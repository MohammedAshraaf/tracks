1
00:00:00,000 --> 00:00:05,340

2
00:00:05,340 --> 00:00:07,370
>> DOUG LLOYD: So we've
done a lot of work in C,

3
00:00:07,370 --> 00:00:09,536
and C is a really cool
language because it gives you

4
00:00:09,536 --> 00:00:12,840
the ability to dive really
low level into your programs.

5
00:00:12,840 --> 00:00:16,810
We get to do things as
really minute as manipulating

6
00:00:16,810 --> 00:00:18,800
individual bytes of memory.

7
00:00:18,800 --> 00:00:21,420
Recall that pointers really
allow us that flexibility.

8
00:00:21,420 --> 00:00:25,260
>> But do we always need to have
that fine-grain level of detail

9
00:00:25,260 --> 00:00:26,820
in our programs?

10
00:00:26,820 --> 00:00:28,210
Probably not, right?

11
00:00:28,210 --> 00:00:30,376
And if we're going to have
a trade-off between being

12
00:00:30,376 --> 00:00:32,911
able to do really, really
minute things and really, really

13
00:00:32,911 --> 00:00:35,910
big things that we don't have to think
about, we don't have to implement

14
00:00:35,910 --> 00:00:40,290
these really big ideas if
they're already built in for us,

15
00:00:40,290 --> 00:00:43,980
generally for building big
programs or big projects,

16
00:00:43,980 --> 00:00:49,130
we're probably going to err on the side
of having more language stuff built in

17
00:00:49,130 --> 00:00:51,300
for us, instead of having
the low-level stuff.

18
00:00:51,300 --> 00:00:53,970
And that's where PHP really comes in.

19
00:00:53,970 --> 00:00:58,200
>> Now, one of the reasons
that we teach PHP in CS50

20
00:00:58,200 --> 00:01:01,020
is that it's heavily inspired by
C. And in fact, in my opinion,

21
00:01:01,020 --> 00:01:05,140
there are really two
progenitor languages that

22
00:01:05,140 --> 00:01:08,200
are very common nowadays.

23
00:01:08,200 --> 00:01:10,110
C and LISP.

24
00:01:10,110 --> 00:01:13,280
And they're progenitor languages
because every other modern programming

25
00:01:13,280 --> 00:01:17,380
language that has developed
since then is inspired

26
00:01:17,380 --> 00:01:20,330
by one or the other syntactically.

27
00:01:20,330 --> 00:01:26,160
PHP is very similar syntactically
to C, whereas languages like Scheme,

28
00:01:26,160 --> 00:01:27,900
for example, which
you may have heard of,

29
00:01:27,900 --> 00:01:32,070
is heavily inspired by a language
called LISP, which is an older language.

30
00:01:32,070 --> 00:01:34,220
>> So the reason we teach
PHP in CS50 is that,

31
00:01:34,220 --> 00:01:37,730
by knowing C as fundamentally
as you do at this point,

32
00:01:37,730 --> 00:01:41,280
picking up PHP, which gives you the
ability to do much higher level things

33
00:01:41,280 --> 00:01:44,710
than C does, isn't
that much of a hurdle,

34
00:01:44,710 --> 00:01:48,230
because you already have the
basic idea of the syntax.

35
00:01:48,230 --> 00:01:50,590
C's been around for almost
45 years at this point.

36
00:01:50,590 --> 00:01:52,780
PHP's been around for about 20 years.

37
00:01:52,780 --> 00:01:57,080
And in that 25 years
in between, programmers

38
00:01:57,080 --> 00:02:01,540
determined that they would much
rather have higher level abilities,

39
00:02:01,540 --> 00:02:04,970
and the mistakes and struggles
of the 20 years in between

40
00:02:04,970 --> 00:02:08,210
led to PHP and other modern languages.

41
00:02:08,210 --> 00:02:11,039
>> PHP's a great choice of
language for software

42
00:02:11,039 --> 00:02:14,042
that allow-- for
software that-- where you

43
00:02:14,042 --> 00:02:16,250
need to do things that in
C are actually complicated.

44
00:02:16,250 --> 00:02:18,480
So for example, working
with strings in C

45
00:02:18,480 --> 00:02:21,709
is very complicated, because
as we know, strings in C

46
00:02:21,709 --> 00:02:23,250
are really just arrays of characters.

47
00:02:23,250 --> 00:02:25,230
It's not a built-in data type.

48
00:02:25,230 --> 00:02:28,220
Or perhaps more fundamentally,
something we didn't even cover in C,

49
00:02:28,220 --> 00:02:30,360
what if you need to do
some computer networking?

50
00:02:30,360 --> 00:02:30,860
All right?

51
00:02:30,860 --> 00:02:34,920
>> C has the ability to do it, but it's so
arcane and so difficult to actually do.

52
00:02:34,920 --> 00:02:37,580
Wouldn't it be nice if the
language had a built-in, easy way

53
00:02:37,580 --> 00:02:38,910
to implement networking?

54
00:02:38,910 --> 00:02:43,420
And PHP is a language that makes that,
or facilitates that, quite a bit more.

55
00:02:43,420 --> 00:02:47,740
As I said, PHP is very heavily inspired
by C. The syntax is very similar.

56
00:02:47,740 --> 00:02:51,760
And so it should hopefully make the
transition from one to the other

57
00:02:51,760 --> 00:02:54,710
a little bit softer than some
other languages might be.

58
00:02:54,710 --> 00:02:58,800
>> To start writing PHP, just open up
a file with the .php file extension.

59
00:02:58,800 --> 00:03:00,670
Technically this isn't
actually required,

60
00:03:00,670 --> 00:03:04,495
but if you want things like syntax
highlighting in IDE, so that type

61
00:03:04,495 --> 00:03:07,620
names, or variable names, functions,
you know, the keywords of the language

62
00:03:07,620 --> 00:03:10,090
are highlighted in a
specific color, you generally

63
00:03:10,090 --> 00:03:14,020
want to name your files with
a particular file extension.

64
00:03:14,020 --> 00:03:18,430
So we've named our file with a .php
extension, but then also with PHP,

65
00:03:18,430 --> 00:03:23,310
all the PHP code we write in that
file has to be enclosed in these PHP

66
00:03:23,310 --> 00:03:25,190
delimiters that we see
here on the screen.

67
00:03:25,190 --> 00:03:27,910
Angle bracket ?php to start.

68
00:03:27,910 --> 00:03:30,860
Then we write all of our PHP
code that we want in between.

69
00:03:30,860 --> 00:03:32,260
And then ?

70
00:03:32,260 --> 00:03:34,710
angle bracket to close.

71
00:03:34,710 --> 00:03:37,170
>> If we don't do this, then
what's going to happen?

72
00:03:37,170 --> 00:03:38,170
It's not going to crash.

73
00:03:38,170 --> 00:03:39,410
It's not going to
really ruin our program.

74
00:03:39,410 --> 00:03:41,440
But it's not going to have
the effect that we want.

75
00:03:41,440 --> 00:03:44,540
What's going to happen, really, is
that when we try and run this program,

76
00:03:44,540 --> 00:03:50,330
everything not between those delimiters
is going to be printed out verbatim.

77
00:03:50,330 --> 00:03:52,210
It's not going to
actually execute the code,

78
00:03:52,210 --> 00:03:56,010
it's going to just
print it out verbatim.

79
00:03:56,010 --> 00:03:57,320
>> Now why is the case?

80
00:03:57,320 --> 00:04:00,416
So C is what's known
as a compiled language.

81
00:04:00,416 --> 00:04:03,040
You're probably familiar with
the step of making your programs,

82
00:04:03,040 --> 00:04:07,820
turning the .c files and .h files
into a single executable with make,

83
00:04:07,820 --> 00:04:11,130
in particular using
Clang as our compiler.

84
00:04:11,130 --> 00:04:13,030
PHP, though, doesn't
have this equivalent.

85
00:04:13,030 --> 00:04:15,600
PHP is what's called an
interpreted language.

86
00:04:15,600 --> 00:04:16,760
And what does that mean?

87
00:04:16,760 --> 00:04:20,680
>> Well, it means we don't have to convert
our source code to zeros and ones

88
00:04:20,680 --> 00:04:21,470
beforehand.

89
00:04:21,470 --> 00:04:23,900
Rather, there's a program,
which is also called

90
00:04:23,900 --> 00:04:29,771
PHP, that understands PHP and
can sort of make it on the fly.

91
00:04:29,771 --> 00:04:32,520
That's not really exactly accurate,
but it's a pretty good analogy

92
00:04:32,520 --> 00:04:33,760
of what's happening.

93
00:04:33,760 --> 00:04:37,230
It's interpreting those
zeroes and ones on the fly.

94
00:04:37,230 --> 00:04:40,160
And so if it doesn't know
how to process something,

95
00:04:40,160 --> 00:04:42,800
if it doesn't know how to
process PHP, you probably

96
00:04:42,800 --> 00:04:44,680
wanted to put that text in there, right?

97
00:04:44,680 --> 00:04:48,960
>> You probably wanted to put the code in
there, even if it's not between PHP--

98
00:04:48,960 --> 00:04:50,035
the PHP delimiters.

99
00:04:50,035 --> 00:04:51,910
But-- so it's not going
to delete it for you,

100
00:04:51,910 --> 00:04:53,576
it's just going to basically discard it.

101
00:04:53,576 --> 00:04:55,550
So it's going to print
it out to the screen.

102
00:04:55,550 --> 00:04:57,150
>> This seems like it's a bad
thing, but actually it's

103
00:04:57,150 --> 00:04:58,220
going to be a really
good thing, as we'll

104
00:04:58,220 --> 00:05:00,390
see when we talk about
PHP web development,

105
00:05:00,390 --> 00:05:04,010
because it means we can
intersperse PHP and HTML.

106
00:05:04,010 --> 00:05:06,640
We can use them together to
create a more dynamic web page.

107
00:05:06,640 --> 00:05:10,650
But more on that in the
video on PHP web development.

108
00:05:10,650 --> 00:05:12,021
>> So what is the syntax of PHP?

109
00:05:12,021 --> 00:05:13,520
That's what this video is all about.

110
00:05:13,520 --> 00:05:14,850
Let's talk about it.

111
00:05:14,850 --> 00:05:16,490
>> So to start out, variables.

112
00:05:16,490 --> 00:05:18,030
PHP variables exist.

113
00:05:18,030 --> 00:05:20,067
There are just two big
differences from C.

114
00:05:20,067 --> 00:05:21,900
The first is that there's
no type specifier.

115
00:05:21,900 --> 00:05:24,245
We don't have to say int,
char, float, all that stuff.

116
00:05:24,245 --> 00:05:25,620
We don't have to do that anymore.

117
00:05:25,620 --> 00:05:26,810
PHP is a modern language.

118
00:05:26,810 --> 00:05:28,910
It can figure out what you're
trying to do or make a best

119
00:05:28,910 --> 00:05:30,451
guess as to what you're trying to do.

120
00:05:30,451 --> 00:05:31,700
So that's pretty nice.

121
00:05:31,700 --> 00:05:35,330
>> The other thing is that all variable
names have to start with a dollar sign.

122
00:05:35,330 --> 00:05:36,940
That's just something to get used to.

123
00:05:36,940 --> 00:05:39,496
It's a little weird, because
it's so that PHP can understand

124
00:05:39,496 --> 00:05:40,870
what's a variable and what's not.

125
00:05:40,870 --> 00:05:43,340
So every variable name
starts with a dollar sign.

126
00:05:43,340 --> 00:05:46,884
So in C we might say something
like this, int x = 54.

127
00:05:46,884 --> 00:05:48,550
We don't have to do that anymore in PHP.

128
00:05:48,550 --> 00:05:52,540
We can just say $x = 54.

129
00:05:52,540 --> 00:05:55,920
And we could say, for example, in C,
if we had pound-included the CS50 .h

130
00:05:55,920 --> 00:06:00,314
header file, we could say
string phrase = "This is CS50."

131
00:06:00,314 --> 00:06:01,980
We don't have to do that in PHP, though.

132
00:06:01,980 --> 00:06:04,865
We can just say $phrase
= "This is CS50."

133
00:06:04,865 --> 00:06:08,760
And in fact, string is now
a built-in data type in PHP,

134
00:06:08,760 --> 00:06:10,950
or rather PHP understands
what a string is.

135
00:06:10,950 --> 00:06:15,612
It's separate from an array
of characters like it is in C.

136
00:06:15,612 --> 00:06:17,570
All your favorite
conditional statements from C

137
00:06:17,570 --> 00:06:19,520
are still available for you to use.

138
00:06:19,520 --> 00:06:21,140
So no big transition there.

139
00:06:21,140 --> 00:06:23,400
We can say-- we can have
if statements like this.

140
00:06:23,400 --> 00:06:28,210
if $y 43, or $z = 15.

141
00:06:28,210 --> 00:06:29,690
So that's pretty straightforward.

142
00:06:29,690 --> 00:06:31,980
We can have if and else.

143
00:06:31,980 --> 00:06:34,210
We can have if and else if.

144
00:06:34,210 --> 00:06:36,430
>> And notice something
pretty nice here, and this

145
00:06:36,430 --> 00:06:39,620
is sort of one of those
advantages of PHP versus C, notice

146
00:06:39,620 --> 00:06:41,510
what function we're not using here?

147
00:06:41,510 --> 00:06:47,737
We're using == to compare a
variable, $name, to a string.

148
00:06:47,737 --> 00:06:49,070
We couldn't do that in C, right?

149
00:06:49,070 --> 00:06:53,200
We had to use a function called
StrComp or StrEndComp or any

150
00:06:53,200 --> 00:06:54,840
of its related cousins.

151
00:06:54,840 --> 00:06:56,980
>> And so already we see these advantages.

152
00:06:56,980 --> 00:07:00,930
We don't have to do something
as silly or perhaps unintuitive

153
00:07:00,930 --> 00:07:03,540
as call a function called
StrComp if I just want to test

154
00:07:03,540 --> 00:07:05,237
whether a value equals a string.

155
00:07:05,237 --> 00:07:07,820
I could just use equals equals,
like I could do anything else.

156
00:07:07,820 --> 00:07:09,560
So there's an advantage.

157
00:07:09,560 --> 00:07:13,350
>> Sometimes, by the way, you might
see else if as one word, elseif.

158
00:07:13,350 --> 00:07:14,910
And that's OK in PHP as well.

159
00:07:14,910 --> 00:07:17,020
So sometimes you might see that.

160
00:07:17,020 --> 00:07:17,790
It's not a typo.

161
00:07:17,790 --> 00:07:21,830
PHP actually understands elseif.

162
00:07:21,830 --> 00:07:23,980
I don't know why they
decided to implement that,

163
00:07:23,980 --> 00:07:28,220
but as we've seen many times
throughout our videos so far,

164
00:07:28,220 --> 00:07:30,460
we programmers love it if
we can do things quickly,

165
00:07:30,460 --> 00:07:33,660
so getting rid of that space
is apparently a big advantage.

166
00:07:33,660 --> 00:07:34,800
>> So that's if and elseif.

167
00:07:34,800 --> 00:07:37,540
We also have the ternary operator,
recall question mark colon,

168
00:07:37,540 --> 00:07:43,262
for really short form if else
or conditional branching.

169
00:07:43,262 --> 00:07:45,470
And apparently, in this,
what we're trying to do here

170
00:07:45,470 --> 00:07:49,720
is assign the variable
$letter either true or false,

171
00:07:49,720 --> 00:07:54,110
depending on whether $var
is an alphabetic character.

172
00:07:54,110 --> 00:07:57,320
So this is pretty similar to isalpha
that we're familiar with from C.

173
00:07:57,320 --> 00:07:59,010
This is sort of the equivalent in PHP.

174
00:07:59,010 --> 00:08:01,550
The function is apparently
called ctype_alpha,

175
00:08:01,550 --> 00:08:03,450
but that's how we do it in PHP.

176
00:08:03,450 --> 00:08:08,560
So all this is going to be is, if
$var is a letter, $letter is true.

177
00:08:08,560 --> 00:08:13,820
If $var is not a letter,
$letter is false.

178
00:08:13,820 --> 00:08:15,820
>> We also have switch statements still.

179
00:08:15,820 --> 00:08:17,870
We recall those from C as well.

180
00:08:17,870 --> 00:08:22,480
At the very top there, that's how we do
something like get int or get string.

181
00:08:22,480 --> 00:08:23,845
So PHP has that built in.

182
00:08:23,845 --> 00:08:25,470
We don't need the CS50 library anymore.

183
00:08:25,470 --> 00:08:27,237
We can just use the function readline.

184
00:08:27,237 --> 00:08:29,820
What that's going to do is print
out the message, "Your state,

185
00:08:29,820 --> 00:08:33,820
please," and then blinking prompt
waiting for the user to input

186
00:08:33,820 --> 00:08:34,739
some information.

187
00:08:34,739 --> 00:08:36,530
Now notice what else
we can do with switch.

188
00:08:36,530 --> 00:08:39,105
If you've used it before,
you may recall that switch

189
00:08:39,105 --> 00:08:44,960
is limited pretty much to integers and
characters, but now we can use strings.

190
00:08:44,960 --> 00:08:50,190
And in fact, the switch statement
in PHP is quite a bit more flexible

191
00:08:50,190 --> 00:08:54,880
than its cousin from C.

192
00:08:54,880 --> 00:08:55,380
Loops.

193
00:08:55,380 --> 00:08:58,130
Just like conditionals, all of
your old favorites are still there.

194
00:08:58,130 --> 00:09:00,740
We have while loops that count
from 1 to 100 in this case.

195
00:09:00,740 --> 00:09:03,940
We have do while loops
that count from 1 to 100,

196
00:09:03,940 --> 00:09:06,200
and we have for loops
that count from 1 to 100.

197
00:09:06,200 --> 00:09:07,220
So no big leap there.

198
00:09:07,220 --> 00:09:09,360
The syntax is pretty
much exactly the same,

199
00:09:09,360 --> 00:09:11,760
except now we're using
dollar sign variable instead

200
00:09:11,760 --> 00:09:17,260
of declaring integer variables or
something like that for our counters.

201
00:09:17,260 --> 00:09:20,090
>> Here's where things get a
lot better than C, though.

202
00:09:20,090 --> 00:09:21,020
Arrays.

203
00:09:21,020 --> 00:09:23,020
So recall when we were
talking about C, in order

204
00:09:23,020 --> 00:09:25,560
for us to grow and shrink
sets of information,

205
00:09:25,560 --> 00:09:28,310
we needed to sort of default
to this idea of a linked list,

206
00:09:28,310 --> 00:09:30,780
because C arrays were fixed in size.

207
00:09:30,780 --> 00:09:31,800
We couldn't shrink them.

208
00:09:31,800 --> 00:09:32,930
We couldn't grow them.

209
00:09:32,930 --> 00:09:36,074
We had to reallocate memory
and do all this madness

210
00:09:36,074 --> 00:09:38,490
or use linked lists, which
take up quite a bit more space.

211
00:09:38,490 --> 00:09:41,590
But in PHP, arrays are
not fixed in size anymore.

212
00:09:41,590 --> 00:09:43,240
They can grow and they can shrink.

213
00:09:43,240 --> 00:09:46,660
So again, these 20 years that existed
between the first release of C

214
00:09:46,660 --> 00:09:49,440
and the first release PHP,
we decided that, you know,

215
00:09:49,440 --> 00:09:51,670
it would be really great
if we could do this.

216
00:09:51,670 --> 00:09:54,100
And so we implemented this.

217
00:09:54,100 --> 00:09:58,040
>> So PHP arrays are not fixed in
size, and because PHP doesn't really

218
00:09:58,040 --> 00:10:03,090
have programmer front-facing
notions of types,

219
00:10:03,090 --> 00:10:05,110
we can mix data types
in our arrays, too.

220
00:10:05,110 --> 00:10:08,100
So we don't even have to use all
integers or all floating points,

221
00:10:08,100 --> 00:10:12,826
we can have a mix of all
different kinds in a single array.

222
00:10:12,826 --> 00:10:14,700
Declaring an array is
pretty straightforward.

223
00:10:14,700 --> 00:10:16,116
It's just like any other variable.

224
00:10:16,116 --> 00:10:20,020
$nums = array (1, 2, 3,
4), array being a function

225
00:10:20,020 --> 00:10:22,760
that's built into PHP that
will create an array for you.

226
00:10:22,760 --> 00:10:28,315
This creates an array of four values,
numbers in this case, called $nums.

227
00:10:28,315 --> 00:10:29,940
And there's more than one way to do it.

228
00:10:29,940 --> 00:10:32,420
And we're going to
see this a lot in PHP.

229
00:10:32,420 --> 00:10:36,380
PHP has been developed by many different
people and grows and grows and grows.

230
00:10:36,380 --> 00:10:40,050
There's usually not just two or
three ways to do something in PHP,

231
00:10:40,050 --> 00:10:42,170
there's usually like 10 or 20.

232
00:10:42,170 --> 00:10:45,300
Here's just another common
way to declare an array.

233
00:10:45,300 --> 00:10:48,310
$nums= square bracket 1, 2, 3, 4.

234
00:10:48,310 --> 00:10:53,170
So this is sort of similar to C's angle
br-- curly brace notation, rather. $--

235
00:10:53,170 --> 00:10:58,525
or it would be int nums square
brackets equals curly brace 1, 2, 3, 4.

236
00:10:58,525 --> 00:11:02,710
In PHP it's $nums = square
brackets 1, 2, 3, 4.

237
00:11:02,710 --> 00:11:08,920
But both of these examples here give me
an array of four in this case integers.

238
00:11:08,920 --> 00:11:10,920
>> What if I want to tack something on now?

239
00:11:10,920 --> 00:11:14,760
Well I can just say $nums 4, which
again, we're still counting from 0 here

240
00:11:14,760 --> 00:11:17,800
in PHP, would be the fifth
element of the array.

241
00:11:17,800 --> 00:11:18,990
I can just say that.

242
00:11:18,990 --> 00:11:22,860
I'm not going to suffer a seg
fault, because my array is just

243
00:11:22,860 --> 00:11:24,337
going to grow to accommodate that.

244
00:11:24,337 --> 00:11:25,420
That's pretty nice, right?

245
00:11:25,420 --> 00:11:28,400
And in fact, I don't even need to
specify where I want to put it.

246
00:11:28,400 --> 00:11:31,220
I can just say this and just
tack it right on to the end,

247
00:11:31,220 --> 00:11:34,099
or I could even just
say $nums 20 or 1,000.

248
00:11:34,099 --> 00:11:35,140
It doesn't really matter.

249
00:11:35,140 --> 00:11:38,330
It's still just going to
tack it right on to the end.

250
00:11:38,330 --> 00:11:41,490
>> So I can grow, and as-- we're
not going to cover it in here,

251
00:11:41,490 --> 00:11:45,360
but I can splice or strip
elements out of the array as well,

252
00:11:45,360 --> 00:11:50,064
and the array will shrink to accommodate
that now missing or empty space.

253
00:11:50,064 --> 00:11:52,230
There's another way to tack
something onto an array,

254
00:11:52,230 --> 00:11:54,330
which is a function called array_push.

255
00:11:54,330 --> 00:11:57,860
So again, just this idea of being
able to do things many different ways.

256
00:11:57,860 --> 00:12:01,950
So we've seen three different ways now
to tack another element onto an array.

257
00:12:01,950 --> 00:12:06,900
So this adds another element
to the end of the $nums array.

258
00:12:06,900 --> 00:12:08,340
And we can mix up our data types.

259
00:12:08,340 --> 00:12:13,110
So I could have an array of not
1, 2, 3, 4, but 1, true, 3, 4,

260
00:12:13,110 --> 00:12:16,420
where true is a Boolean, and then
if I want to tack on another element

261
00:12:16,420 --> 00:12:20,860
to that array, perhaps a string,
the string "five," I could do that.

262
00:12:20,860 --> 00:12:26,110
And now my array would
be 1, true, 3, 4, five.

263
00:12:26,110 --> 00:12:28,640
The word five, not the integer 5.

264
00:12:28,640 --> 00:12:31,270
So a lot of flexibility there.

265
00:12:31,270 --> 00:12:33,290
>> The flexibility gets
even better, though,

266
00:12:33,290 --> 00:12:37,530
because PHP has support for something
called an associative array.

267
00:12:37,530 --> 00:12:40,660
And we sort of vaguely talked
about associative arrays in C

268
00:12:40,660 --> 00:12:44,740
in the context of hash tables, because
what associative arrays are really all

269
00:12:44,740 --> 00:12:48,950
about are making key
value pair mappings.

270
00:12:48,950 --> 00:12:53,410
And in this case, the keys-- if
we're familiar with arrays from C,

271
00:12:53,410 --> 00:12:55,440
the keys are index numbers.

272
00:12:55,440 --> 00:12:57,530
0, 1, 2, 3.

273
00:12:57,530 --> 00:13:03,070
And the values are what we find that
array 0, array 1, array 2, and so on.

274
00:13:03,070 --> 00:13:06,310
So the keys are indexes,
and the values are

275
00:13:06,310 --> 00:13:10,060
what is in that array location,
specified by that index.

276
00:13:10,060 --> 00:13:15,130
>> But in PHP, we don't have to do this
notion of array 0, array 1, array 2

277
00:13:15,130 --> 00:13:15,830
anymore.

278
00:13:15,830 --> 00:13:21,025
We can now use actual words
to map keys to values.

279
00:13:21,025 --> 00:13:22,650
And so I could say something like this.

280
00:13:22,650 --> 00:13:26,710
I could create an array using the
square bracket syntax as follows.

281
00:13:26,710 --> 00:13:30,685
$pizzas = square bracket
"cheese" and then

282
00:13:30,685 --> 00:13:37,210
this sort of double arrow notation,
8.99, "pepperoni," arrow 10.99-- 9.99,

283
00:13:37,210 --> 00:13:37,880
and so on.

284
00:13:37,880 --> 00:13:39,060
And so what's going on here?

285
00:13:39,060 --> 00:13:41,040
What am I actually doing?

286
00:13:41,040 --> 00:13:43,990
I'm creating key value pair mappings.

287
00:13:43,990 --> 00:13:49,060
So instead of saying, for example,
pizzas 0, pieces 1, pizzas 2,

288
00:13:49,060 --> 00:13:52,350
I can now say pizzas
cheese, pizzas pepperoni,

289
00:13:52,350 --> 00:13:55,120
and refer to the values
associated with them.

290
00:13:55,120 --> 00:13:56,970
>> So here are our keys in green.

291
00:13:56,970 --> 00:13:59,870
Cheese, pepperoni,
vegetable, buffalo chicken.

292
00:13:59,870 --> 00:14:04,200
Here is the arrow that makes
this key value pair mapping.

293
00:14:04,200 --> 00:14:07,420
And then here are the values
at that array location.

294
00:14:07,420 --> 00:14:10,330
So it's like saying array 0 equals 8.99.

295
00:14:10,330 --> 00:14:11,720
The key is 0.

296
00:14:11,720 --> 00:14:13,600
The value is 8.99.

297
00:14:13,600 --> 00:14:19,370
I can now say array cheese, or in this
case pizzas cheese, cheese is the key,

298
00:14:19,370 --> 00:14:23,340
and what I find at
pizzas cheese is 8.99.

299
00:14:23,340 --> 00:14:25,540
That's the value that I find there.

300
00:14:25,540 --> 00:14:28,124
>> So I can say things like.
$pizza cheese = 7.99.

301
00:14:28,124 --> 00:14:29,040
Say I'm having a sale.

302
00:14:29,040 --> 00:14:31,750
I want dis-- I want to drop
the price of the cheese pizza.

303
00:14:31,750 --> 00:14:35,620
Or I can use the vegetable
pizza as part of a condition,

304
00:14:35,620 --> 00:14:39,990
or I can add a new element to my
array, just like I could do previously.

305
00:14:39,990 --> 00:14:44,680
I can add a new element to this
associative array with the key "bacon"

306
00:14:44,680 --> 00:14:49,250
and the value 13.49.

307
00:14:49,250 --> 00:14:53,820
>> But this sort of introduces a problem,
if you think about it for a second.

308
00:14:53,820 --> 00:14:55,721
How would we iterate through this array?

309
00:14:55,721 --> 00:14:56,220
Right?

310
00:14:56,220 --> 00:14:59,820
In C, we would just have a
for loop, typically, that

311
00:14:59,820 --> 00:15:03,650
would run from 0 to the
size of the array minus 1.

312
00:15:03,650 --> 00:15:08,060
The array has n elements in at, the
valid indexes are 0 to n minus 1.

313
00:15:08,060 --> 00:15:11,530
So we could use a for loop to
step through every single element.

314
00:15:11,530 --> 00:15:13,530
>> But that's not really
the case anymore, right?

315
00:15:13,530 --> 00:15:17,360
Now where we have key value pair
mappings where the keys are words,

316
00:15:17,360 --> 00:15:19,970
how do we iterate over all of the words?

317
00:15:19,970 --> 00:15:22,420
Well, fortunately, PHP has
a way to deal with this too,

318
00:15:22,420 --> 00:15:24,580
and so we'll jump back
to loops for a second

319
00:15:24,580 --> 00:15:30,780
to introduce a fourth kind of loop that
exists in PHP called a foreach loop.

320
00:15:30,780 --> 00:15:34,430
And what a foreach loop does is
it's basically the same idea.

321
00:15:34,430 --> 00:15:36,060
You can use it for any kind of array.

322
00:15:36,060 --> 00:15:38,100
But it's basically the
same idea as a for loop,

323
00:15:38,100 --> 00:15:40,750
except instead of using
index numbers, you just

324
00:15:40,750 --> 00:15:45,830
have this weird syntax where
you call every single element

325
00:15:45,830 --> 00:15:47,550
a name for the purposes of this loop.

326
00:15:47,550 --> 00:15:49,258
>> So in this case,
foreach($array as $key).

327
00:15:49,258 --> 00:15:52,900

328
00:15:52,900 --> 00:15:56,450
Basically, as that comment notes,
inside of that foreach loop,

329
00:15:56,450 --> 00:16:00,466
it's going to go over every single
element of $array, which is typically

330
00:16:00,466 --> 00:16:03,340
going to be an associative array,
but can really be any kind of array

331
00:16:03,340 --> 00:16:05,419
that you want in PHP.

332
00:16:05,419 --> 00:16:07,210
And every time that in
a for loop you might

333
00:16:07,210 --> 00:16:13,780
have said $array square brackets
$i, you could just say $key.

334
00:16:13,780 --> 00:16:22,340
So that $key becomes an alias for every
index of your PHP associative array,

335
00:16:22,340 --> 00:16:23,710
and so you can use it like that.

336
00:16:23,710 --> 00:16:25,897
>> So for example, we've
now got our pizzas array.

337
00:16:25,897 --> 00:16:27,730
I've kind of tucked it
into the corner there

338
00:16:27,730 --> 00:16:31,080
so we can use it to do a quick example.

339
00:16:31,080 --> 00:16:36,420
If I say foreach($pizzas as
$pizza), well, what's happening?

340
00:16:36,420 --> 00:16:42,400
Well, I'm going to iterate through every
single element of the array $pizzas,

341
00:16:42,400 --> 00:16:46,670
and in so doing, I'm going to call
every element, when I'm inside

342
00:16:46,670 --> 00:16:49,400
of the body of that for loop, $pizza.

343
00:16:49,400 --> 00:16:52,440
>> So that's sort of a
stand-in, recall, that $pizza

344
00:16:52,440 --> 00:16:59,140
is a stand-in for saying
$pizzas square brackets $i

345
00:16:59,140 --> 00:17:03,370
if we were using a for loop, where we
could go from $i = 0 to, in this case,

346
00:17:03,370 --> 00:17:06,089
$i = 3.

347
00:17:06,089 --> 00:17:09,780
If we didn't have key value pairs
here, this would be element 0, 1, 2, 3,

348
00:17:09,780 --> 00:17:16,390
and we would use a for loop to go
$pizzas 0, $pizzas 1, $pizzas 2,

349
00:17:16,390 --> 00:17:17,750
$pizzas 3.

350
00:17:17,750 --> 00:17:23,130
So now just $pizza is substituting
for that individual key.

351
00:17:23,130 --> 00:17:25,630
>> So what is this going to print out?

352
00:17:25,630 --> 00:17:29,030
I'm printing out $pizza.

353
00:17:29,030 --> 00:17:35,270
What am I going to find at--
if I print out $pizzas, $i?

354
00:17:35,270 --> 00:17:35,770
Right?

355
00:17:35,770 --> 00:17:38,680
If I'm going to print out
the ith element of pizzas,

356
00:17:38,680 --> 00:17:40,070
what am I going to print?

357
00:17:40,070 --> 00:17:42,580
I'm going to print out the
values at that location, right?

358
00:17:42,580 --> 00:17:45,370
Like if we were doing
this in the context of C,

359
00:17:45,370 --> 00:17:49,786
we don't usually use our iterator
variable, int i = 0, i is less than 3,

360
00:17:49,786 --> 00:17:52,900
i++, to print out 0, 1, 2, 3.

361
00:17:52,900 --> 00:17:57,500
We're printing out array 0,
array 1, array 2, array 3.

362
00:17:57,500 --> 00:17:59,580
And so what this prints out is this.

363
00:17:59,580 --> 00:18:01,150
It's the list of prices.

364
00:18:01,150 --> 00:18:05,750
8.99, 9.99, 10.99, 11.99.

365
00:18:05,750 --> 00:18:06,900
>> Now a quick note here.

366
00:18:06,900 --> 00:18:10,900
A foreach loop does not necessarily
print out things in order.

367
00:18:10,900 --> 00:18:12,770
It's not guaranteed.

368
00:18:12,770 --> 00:18:13,550
It usually does.

369
00:18:13,550 --> 00:18:17,667
It's usually based on the order in
which elements are added to the array,

370
00:18:17,667 --> 00:18:18,750
so just bear that in mind.

371
00:18:18,750 --> 00:18:20,830
It might not be in order.

372
00:18:20,830 --> 00:18:23,930
But a foreach loop will iterate
across every single element

373
00:18:23,930 --> 00:18:25,060
of the array in question.

374
00:18:25,060 --> 00:18:27,980
In this case, again,
that array is $pizzas.

375
00:18:27,980 --> 00:18:32,920
>> I can change the syntax, though, if
I want both the key and the value.

376
00:18:32,920 --> 00:18:37,179
Instead of saying $pizzas
as $pizza, I can say this.

377
00:18:37,179 --> 00:18:39,470
And if you look at what I've
highlighted in green here,

378
00:18:39,470 --> 00:18:42,130
it looks like a key value pair mapping.

379
00:18:42,130 --> 00:18:45,980
And so if you-- even if you are not
entirely sure what it's going to do,

380
00:18:45,980 --> 00:18:49,300
you can probably guess
that $topping is going

381
00:18:49,300 --> 00:18:53,800
to be the key in this case and
$price is going to be the value.

382
00:18:53,800 --> 00:18:59,200
So I'm substituting now every element
of $pizzas as a key value pair,

383
00:18:59,200 --> 00:19:03,900
and now I can refer to the key and
the value, which might in handy,

384
00:19:03,900 --> 00:19:05,590
for example, as follows.

385
00:19:05,590 --> 00:19:10,170
>> "A whole"-- this is a lot of
printing going on here-- "A whole"

386
00:19:10,170 --> 00:19:17,300
topping "pizza costs $" price, and then
I print out a period and a backslash n.

387
00:19:17,300 --> 00:19:23,420
So now, notice again I have access to
a key, $topping, and a value, $price.

388
00:19:23,420 --> 00:19:26,647
So can you guess what this
is going to print out?

389
00:19:26,647 --> 00:19:29,480
There's a lot of print statements,
but there's only one backslash n,

390
00:19:29,480 --> 00:19:33,410
so it's going to print something on
an entire-- on a single line of code.

391
00:19:33,410 --> 00:19:36,965
>> If I can refer to the key
and the value, then now,

392
00:19:36,965 --> 00:19:39,090
instead of just being able
to print out the prices,

393
00:19:39,090 --> 00:19:41,330
I can print out something like this.

394
00:19:41,330 --> 00:19:43,780
"A whole cheese pizza costs $8.99."

395
00:19:43,780 --> 00:19:47,150
And now I'm using all of the keys--
cheese, pepperoni, vegetable,

396
00:19:47,150 --> 00:19:49,640
buffalo chicken-- and the values.

397
00:19:49,640 --> 00:19:53,980
8.99, 9.99, 10.99, 11.99 So
that's just a different way

398
00:19:53,980 --> 00:19:57,840
to do a foreach loop that instead of
just giving you access to the values,

399
00:19:57,840 --> 00:20:02,950
it just gives you-- it gives you
access to the keys and the values.

400
00:20:02,950 --> 00:20:04,411
>> So printing out information.

401
00:20:04,411 --> 00:20:07,410
I've already done it a couple of
different ways, you might have noticed.

402
00:20:07,410 --> 00:20:11,080
The two functions we've primarily
seen are print and echo.

403
00:20:11,080 --> 00:20:14,380
And for pretty much all intents and
purposes, they're exactly the same.

404
00:20:14,380 --> 00:20:17,130
They're-- there's a very subtle
difference that's not even worth

405
00:20:17,130 --> 00:20:21,130
getting into, but basically everywhere
you can use print you can probably use

406
00:20:21,130 --> 00:20:22,370
echo as well.

407
00:20:22,370 --> 00:20:23,610
>> And that's not the only two.

408
00:20:23,610 --> 00:20:26,970
PHP has a lot of different
ways to print things out,

409
00:20:26,970 --> 00:20:30,520
and it also has ways to integrate
variables into the middle of string.

410
00:20:30,520 --> 00:20:32,860
So recall from C, do you
remember what function

411
00:20:32,860 --> 00:20:37,580
we can use to substitute variables
into things we want to print out?

412
00:20:37,580 --> 00:20:40,160
You probably use this
function quite a lot.

413
00:20:40,160 --> 00:20:42,290
printf, right?

414
00:20:42,290 --> 00:20:45,290
So this is what we had before inside
of the context of our foreach loop.

415
00:20:45,290 --> 00:20:48,000
We had these five
separate print statements,

416
00:20:48,000 --> 00:20:50,330
because that was the only
way I really knew at the time

417
00:20:50,330 --> 00:20:52,450
how to print out messages.

418
00:20:52,450 --> 00:20:59,560
I didn't know how to integrate the
variable $topping into my PHP code.

419
00:20:59,560 --> 00:21:03,700
Well, if I just taken a wild guess,
printf, it actually would have worked.

420
00:21:03,700 --> 00:21:08,980
printf is a function that I can use
in PHP, just like I can use it in C.

421
00:21:08,980 --> 00:21:11,880
>> And so something like this, printf,
again, we're familiar with that.

422
00:21:11,880 --> 00:21:16,420
The first %s is replaced
with the value of $topping.

423
00:21:16,420 --> 00:21:19,700
The second %s is replaced
with the value of $price.

424
00:21:19,700 --> 00:21:22,630
And so I'm interpellating,
which is just a fancy way

425
00:21:22,630 --> 00:21:25,400
of saying I'm sticking the
variables into that location.

426
00:21:25,400 --> 00:21:31,000
So I'm plugging in $topping where the
red %s is and $price where the blue %s

427
00:21:31,000 --> 00:21:36,060
is, and then I would get the message,
"A whole cheese pizza costs $8.99."

428
00:21:36,060 --> 00:21:37,750
>> Not the only way I can do it, though.

429
00:21:37,750 --> 00:21:39,760
Maybe I would want to use this method.

430
00:21:39,760 --> 00:21:44,890
This is actually what's most commonly
called variable interpellation.

431
00:21:44,890 --> 00:21:45,690
I can use an echo.

432
00:21:45,690 --> 00:21:47,737
I could use a print too, as we'll see.

433
00:21:47,737 --> 00:21:48,820
But what's happening here?

434
00:21:48,820 --> 00:21:51,520
>> First of all, I have to
escape the dollar sign.

435
00:21:51,520 --> 00:21:55,140
Because remember, when we were actually
printing out the prices of the pizzas,

436
00:21:55,140 --> 00:21:59,370
I was actually formatting them as
monetary figures with a dollar sign.

437
00:21:59,370 --> 00:22:05,635
But we're using dollar signs also
to represent variable names in PHP,

438
00:22:05,635 --> 00:22:08,010
and in particular when I'm
using this method of the curly

439
00:22:08,010 --> 00:22:10,040
brace variable
interpellation method, I need

440
00:22:10,040 --> 00:22:13,490
to escape my dollar sign so it doesn't
think I'm talking about a variable.

441
00:22:13,490 --> 00:22:16,920
It's going to actually,
literally print a dollar sign.

442
00:22:16,920 --> 00:22:19,530
>> So sort of analogize it to
what you see at the end there.

443
00:22:19,530 --> 00:22:22,832
It doesn't actually
print backslash n, right?

444
00:22:22,832 --> 00:22:24,290
It prints out a new line character.

445
00:22:24,290 --> 00:22:26,750
This is-- it's not going to
print backslash dollar sign,

446
00:22:26,750 --> 00:22:30,130
it's going to print out just
a dollar sign character.

447
00:22:30,130 --> 00:22:30,640
Same idea.

448
00:22:30,640 --> 00:22:32,760
Escape sequences, what
these things are called.

449
00:22:32,760 --> 00:22:37,080
>> But notice that I am not doing
any sort of %s substitutions,

450
00:22:37,080 --> 00:22:40,050
I'm just literally plugging
in these variables.

451
00:22:40,050 --> 00:22:45,110
And so in this-- what would happen here
is that the value of $topping-- again,

452
00:22:45,110 --> 00:22:48,390
just keeping with what we've been
talking about so far-- cheese would get

453
00:22:48,390 --> 00:22:49,720
plugged in there.

454
00:22:49,720 --> 00:22:54,780
And $price would be whatever value is
at pizzas, square brackets, cheese,

455
00:22:54,780 --> 00:22:56,270
which was 8.99.

456
00:22:56,270 --> 00:23:01,860
And so this would also print out
"A whole cheese pizza costs $8.99."

457
00:23:01,860 --> 00:23:05,160
And like I said, I could use
print here instead of echo,

458
00:23:05,160 --> 00:23:08,040
and the functionality be
pretty much exactly the same.

459
00:23:08,040 --> 00:23:09,660
It would print out the same thing.

460
00:23:09,660 --> 00:23:12,680
>> There's another way to do it,
and this is another advantage

461
00:23:12,680 --> 00:23:14,710
of PHP working with strings.

462
00:23:14,710 --> 00:23:17,130
We can do string concatenation.

463
00:23:17,130 --> 00:23:19,660
We could do this in C, too,
using a function called strcat,

464
00:23:19,660 --> 00:23:21,180
but again, we had to
call separate functions.

465
00:23:21,180 --> 00:23:22,640
It was this whole mess to do.

466
00:23:22,640 --> 00:23:24,590
We had to pound-include string.h.

467
00:23:24,590 --> 00:23:25,780
It was a production, right?

468
00:23:25,780 --> 00:23:30,070
But now I can just use this dot operator
to concatenate strings together.

469
00:23:30,070 --> 00:23:34,910
>> So I'm concatenating "A whole" and
then whatever the value of $topping is,

470
00:23:34,910 --> 00:23:38,860
and then another
string, " pizza costs $"

471
00:23:38,860 --> 00:23:42,340
and then concatenating whatever
the value of $price is,

472
00:23:42,340 --> 00:23:45,670
and then at the very end I'm
tacking on period backslash n.

473
00:23:45,670 --> 00:23:47,926
And so this would also
print out "A whole"-- again,

474
00:23:47,926 --> 00:23:50,550
if we're talking about the first
element of that pizzas array--

475
00:23:50,550 --> 00:23:54,710
"A whole cheese pizza costs $8.99."

476
00:23:54,710 --> 00:24:01,260
Period, backslash n, again, with
the $topping and $price substituting

477
00:24:01,260 --> 00:24:06,580
for what we had specified in our foreach
loop as the key value pair mapping.

478
00:24:06,580 --> 00:24:08,050
>> PHP can handle functions.

479
00:24:08,050 --> 00:24:11,250
Functions were sort of
integral to C, as we saw.

480
00:24:11,250 --> 00:24:14,870
Like variables, we don't need to
specify the return type of the function,

481
00:24:14,870 --> 00:24:16,350
because it doesn't really matter.

482
00:24:16,350 --> 00:24:18,660
And we don't specify the
data types of any parameters,

483
00:24:18,660 --> 00:24:21,410
because they don't really
matter, like we've seen in PHP.

484
00:24:21,410 --> 00:24:24,510
Every function is introduced
with the function keyword.

485
00:24:24,510 --> 00:24:27,920
That's how we indicate to PHP that
what we're talking about is a function.

486
00:24:27,920 --> 00:24:29,720
>> And we don't have to
deal with main at all,

487
00:24:29,720 --> 00:24:33,690
because the interpreter, the PHP
interpreter, works from top to bottom,

488
00:24:33,690 --> 00:24:34,190
regardless.

489
00:24:34,190 --> 00:24:35,640
If it sees you can make
a function call, it'll

490
00:24:35,640 --> 00:24:37,850
go find the function call,
even if it comes later.

491
00:24:37,850 --> 00:24:40,360
But it's going to read from top to
bottom, so we don't need to specify,

492
00:24:40,360 --> 00:24:41,500
here's where you start.

493
00:24:41,500 --> 00:24:46,700
You start on line 1 of your
PHP and work down from there.

494
00:24:46,700 --> 00:24:49,690
>> So here is how we would create
a function called hard_square.

495
00:24:49,690 --> 00:24:54,100
It apparently takes one
parameter, which I'm calling $x.

496
00:24:54,100 --> 00:24:58,424
This function is complicated just
to illustrate various things.

497
00:24:58,424 --> 00:24:59,590
We still have return values.

498
00:24:59,590 --> 00:25:00,870
I'm using a for loop here.

499
00:25:00,870 --> 00:25:04,970
But it's basically just, what this
amounts to is just $x times $x.

500
00:25:04,970 --> 00:25:10,520
What I'm actually doing is just adding
x to 0 x times or $x to zero $x times.

501
00:25:10,520 --> 00:25:15,850
But it's effectively exactly the
same as multiplying $x times $x.

502
00:25:15,850 --> 00:25:18,700
I can still return a value,
in this case $result,

503
00:25:18,700 --> 00:25:22,060
and I've made a function in PHP.

504
00:25:22,060 --> 00:25:24,160
>> Here's how you might use it in context.

505
00:25:24,160 --> 00:25:26,020
So maybe I'm inside of some PHP file.

506
00:25:26,020 --> 00:25:29,240
Notice in blue there that
I've used my PHP delimiters,

507
00:25:29,240 --> 00:25:31,010
angle bracket question mark php.

508
00:25:31,010 --> 00:25:35,180
In between those are all of
the PHP that I want to write.

509
00:25:35,180 --> 00:25:37,840
So I'm apparently going to get--
I'm going to prompt the user

510
00:25:37,840 --> 00:25:41,550
to give me a number, store that
variable, store in that variable $x,

511
00:25:41,550 --> 00:25:43,320
whatever they gave me.

512
00:25:43,320 --> 00:25:48,590
Then I'm going to echo
hard_square of that value,

513
00:25:48,590 --> 00:25:50,370
and apparently going
to tack on a new line

514
00:25:50,370 --> 00:25:53,590
as well, and then later on I'll
define the function hard_square so

515
00:25:53,590 --> 00:25:55,550
that when I make the
call to hard_square,

516
00:25:55,550 --> 00:25:58,160
it knows what I'm talking about.

517
00:25:58,160 --> 00:26:00,705
>> Now, I could also do
something like this.

518
00:26:00,705 --> 00:26:02,050
This is slightly different.

519
00:26:02,050 --> 00:26:04,190
It's almost exactly the
same as what we saw before,

520
00:26:04,190 --> 00:26:08,400
except instead of saying just $x
there as the parameter to hard_square,

521
00:26:08,400 --> 00:26:11,730
I'm saying $x = 10.

522
00:26:11,730 --> 00:26:14,330
So this is an example of
defensive programming,

523
00:26:14,330 --> 00:26:17,070
guarding your programs
against malicious users.

524
00:26:17,070 --> 00:26:20,020
>> This is one way to do some error
checking that we didn't really

525
00:26:20,020 --> 00:26:24,670
have as an option in C. We could never
specify the default value of something.

526
00:26:24,670 --> 00:26:27,010
We always had to check
whether the, for example,

527
00:26:27,010 --> 00:26:30,820
if we made a call to GetString, it was
most proper if immediately after we

528
00:26:30,820 --> 00:26:33,300
checked that, we checked
whether the string

529
00:26:33,300 --> 00:26:35,504
that the user gave us
is not equal to null,

530
00:26:35,504 --> 00:26:37,920
because we don't want to start
working with a null string.

531
00:26:37,920 --> 00:26:39,670
>> Here, this is a way
to guard against that.

532
00:26:39,670 --> 00:26:43,480
If the user doesn't provide us something
somehow, what are we going to do?

533
00:26:43,480 --> 00:26:46,080
Well, we'll just say whatever
they didn't provide us,

534
00:26:46,080 --> 00:26:47,705
we're just going to plug in 10 instead.

535
00:26:47,705 --> 00:26:52,030
So if they didn't give us a value,
just use 10 by default. And so here,

536
00:26:52,030 --> 00:26:53,940
notice that I'm making
a call to hard_square,

537
00:26:53,940 --> 00:26:55,980
but there's no prompt
to the user, right?

538
00:26:55,980 --> 00:26:57,540
I'm just making an empty call.

539
00:26:57,540 --> 00:27:00,860
>> But my function hard_square
is expecting a parameter.

540
00:27:00,860 --> 00:27:02,222
What is this going to print out?

541
00:27:02,222 --> 00:27:03,680
It's going to print out 100, right?

542
00:27:03,680 --> 00:27:05,720
Because the user didn't
give me anything.

543
00:27:05,720 --> 00:27:08,970
And so I'm just going to assume
that 10-- 10 is the default value.

544
00:27:08,970 --> 00:27:13,760
And so this would print
out 100 on its own line.

545
00:27:13,760 --> 00:27:16,390
>> PHP files do not have to
be just a single file.

546
00:27:16,390 --> 00:27:19,480
You can combine multiple files together,
just like you can in C. The way

547
00:27:19,480 --> 00:27:24,330
we did that in C was typically to do a
#include to get header files pulled in.

548
00:27:24,330 --> 00:27:26,180
We don't do that in PHP.

549
00:27:26,180 --> 00:27:29,110
We do something called require_once.

550
00:27:29,110 --> 00:27:33,360
And then there's this whole
thing, what's this __dir__?

551
00:27:33,360 --> 00:27:36,510
That's just a special
variable, or special constant,

552
00:27:36,510 --> 00:27:39,030
really, that specifies what
your current directory is.

553
00:27:39,030 --> 00:27:41,320
And so it's going to look
in your current directory

554
00:27:41,320 --> 00:27:44,900
for a file called cs50.php
in this example here,

555
00:27:44,900 --> 00:27:50,490
and it's going to stick that file
at the top of your PHP program,

556
00:27:50,490 --> 00:27:56,980
assuming that you put the require
once line at the top of your PHP file.

557
00:27:56,980 --> 00:28:01,474
>> So PHP is primarily used,
but not exclusively used,

558
00:28:01,474 --> 00:28:03,140
as a language for web-based programming.

559
00:28:03,140 --> 00:28:05,270
That's really how it came to be.

560
00:28:05,270 --> 00:28:06,980
But it is a full
language, as we've seen.

561
00:28:06,980 --> 00:28:10,105
We've seen pretty much all the things
that it can do that are similar to C,

562
00:28:10,105 --> 00:28:13,290
and it can do a heck of
a lot more than that.

563
00:28:13,290 --> 00:28:16,950
>> But because it's a full language and we
can do command line programming in it.

564
00:28:16,950 --> 00:28:18,630
We can run command line programs.

565
00:28:18,630 --> 00:28:22,580
All that's required to run a command
line program that's written in PHP

566
00:28:22,580 --> 00:28:24,260
is that you have a PHP interpreter.

567
00:28:24,260 --> 00:28:27,460
So it's sort of analogous to
having a compiler on your system

568
00:28:27,460 --> 00:28:31,100
if you want to compile your C code
to turn it into executable files.

569
00:28:31,100 --> 00:28:33,810
You need to have a PHP interpreter
that exists on your system

570
00:28:33,810 --> 00:28:37,330
so that you can interpret PHP files.

571
00:28:37,330 --> 00:28:40,370
>> Assuming you do, and usually
this interpreter is called PHP,

572
00:28:40,370 --> 00:28:44,300
and it's usually bundled with most
downloads or installations of PHP

573
00:28:44,300 --> 00:28:47,430
that you can get online, and certainly
the name of the PHP interpreter

574
00:28:47,430 --> 00:28:49,550
we have in CS50, IDE.

575
00:28:49,550 --> 00:28:51,819
All you do is type php file.

576
00:28:51,819 --> 00:28:53,610
And what your program's
going to do is it's

577
00:28:53,610 --> 00:28:55,360
going to run through
the interpreter, it's

578
00:28:55,360 --> 00:28:58,040
going to ignore everything that's
not in between question mark--

579
00:28:58,040 --> 00:29:03,160
or, angle bracket question mark php,
the PHP delimiters, and print it out,

580
00:29:03,160 --> 00:29:07,660
and it will interpret and execute the
code inside of your PHP delimiters.

581
00:29:07,660 --> 00:29:12,850
>> So let's pop over to CS50 IDE and
have a look at a couple of PHP files,

582
00:29:12,850 --> 00:29:19,850
running a couple of PHP files, in
command line interface of CS50 IDE.

583
00:29:19,850 --> 00:29:22,100
So here we are in CS50 IDE,
and I've taken the liberty

584
00:29:22,100 --> 00:29:25,800
of opening a file called hello1.php.

585
00:29:25,800 --> 00:29:29,920
And apparently, the contents of this
file are just the PHP delimiters there,

586
00:29:29,920 --> 00:29:32,220
and in between, echo("hello, world").

587
00:29:32,220 --> 00:29:34,710
This is a pretty simple PHP program.

588
00:29:34,710 --> 00:29:37,670
I'm just going to scroll down
to my terminal window here,

589
00:29:37,670 --> 00:29:44,320
and I'm going to type php
hello1.php, hit enter.

590
00:29:44,320 --> 00:29:44,950
Hello, world.

591
00:29:44,950 --> 00:29:48,110
That's probably what we were
expecting it to do, right?

592
00:29:48,110 --> 00:29:51,140
>> Let's go up and take
another look at a program.

593
00:29:51,140 --> 00:29:52,924
hello2.php.

594
00:29:52,924 --> 00:29:55,090
Pretty much the same thing,
not a lot going on here.

595
00:29:55,090 --> 00:29:57,190
This time, though, I'm going to prompt
the user to give me their names.

596
00:29:57,190 --> 00:29:59,290
I'm using that readline function again.

597
00:29:59,290 --> 00:30:01,340
$name = readline.

598
00:30:01,340 --> 00:30:03,070
That's the prompt, "What is your name?"

599
00:30:03,070 --> 00:30:04,880
>> Apparently I'm printing
it on its own line.

600
00:30:04,880 --> 00:30:07,220
And then, so the line below
that will be the prompt

601
00:30:07,220 --> 00:30:08,750
where the user can enter their name.

602
00:30:08,750 --> 00:30:12,030
And then I'm using a little bit of
variable interpellation here on line 3

603
00:30:12,030 --> 00:30:14,780
to print out "Hello" and
whatever the user types.

604
00:30:14,780 --> 00:30:22,040
So this is analogous to saying, Hello,
comma, %s if we were using printf in C.

605
00:30:22,040 --> 00:30:24,910
>> So let's go and interpret this program.

606
00:30:24,910 --> 00:30:27,400
So again, I'll scroll down
to my terminal window.

607
00:30:27,400 --> 00:30:29,070
php hello2.php.

608
00:30:29,070 --> 00:30:31,920

609
00:30:31,920 --> 00:30:33,820
What is your name?

610
00:30:33,820 --> 00:30:35,490
Doug.

611
00:30:35,490 --> 00:30:36,526
Hello, Doug.

612
00:30:36,526 --> 00:30:39,440
I also have another
file called hello3.php.

613
00:30:39,440 --> 00:30:42,850
I'm going to clear my
screen with Control L,

614
00:30:42,850 --> 00:30:46,210
and I'm going to execute that.

615
00:30:46,210 --> 00:30:47,640
What is your name?

616
00:30:47,640 --> 00:30:49,020
Doug.

617
00:30:49,020 --> 00:30:49,780
Hello, Doug.

618
00:30:49,780 --> 00:30:56,540
So the behavior is identical to
hello2.php, but why is it hello3.php?

619
00:30:56,540 --> 00:30:58,040
>> Well, here's the difference.

620
00:30:58,040 --> 00:31:00,620
In this case, notice
that on line 1 here,

621
00:31:00,620 --> 00:31:04,270
I have something that's not
in between the PHP delimiters.

622
00:31:04,270 --> 00:31:07,760
I'm just printing out-- or I
just typed, "What is your name?"

623
00:31:07,760 --> 00:31:12,060
When the PHP interpreter sees this, it
has no idea how to interpret it as PHP,

624
00:31:12,060 --> 00:31:15,060
and so instead of failing,
it's just going to spit it out.

625
00:31:15,060 --> 00:31:19,010
>> So notice on line 3 now, my call to
readline, there's no prompt anymore.

626
00:31:19,010 --> 00:31:21,750
I'm just actually going to-- when
the PHP interpreter sees this,

627
00:31:21,750 --> 00:31:23,400
it's going to print out
"What is your name?"

628
00:31:23,400 --> 00:31:25,941
Then it sees, oh, OK, here's--
everything else is going to be

629
00:31:25,941 --> 00:31:29,970
interpreted as PHP, so
that's why this works.

630
00:31:29,970 --> 00:31:34,990
I don't have to necessarily prompt
the user to-- inside of readline,

631
00:31:34,990 --> 00:31:37,490
I can just have it outside
of the PHP delimiters

632
00:31:37,490 --> 00:31:41,490
and allow the interpreter
to just print it out for me.

633
00:31:41,490 --> 00:31:45,364
>> So you don't actually only have
to have one set of PHP delimiters

634
00:31:45,364 --> 00:31:46,030
in your program.

635
00:31:46,030 --> 00:31:49,887
You can actually have several of them,
opening and closing them as needed.

636
00:31:49,887 --> 00:31:51,720
So let's take a look
at a couple of programs

637
00:31:51,720 --> 00:31:55,070
in CS50 IDE where we
illustrate this idea of having

638
00:31:55,070 --> 00:31:58,376
multiple sets of delimited PHP.

639
00:31:58,376 --> 00:32:02,010
>> OK, so I've opened a file
here called add1.php.

640
00:32:02,010 --> 00:32:03,390
And notice what's happening here.

641
00:32:03,390 --> 00:32:08,077
Just as before, I have a
single PHP set of delimiters.

642
00:32:08,077 --> 00:32:10,660
I'm going to print out the
message, "Please give me a number."

643
00:32:10,660 --> 00:32:13,394
Then I'm going to read a line and
store it in the variable $num1.

644
00:32:13,394 --> 00:32:14,810
Then I'm going to print out again.

645
00:32:14,810 --> 00:32:16,310
Give me a second number.

646
00:32:16,310 --> 00:32:20,450
Read a line from the user, store
whatever they typed in in $num2.

647
00:32:20,450 --> 00:32:23,980
Add them together and store that
result in a variable called $sum,

648
00:32:23,980 --> 00:32:26,180
and then print out, "The
sum of these two numbers

649
00:32:26,180 --> 00:32:29,254
is," and then interpellate
there the variable $sum.

650
00:32:29,254 --> 00:32:31,170
So let's just run this
through the interpreter

651
00:32:31,170 --> 00:32:33,720
to confirm that this is what we expect.

652
00:32:33,720 --> 00:32:37,540
php add1.php.

653
00:32:37,540 --> 00:32:38,665
Please give me a number, 3.

654
00:32:38,665 --> 00:32:40,410
Please give me a second number, 4.

655
00:32:40,410 --> 00:32:43,370
The sum of these two numbers is 7.

656
00:32:43,370 --> 00:32:45,030
That's 3 plus 4.

657
00:32:45,030 --> 00:32:45,530
OK?

658
00:32:45,530 --> 00:32:47,770
So nothing terribly fancy there.

659
00:32:47,770 --> 00:32:51,080
>> And now let's open up add2.php.

660
00:32:51,080 --> 00:32:54,460
Here, I've got a couple of PHP
delimited sets there, right?

661
00:32:54,460 --> 00:32:59,107
Lines 1, 3-- lines 1 and
3 have no PHP delimiters.

662
00:32:59,107 --> 00:33:00,940
So when the interpreter
sees them, it's just

663
00:33:00,940 --> 00:33:03,220
going to spit out exactly
what I have typed there.

664
00:33:03,220 --> 00:33:05,011
So that's where I'm
doing all my prompting.

665
00:33:05,011 --> 00:33:11,220
On lines 2 and 4, we see the very
familiar $?php sort of delimiters,

666
00:33:11,220 --> 00:33:15,210
so those two lines are
going to execute as PHP.

667
00:33:15,210 --> 00:33:18,270
And then on line 5, I have this
weird thing right here, right?

668
00:33:18,270 --> 00:33:20,480
This angle bracket
question mark equal sign.

669
00:33:20,480 --> 00:33:22,660
I'll even zoom in a little bit further.

670
00:33:22,660 --> 00:33:29,270
You can see this is what I'm
talking about right there, this $?=.

671
00:33:29,270 --> 00:33:33,420
>> It turns out that it's so common that
the reason that we open up a set of PHP

672
00:33:33,420 --> 00:33:36,055
delimiters is to print out a value.

673
00:33:36,055 --> 00:33:37,430
And that's all we're going to do.

674
00:33:37,430 --> 00:33:39,220
But there's even shorthand for that.

675
00:33:39,220 --> 00:33:46,490
$?= is PHP shorthand for saying
something like $?php echo the sum

676
00:33:46,490 --> 00:33:48,350
of num1 and num2.

677
00:33:48,350 --> 00:33:51,900
So this is just another
shorthand for that.

678
00:33:51,900 --> 00:33:55,550
>> So if I run this program, php add2.php.

679
00:33:55,550 --> 00:33:57,530
I'll zoom down a little bit.

680
00:33:57,530 --> 00:33:59,000
Please give me a number, 4.

681
00:33:59,000 --> 00:34:00,350
Please give me a second number.

682
00:34:00,350 --> 00:34:04,650
And since I don't really care about
data types in PHP, I can say 4.8.

683
00:34:04,650 --> 00:34:07,160
The sum of these two numbers is 8.8.

684
00:34:07,160 --> 00:34:10,179
That function behaves pretty much
exactly the same as we would expect,

685
00:34:10,179 --> 00:34:10,989
as well.

686
00:34:10,989 --> 00:34:13,114
And I have one more opened
up here called dice.php.

687
00:34:13,114 --> 00:34:25,625

688
00:34:25,625 --> 00:34:26,250
Try this again.

689
00:34:26,250 --> 00:34:29,429

690
00:34:29,429 --> 00:34:33,280
I have one more here called
dice1.php, which also, see,

691
00:34:33,280 --> 00:34:37,440
has that angle bracket question
mark equal sign notation in there,

692
00:34:37,440 --> 00:34:40,659
but notice that in this case I'm
calling the function rand, which as you

693
00:34:40,659 --> 00:34:42,790
might expect generates a random number.

694
00:34:42,790 --> 00:34:46,889
"You rolled a," and it's going to
calculate some random number, mod 6 +

695
00:34:46,889 --> 00:34:47,389
1.

696
00:34:47,389 --> 00:34:49,989
So that'll give me number
in the range of 1 to 6.

697
00:34:49,989 --> 00:34:53,040
>> Remember that mod 6 would give me
a number in the range of 0 to 5,

698
00:34:53,040 --> 00:34:56,630
but if I'm simulating dice rolls,
which is what I'm doing here,

699
00:34:56,630 --> 00:35:00,040
I don't want these dice to go from 0
to 5, I want dice that go from 1 to 6.

700
00:35:00,040 --> 00:35:02,800
And so this is a way to get
me in the range of 1 to 6.

701
00:35:02,800 --> 00:35:04,720
I'm doing this twice.

702
00:35:04,720 --> 00:35:08,630
So apparently I am rolling
two dice in this program.

703
00:35:08,630 --> 00:35:15,210
>> So I'll clear my screen,
and I'll do php dice1.php.

704
00:35:15,210 --> 00:35:16,640
You rolled a 4 and a 2.

705
00:35:16,640 --> 00:35:19,156
And if I run the program
again, you rolled a 5 and a 5.

706
00:35:19,156 --> 00:35:21,780
So every time I run the program,
I'm getting different numbers,

707
00:35:21,780 --> 00:35:24,280
because every time I do
so, it's starting over.

708
00:35:24,280 --> 00:35:27,250
It's going to generate a new
set of random numbers for me.

709
00:35:27,250 --> 00:35:29,790
>> So if we're used to
running programs from C,

710
00:35:29,790 --> 00:35:32,520
we're used to typing ./ the
name of a program, right?

711
00:35:32,520 --> 00:35:35,090
That's how we've done all
of our programs in C so far.

712
00:35:35,090 --> 00:35:37,555
We can do this in PHP as well
by adding something called

713
00:35:37,555 --> 00:35:40,026
a shebang to the top of our PHP file.

714
00:35:40,026 --> 00:35:41,400
I know it's kind of a silly word.

715
00:35:41,400 --> 00:35:44,540
It's short for hash bang.

716
00:35:44,540 --> 00:35:46,300
That's the first two characters there.

717
00:35:46,300 --> 00:35:50,030
Remember we call exclamation point
frequently a bang in computer science.

718
00:35:50,030 --> 00:35:51,690
It also might be for sharp bang.

719
00:35:51,690 --> 00:35:53,273
There's a couple ways to interpret it.

720
00:35:53,273 --> 00:35:57,320
But it's basically a special sort
of command that the PHP interpreter

721
00:35:57,320 --> 00:36:00,160
understands as, oh, I want
you to execute this program,

722
00:36:00,160 --> 00:36:05,250
which is apparently /user/bin/php, which
is actually where the PHP interpreter

723
00:36:05,250 --> 00:36:08,590
specifically lives on our system.

724
00:36:08,590 --> 00:36:12,530
So it's-- what happens here is
the interpreter understands, oh,

725
00:36:12,530 --> 00:36:17,270
I'm apparently supposed to use
in this program to run this file.

726
00:36:17,270 --> 00:36:20,010
And so it allows you
to skip over the step

727
00:36:20,010 --> 00:36:22,979
of having to say php something.php.

728
00:36:22,979 --> 00:36:25,020
There's one other catch
here, which is that if we

729
00:36:25,020 --> 00:36:27,320
want our programs to
work as expected, we

730
00:36:27,320 --> 00:36:30,220
need to do something called
a file permission change.

731
00:36:30,220 --> 00:36:33,380
And we'll go-- and we talk a little
bit more about file permission changes

732
00:36:33,380 --> 00:36:37,550
in our video on MVC, but suffice it to
say that this is what you need to do

733
00:36:37,550 --> 00:36:42,760
in order to make your
.php files executable.

734
00:36:42,760 --> 00:36:49,330
So let's take a look at this as
our final example over in CS50 IDE.

735
00:36:49,330 --> 00:36:53,910
>> So here in IDE I have two files in this
PHP directory that appear not to be

736
00:36:53,910 --> 00:36:55,310
called .php.

737
00:36:55,310 --> 00:36:58,170
I have a function called add--
I have a file called add3

738
00:36:58,170 --> 00:37:00,650
and a file called dice2.

739
00:37:00,650 --> 00:37:03,680
So let's take a quick
look and open up add3.

740
00:37:03,680 --> 00:37:08,300
And as you can see, at the beginning
of my file I have this shebang, right?

741
00:37:08,300 --> 00:37:11,420
This hash mark exclamation point.

742
00:37:11,420 --> 00:37:15,115
Now, you'll also maybe
notice that for some reason,

743
00:37:15,115 --> 00:37:16,990
I don't have any syntax
highlighting anymore,

744
00:37:16,990 --> 00:37:20,198
and this is what I alluded to earlier,
which was that if I don't name my file

745
00:37:20,198 --> 00:37:23,040
.php, I don't have the benefit
of syntax highlighting anymore.

746
00:37:23,040 --> 00:37:26,220
This file is just called add3.

747
00:37:26,220 --> 00:37:30,960
So that I can run it later on
with ./ add3 and not ./ add3.php.

748
00:37:30,960 --> 00:37:33,680
>> So the reason-- it's still
fine, it's still valid PHP,

749
00:37:33,680 --> 00:37:37,000
but it's not syntax highlighted, because
this file is not called something.php.

750
00:37:37,000 --> 00:37:41,580
That's the only real difference
here, plus the shebang.

751
00:37:41,580 --> 00:37:45,170
So let's see what happens when
I try and run this program.

752
00:37:45,170 --> 00:37:50,780
./ add3, just like I would with C. Bash.

753
00:37:50,780 --> 00:37:53,190
./ add3 permission denied.

754
00:37:53,190 --> 00:37:55,390
This is what you're going
to see if you forget

755
00:37:55,390 --> 00:37:59,280
to use the chmod command to change
the permissions of the file.

756
00:37:59,280 --> 00:38:03,845
>> As it turns out, regular PHP
files cannot just be executed.

757
00:38:03,845 --> 00:38:06,970
They can be interpreted, but we're
doing something a little different here.

758
00:38:06,970 --> 00:38:07,761
We're executing it.

759
00:38:07,761 --> 00:38:12,970
And so I need to add the permission
of execution, chmod a+x to add3.

760
00:38:12,970 --> 00:38:15,680
Then I can say ./ add3.

761
00:38:15,680 --> 00:38:16,860
Please give me a number.

762
00:38:16,860 --> 00:38:18,060
5, 6.

763
00:38:18,060 --> 00:38:20,490
The sum of these two numbers is 11.

764
00:38:20,490 --> 00:38:26,530
>> Similarly, I have already chmoded
dice2, so I can just type ./ dice2,

765
00:38:26,530 --> 00:38:31,260
you rolled a 1 and a 1, you
rolled a 5 and a 4, and so on.

766
00:38:31,260 --> 00:38:33,680
>> So that's pretty much the
idea of a PHP syntax, right?

767
00:38:33,680 --> 00:38:35,221
There's a lot to get through, I know.

768
00:38:35,221 --> 00:38:39,160
But hopefully you've seen now that PHP
is not really that different from C

769
00:38:39,160 --> 00:38:43,670
and really gives us the ability
to take things up a notch or two.

770
00:38:43,670 --> 00:38:48,230
We don't really have to worry
too much about-- we don't really

771
00:38:48,230 --> 00:38:51,605
have to worry too much about
the low-level details we

772
00:38:51,605 --> 00:38:52,980
had to worry about with C, right?

773
00:38:52,980 --> 00:38:56,170
We can focus on the higher
level stuff that PHP

774
00:38:56,170 --> 00:39:01,090
allows us to do and to take for
granted that it will work for us.

775
00:39:01,090 --> 00:39:04,350
So it gives us the ability now,
transitioning from C to PHP,

776
00:39:04,350 --> 00:39:08,280
to make programs that are a lot more
complex and perhaps a lot more robust.

777
00:39:08,280 --> 00:39:13,070
>> So I hope you have fun working
with PHP, and I'm Doug Lloyd.

778
00:39:13,070 --> 00:39:15,050
This is CS50.

779
00:39:15,050 --> 00:39:17,637
