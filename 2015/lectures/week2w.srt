1
00:00:00,000 --> 00:00:03,944
>> [MUSIC PLAYING]

2
00:00:03,944 --> 00:00:10,732

3
00:00:10,732 --> 00:00:11,690
DAVID MALAN: All right.

4
00:00:11,690 --> 00:00:14,674
This is CS50, and this
is the end of week 2.

5
00:00:14,674 --> 00:00:16,840
I'm so sorry I couldn't be
there with you all today,

6
00:00:16,840 --> 00:00:18,300
but you're in very good hands.

7
00:00:18,300 --> 00:00:21,710
Allow me to introduce
CS50's own Rob Bowden.

8
00:00:21,710 --> 00:00:29,106

9
00:00:29,106 --> 00:00:31,730
ROB BOWDEN: And of course, then
we have to make fun of the fact

10
00:00:31,730 --> 00:00:36,820
that he sent us a vertical
video and show this.

11
00:00:36,820 --> 00:00:38,320
>> [VIDEO PLAYBACK]

12
00:00:38,320 --> 00:00:39,820
>> [MUSIC PLAYING]

13
00:00:39,820 --> 00:00:42,350
>> [FOOTSTEPS]

14
00:00:42,350 --> 00:00:44,730
>> -This video didn't
have to look this way.

15
00:00:44,730 --> 00:00:46,570
It could have been prevented.

16
00:00:46,570 --> 00:00:49,070
Say no to vertical videos.

17
00:00:49,070 --> 00:00:53,310
>> -Vertical videos happen when you
hold your camera the wrong way.

18
00:00:53,310 --> 00:00:55,880
Your video will end
up looking like crap.

19
00:00:55,880 --> 00:00:57,650
>> -[GRUNT]

20
00:00:57,650 --> 00:01:02,240
>> -There are more and more people addicted
to making vertical videos every day.

21
00:01:02,240 --> 00:01:06,240
It's not crack or nothing,
but it's still really bad.

22
00:01:06,240 --> 00:01:10,410
There are two different kinds of
people who are afflicted with VVS.

23
00:01:10,410 --> 00:01:14,160
The first group treats the
videos they shoot like pictures.

24
00:01:14,160 --> 00:01:15,850
They don't mean any harm.

25
00:01:15,850 --> 00:01:19,180
They just don't understand that
while you can turn a picture,

26
00:01:19,180 --> 00:01:20,880
you can't really turn a video.

27
00:01:20,880 --> 00:01:21,880
>> [CRASH]

28
00:01:21,880 --> 00:01:23,460
>> -[MONKEY SOUNDS]

29
00:01:23,460 --> 00:01:27,540
>> -The other group is people
who don't give a [BLEEP].

30
00:01:27,540 --> 00:01:31,090
>> -Vertical Video Syndrome is dangerous.

31
00:01:31,090 --> 00:01:34,120
Motion pictures have
always been horizontal.

32
00:01:34,120 --> 00:01:35,990
Televisions are horizontal.

33
00:01:35,990 --> 00:01:38,380
Computer screens are horizontal.

34
00:01:38,380 --> 00:01:41,580
People's eyes are horizontal.

35
00:01:41,580 --> 00:01:45,170
We aren't built to
watch vertical videos.

36
00:01:45,170 --> 00:01:47,600
>> -I love vertical videos.

37
00:01:47,600 --> 00:01:50,410
>> -Nobody cares about you.

38
00:01:50,410 --> 00:01:53,340
>> -If this problem's
left unchecked, you too

39
00:01:53,340 --> 00:01:57,650
will begin showing four videos
at once just to save bandwidth.

40
00:01:57,650 --> 00:02:02,400
>> -Letterboxed vertical videos would
be the size of a postage stamp.

41
00:02:02,400 --> 00:02:04,920
>> -And it will spread everywhere.

42
00:02:04,920 --> 00:02:07,670
Movie screens have
always been horizontal.

43
00:02:07,670 --> 00:02:11,200
If vertical videos become
accepted, movie theaters

44
00:02:11,200 --> 00:02:13,930
will have to be tall and skinny.

45
00:02:13,930 --> 00:02:17,710
>> -And all of the movie theaters would
have to get torn down and rebuilt.

46
00:02:17,710 --> 00:02:22,090
And by the time they were rebuilt,
Mila Kunis would be old and ugly.

47
00:02:22,090 --> 00:02:24,342
>> -Birds will crash into them and die.

48
00:02:24,342 --> 00:02:26,530
>> -We'll all get stiff
necks from looking up.

49
00:02:26,530 --> 00:02:29,800
>> -And no one will sit in
the front row ever again.

50
00:02:29,800 --> 00:02:37,170
>> -George Lucas will re-release Star
Wars again-- the skinny edition.

51
00:02:37,170 --> 00:02:41,860
>> -I was never really able to tell
the story that I wanted to tell.

52
00:02:41,860 --> 00:02:46,030
This was a great chance for me to
experiment with a new technology.

53
00:02:46,030 --> 00:02:48,150
>> -You're a jerk.

54
00:02:48,150 --> 00:02:54,430
>> -Every time a mobile device is used to
record video, the temptation is there.

55
00:02:54,430 --> 00:02:56,370
Just say no.

56
00:02:56,370 --> 00:03:00,116
Say no to George Lucas.

57
00:03:00,116 --> 00:03:04,062
Say no to old Mila Kunis.

58
00:03:04,062 --> 00:03:06,600
Say no to vertical videos.

59
00:03:06,600 --> 00:03:12,511
>> -And if you see someone doing it, say,
"you're not shooting that right dummy!"

60
00:03:12,511 --> 00:03:15,433
>> [MUSIC PLAYING]

61
00:03:15,433 --> 00:03:18,842

62
00:03:18,842 --> 00:03:19,830
>> [END PLAYBACK]

63
00:03:19,830 --> 00:03:23,702
>> [APPLAUSE]

64
00:03:23,702 --> 00:03:27,598
>> [AUDIO OUT]

65
00:03:27,598 --> 00:03:44,041

66
00:03:44,041 --> 00:03:45,790
ROB BOWDEN: --simple
form of cryptography,

67
00:03:45,790 --> 00:03:49,500
which is basically the encryption
and decryption of secret messages.

68
00:03:49,500 --> 00:03:52,590
So here we have a very simple toy.

69
00:03:52,590 --> 00:03:56,900
And the idea is the outer ring
rotates around the inner ring.

70
00:03:56,900 --> 00:04:01,610
And you can see, maybe if I zoom
in, that-- it's hard to see.

71
00:04:01,610 --> 00:04:05,090
But, like, the number
1-- well, that moved.

72
00:04:05,090 --> 00:04:09,120
>> The number 1 maps to the letter
X, number 2 maps to the letter

73
00:04:09,120 --> 00:04:11,630
J. Incredibly difficult
not to skip forward.

74
00:04:11,630 --> 00:04:16,100
Letter 2 maps to J.
Number 3 maps to D. So

75
00:04:16,100 --> 00:04:20,140
with this ring you can give
someone a message 1, 2, 3.

76
00:04:20,140 --> 00:04:22,624
For some reason you
want to tell them XJD.

77
00:04:22,624 --> 00:04:24,540
But you can give them
some message of numbers,

78
00:04:24,540 --> 00:04:28,460
and as long as they have this ring, they
can decrypt what you're trying to say.

79
00:04:28,460 --> 00:04:32,510
>> So you may have seen this
particular example of cryptography

80
00:04:32,510 --> 00:04:36,640
before if around the Christmas season
you've watched A Christmas Story.

81
00:04:36,640 --> 00:04:38,520
If you've never seen
it before, then just

82
00:04:38,520 --> 00:04:41,060
turn on TBS at literally
any time on Christmas Eve,

83
00:04:41,060 --> 00:04:44,510
because they just show it back to back
to back to back to back the entire day.

84
00:04:44,510 --> 00:04:46,744
And the relevant video is this.

85
00:04:46,744 --> 00:04:47,410
[VIDEO PLAYBACK]

86
00:04:47,410 --> 00:04:50,020
-Be it known to all and sundry
that Ralph Parker is hereby

87
00:04:50,020 --> 00:04:52,850
appointed a member of the Little
Orphan Annie Secret Circle

88
00:04:52,850 --> 00:04:56,490
and is entitled to all the honors
and benefits occurring thereto.

89
00:04:56,490 --> 00:04:59,010
Signed Little Orphan Annie.

90
00:04:59,010 --> 00:05:03,120
Countersigned Pierre Andre in ink!

91
00:05:03,120 --> 00:05:07,460
Honors and benefits
already at the age of nine!

92
00:05:07,460 --> 00:05:12,530
>> [YELLING FROM RADIO]

93
00:05:12,530 --> 00:05:13,030
-Come on.

94
00:05:13,030 --> 00:05:14,000
Let's get on with it.

95
00:05:14,000 --> 00:05:18,274
I don't need all that jazz
about smugglers and pirates.

96
00:05:18,274 --> 00:05:20,440
-Listen tomorrow night with
the concluding adventure

97
00:05:20,440 --> 00:05:22,540
of the Black Pirate Ship.

98
00:05:22,540 --> 00:05:25,460
Now, it's time for
Annie's secret message

99
00:05:25,460 --> 00:05:28,620
for you members of the Secret Circle.

100
00:05:28,620 --> 00:05:32,370
Remember kids, only members
of Annie's Secret Circle

101
00:05:32,370 --> 00:05:34,880
can decode Annie's secret message.

102
00:05:34,880 --> 00:05:39,100
Remember, Annie is depending on you.

103
00:05:39,100 --> 00:05:41,660
Set your pins to B2.

104
00:05:41,660 --> 00:05:43,960
Here is the message.

105
00:05:43,960 --> 00:05:44,680
12.

106
00:05:44,680 --> 00:05:45,180
11.

107
00:05:45,180 --> 00:05:45,679
2.

108
00:05:45,679 --> 00:05:48,110
-I am in my first secret meeting.

109
00:05:48,110 --> 00:05:49,030
>> -25.

110
00:05:49,030 --> 00:05:49,834
14.

111
00:05:49,834 --> 00:05:51,040
11.

112
00:05:51,040 --> 00:05:51,854
18.

113
00:05:51,854 --> 00:05:52,670
16.

114
00:05:52,670 --> 00:05:54,570
>> -Oh, Pierre is in great voice tonight.

115
00:05:54,570 --> 00:05:57,490
I could tell that tonight's
message was really important.

116
00:05:57,490 --> 00:05:57,990
-3.

117
00:05:57,990 --> 00:06:00,080
25.

118
00:06:00,080 --> 00:06:01,580
That's a message from Annie herself.

119
00:06:01,580 --> 00:06:02,880
Remember, don't tell anyone.

120
00:06:02,880 --> 00:06:07,840

121
00:06:07,840 --> 00:06:11,130
>> -Five seconds later, I'm in the only
room in the house where a boy of nine

122
00:06:11,130 --> 00:06:15,830
could sit in privacy and decode.

123
00:06:15,830 --> 00:06:16,620
Aha!

124
00:06:16,620 --> 00:06:17,340
B!

125
00:06:17,340 --> 00:06:20,210
I went to the next.

126
00:06:20,210 --> 00:06:23,300
E. The first word is "be."

127
00:06:23,300 --> 00:06:25,880
S. It was coming easier now.

128
00:06:25,880 --> 00:06:28,400
U. 25.

129
00:06:28,400 --> 00:06:30,528
That's R.

130
00:06:30,528 --> 00:06:31,278
-Come on, Ralphie!

131
00:06:31,278 --> 00:06:31,861
I've gotta go!

132
00:06:31,861 --> 00:06:33,182
-I'll be right down, Ma!

133
00:06:33,182 --> 00:06:36,038
Gee whiz.

134
00:06:36,038 --> 00:06:42,840
T. O. "Be sure to"-- be sure to what?

135
00:06:42,840 --> 00:06:44,770
What was Little Orphan
Annie trying to say?

136
00:06:44,770 --> 00:06:46,381
Be sure to what?

137
00:06:46,381 --> 00:06:47,825
>> -Randy has got to go!

138
00:06:47,825 --> 00:06:48,866
Will you please come out?

139
00:06:48,866 --> 00:06:49,783
>> -All right, mom!

140
00:06:49,783 --> 00:06:51,786
I'll be right out!

141
00:06:51,786 --> 00:06:53,606
I was getting closer now.

142
00:06:53,606 --> 00:06:55,550
The tension was terrible.

143
00:06:55,550 --> 00:06:57,050
What was it?

144
00:06:57,050 --> 00:06:59,905
The fate of the planet
may hang in the balance!

145
00:06:59,905 --> 00:07:01,736
>> -Ralphie, Randy's got to go!

146
00:07:01,736 --> 00:07:05,680
>> -I'll be right out, for crying out loud!

147
00:07:05,680 --> 00:07:07,170
Almost there!

148
00:07:07,170 --> 00:07:08,150
My fingers flew.

149
00:07:08,150 --> 00:07:09,980
My mind was a steel trap.

150
00:07:09,980 --> 00:07:11,496
Every pore vibrated.

151
00:07:11,496 --> 00:07:13,268
It was almost clear!

152
00:07:13,268 --> 00:07:13,767
Yes.

153
00:07:13,767 --> 00:07:14,609
Yes.

154
00:07:14,609 --> 00:07:15,108
Yes.

155
00:07:15,108 --> 00:07:16,449
Yes.

156
00:07:16,449 --> 00:07:20,240
Be sure to drink your Ovaltine.

157
00:07:20,240 --> 00:07:20,740
Ovaltine?

158
00:07:20,740 --> 00:07:26,687

159
00:07:26,687 --> 00:07:27,520
A crummy commercial?

160
00:07:27,520 --> 00:07:32,040

161
00:07:32,040 --> 00:07:34,920
Son of a bitch.

162
00:07:34,920 --> 00:07:35,890
>> [END PLAYBACK]

163
00:07:35,890 --> 00:07:39,650
>> ROB BOWDEN: So that's how
Ovaltine relates to cryptography.

164
00:07:39,650 --> 00:07:42,290
Basically CS50 just advertised
Ovaltine, so we could

165
00:07:42,290 --> 00:07:44,400
be a crummy commercial for Ovaltine.

166
00:07:44,400 --> 00:07:44,900
All right.

167
00:07:44,900 --> 00:07:47,120
So now actual computer science.

168
00:07:47,120 --> 00:07:50,670
Remember on Monday we left off
diving deeper into strings.

169
00:07:50,670 --> 00:07:52,820
So we were dealing with
the string "Zamyla."

170
00:07:52,820 --> 00:07:55,130
And we were recognizing
the fact that we can treat

171
00:07:55,130 --> 00:07:57,510
"Zamyla" as a sequence of characters.

172
00:07:57,510 --> 00:07:59,740
And remember that we learned
the bracket notation.

173
00:07:59,740 --> 00:08:01,995
So if this were stored
in a string "s," then

174
00:08:01,995 --> 00:08:05,860
if we said s bracket 0, that would
indicate the letter capital Z.

175
00:08:05,860 --> 00:08:09,790
And if we said s bracket 1, that
would indicate the first lowercase a,

176
00:08:09,790 --> 00:08:14,220
and so on up to s bracket 5,
which would indicate the last a.

177
00:08:14,220 --> 00:08:17,090
>> Now remember that the
length of this string is 6,

178
00:08:17,090 --> 00:08:23,220
but the indices into the string are
0 through 5, Z through that last a.

179
00:08:23,220 --> 00:08:28,650
So this now fits into a bigger picture
of your computer's memory, your RAM.

180
00:08:28,650 --> 00:08:32,020
So somewhere the program that
you're running your computer

181
00:08:32,020 --> 00:08:34,780
needs to remember Zamyla
somewhere in memory.

182
00:08:34,780 --> 00:08:36,029
So can I have a volunteer?

183
00:08:36,029 --> 00:08:38,840

184
00:08:38,840 --> 00:08:40,181
Yes, please.

185
00:08:40,181 --> 00:08:50,120

186
00:08:50,120 --> 00:08:51,500
And what is your name?

187
00:08:51,500 --> 00:08:52,410
>> DEAN: Dean.

188
00:08:52,410 --> 00:08:53,550
>> ROB BOWDEN: Dean?

189
00:08:53,550 --> 00:08:54,910
Nice to meet you, Dean.

190
00:08:54,910 --> 00:08:58,240
So come over here, and
we're going to have you draw

191
00:08:58,240 --> 00:09:00,740
on our nice nifty layout of memory.

192
00:09:00,740 --> 00:09:05,950
Now I like to think of memory
as one long strip of bytes,

193
00:09:05,950 --> 00:09:11,090
but just for display purposes we'll
just do left to right, top to bottom.

194
00:09:11,090 --> 00:09:11,590
OK?

195
00:09:11,590 --> 00:09:22,030
>> So I'm going to show a
program-- Getstrings.c.

196
00:09:22,030 --> 00:09:25,760
And so all this program is
doing is requesting four strings

197
00:09:25,760 --> 00:09:28,830
from the user with
GetString and then printing

198
00:09:28,830 --> 00:09:30,950
whatever that first string entered was.

199
00:09:30,950 --> 00:09:32,840
We're ignoring two through four.

200
00:09:32,840 --> 00:09:33,610
OK.

201
00:09:33,610 --> 00:09:38,210
So over here now-- when
I first request s1.

202
00:09:38,210 --> 00:09:39,740
So you are the computer.

203
00:09:39,740 --> 00:09:41,680
And you are implementing GetString.

204
00:09:41,680 --> 00:09:46,710
So you request a string from
me, and I say, OK, Dean.

205
00:09:46,710 --> 00:09:47,900
Give the string "Dean."

206
00:09:47,900 --> 00:09:50,300
>> So somewhere in memory you
need to remember "Dean."

207
00:09:50,300 --> 00:09:52,160
So write it into memory somewhere.

208
00:09:52,160 --> 00:09:58,270

209
00:09:58,270 --> 00:09:59,210
Perfect.

210
00:09:59,210 --> 00:09:59,880
OK.

211
00:09:59,880 --> 00:10:01,740
So now we have s2.

212
00:10:01,740 --> 00:10:03,869
And s2 is going to be
a request to GetString.

213
00:10:03,869 --> 00:10:05,160
So I'm going to enter a string.

214
00:10:05,160 --> 00:10:08,720
I'm going to enter "Hannah."

215
00:10:08,720 --> 00:10:10,586
So enter "Hannah" somewhere into memory.

216
00:10:10,586 --> 00:10:18,860

217
00:10:18,860 --> 00:10:19,360
Yeah.

218
00:10:19,360 --> 00:10:23,000
A-H.

219
00:10:23,000 --> 00:10:25,550
>> OK, so now s3.

220
00:10:25,550 --> 00:10:28,380
And it's going to be another
request to GetString.

221
00:10:28,380 --> 00:10:37,020
And so now enter "Maria."

222
00:10:37,020 --> 00:10:37,520
All right.

223
00:10:37,520 --> 00:10:40,980
And then there's one last
request to GetString, s4.

224
00:10:40,980 --> 00:10:42,580
So, I don't know.

225
00:10:42,580 --> 00:10:45,640
How about we go with
antidisestablishmentarianism.

226
00:10:45,640 --> 00:10:49,460
So enter that into memory.

227
00:10:49,460 --> 00:10:50,400
Yeah.

228
00:10:50,400 --> 00:10:53,970
So just do "Rob."

229
00:10:53,970 --> 00:10:54,560
>> OK.

230
00:10:54,560 --> 00:10:58,410
So now explain-- why did
you leave these spaces?

231
00:10:58,410 --> 00:11:01,340
Why do you have this blank
space here, here, and up here?

232
00:11:01,340 --> 00:11:05,170

233
00:11:05,170 --> 00:11:05,670
Yes.

234
00:11:05,670 --> 00:11:09,450
So notice when I go
to print s1-- so if we

235
00:11:09,450 --> 00:11:11,890
had "Hannah" running
right up next to "Dean,"

236
00:11:11,890 --> 00:11:14,360
how do we know when
the string "Dean" ends?

237
00:11:14,360 --> 00:11:19,470
So printing the string s1 may have
just printed "DeanHannahMariaRob"

238
00:11:19,470 --> 00:11:22,720
if it doesn't have any clue
of when "Dean" actually ends.

239
00:11:22,720 --> 00:11:23,240
>> All right.

240
00:11:23,240 --> 00:11:27,650
So in memory the way we actually
represent this end of a string

241
00:11:27,650 --> 00:11:29,940
is with backslash zero.

242
00:11:29,940 --> 00:11:32,620
So this space is exactly what we wanted.

243
00:11:32,620 --> 00:11:34,040
It should be a backslash zero.

244
00:11:34,040 --> 00:11:37,690
This will be a backslash zero,
and this will be a backslash zero.

245
00:11:37,690 --> 00:11:41,585
And you can have a fabulous prize
for being a perfect volunteer.

246
00:11:41,585 --> 00:11:44,910

247
00:11:44,910 --> 00:11:45,860
Take a stress ball!

248
00:11:45,860 --> 00:11:49,040

249
00:11:49,040 --> 00:11:49,700
>> OK.

250
00:11:49,700 --> 00:11:54,420
So this character backslash zero is
how we indicate the end of a string.

251
00:11:54,420 --> 00:11:57,120
It's how when any given program
wants to print a string,

252
00:11:57,120 --> 00:11:59,760
it's how-- remember we learned
the strlen function last week?

253
00:11:59,760 --> 00:12:00,940
String length?

254
00:12:00,940 --> 00:12:03,770
It's how string length is able to
determine how long a string is.

255
00:12:03,770 --> 00:12:05,810
It just keeps iterating
over the characters

256
00:12:05,810 --> 00:12:08,217
until it finds the
backslash zero character.

257
00:12:08,217 --> 00:12:11,050
So the important thing to realize
about the backslash zero character

258
00:12:11,050 --> 00:12:14,950
is it's represented
by all zeros in bits.

259
00:12:14,950 --> 00:12:18,980
So notice that this is distinct
from the zero character.

260
00:12:18,980 --> 00:12:23,010
So the zero character, if you remember
in the example that he gave at the end

261
00:12:23,010 --> 00:12:27,360
of lecture where characters map
to-- like capital A maps to 65.

262
00:12:27,360 --> 00:12:29,130
Lowercase a maps to 97.

263
00:12:29,130 --> 00:12:30,890
Lowercase b would be 98.

264
00:12:30,890 --> 00:12:35,220
So the number 0 maps to-- I don't
know off the top of my head.

265
00:12:35,220 --> 00:12:36,400
44 or 45.

266
00:12:36,400 --> 00:12:37,890
Somewhere in that region.

267
00:12:37,890 --> 00:12:40,850
>> So the character 0 is an actual number.

268
00:12:40,850 --> 00:12:44,350
But backslash zero
maps to all zero bits.

269
00:12:44,350 --> 00:12:46,380
So there's a distinction
between backslash zero,

270
00:12:46,380 --> 00:12:48,450
which we'll call the null terminator.

271
00:12:48,450 --> 00:12:53,210
There's a distinction between
backslash zero and the character zero.

272
00:12:53,210 --> 00:12:54,350
>> All right.

273
00:12:54,350 --> 00:12:57,520
So talking a bit more about strings.

274
00:12:57,520 --> 00:13:01,470
So then we see here this is how
it would be laid out in memory.

275
00:13:01,470 --> 00:13:07,940
So this idea of strings as a sequence
of characters-- so the official computer

276
00:13:07,940 --> 00:13:10,750
sciency term for sequence is an array.

277
00:13:10,750 --> 00:13:13,790
So we would call a string
an array of characters.

278
00:13:13,790 --> 00:13:17,770
And there are actually other data
types that we can make arrays out of.

279
00:13:17,770 --> 00:13:19,975
>> So to motivate this, look at an example.

280
00:13:19,975 --> 00:13:22,810

281
00:13:22,810 --> 00:13:29,812
We'll call it ages0.c I'll
copy and paste our template.

282
00:13:29,812 --> 00:13:32,470

283
00:13:32,470 --> 00:13:33,410
OK.

284
00:13:33,410 --> 00:13:39,378
So in this program what we
want to do is grab the age

285
00:13:39,378 --> 00:13:45,160
of three students in the course.

286
00:13:45,160 --> 00:13:49,240
So we know the int age--
and now I'm going to say 0.

287
00:13:49,240 --> 00:13:53,140
So you might want to say age1, but
for purposes we'll see very shortly,

288
00:13:53,140 --> 00:13:57,187
I'll say int age0 equals GetInt.

289
00:13:57,187 --> 00:13:59,270
So the same call to GetInt
that we've been using I

290
00:13:59,270 --> 00:14:01,561
don't happen to be prompting
saying, "give me the age."

291
00:14:01,561 --> 00:14:03,120
But just requests it.

292
00:14:03,120 --> 00:14:06,510
>> And age1 equals GetInt.

293
00:14:06,510 --> 00:14:09,600
And int age2 equals GetInt.

294
00:14:09,600 --> 00:14:14,070
So, again, three students, but
ultimately the variable indices

295
00:14:14,070 --> 00:14:16,890
are age0 through age2.

296
00:14:16,890 --> 00:14:17,550
OK.

297
00:14:17,550 --> 00:14:23,960
So this program will do whatever
we want with age0, age1, and age2,

298
00:14:23,960 --> 00:14:27,670
but this program ultimately
works for three students.

299
00:14:27,670 --> 00:14:28,380
>> OK.

300
00:14:28,380 --> 00:14:32,110
So now what if I want four students?

301
00:14:32,110 --> 00:14:36,000
Well, I'm going to have to go back
into my code, change the comment,

302
00:14:36,000 --> 00:14:39,840
and now we have an int
age3 equals GetInt.

303
00:14:39,840 --> 00:14:40,610
OK.

304
00:14:40,610 --> 00:14:43,660
So who sees the problem here?

305
00:14:43,660 --> 00:14:47,310
What is the problem
with this sort of setup?

306
00:14:47,310 --> 00:14:47,810
Yeah.

307
00:14:47,810 --> 00:14:53,110

308
00:14:53,110 --> 00:14:53,610
Yeah.

309
00:14:53,610 --> 00:14:56,360
So we're creating a
variable for each student.

310
00:14:56,360 --> 00:15:00,140
Now that works, but
ultimately what if I now

311
00:15:00,140 --> 00:15:06,500
say, "I want to grab the age of
eight students or 16 students

312
00:15:06,500 --> 00:15:11,340
or the however many students of
the hundreds of students in CS50

313
00:15:11,340 --> 00:15:16,750
or the thousands of students on campus
or the billions of people in the world?

314
00:15:16,750 --> 00:15:19,130
So ultimately this is not sustainable.

315
00:15:19,130 --> 00:15:21,990
Any time you see yourself copying
and pasting code like this,

316
00:15:21,990 --> 00:15:25,050
you should generally feel
that there is a better way.

317
00:15:25,050 --> 00:15:31,290
>> So this is where we introduce
an array declaration.

318
00:15:31,290 --> 00:15:34,564
So when you declare an array,
this is what the general format

319
00:15:34,564 --> 00:15:35,480
is going to look like.

320
00:15:35,480 --> 00:15:36,664
We're going to say the type.

321
00:15:36,664 --> 00:15:38,830
and then we're going to
give the name of that array,

322
00:15:38,830 --> 00:15:41,150
just as we define any given variable.

323
00:15:41,150 --> 00:15:43,980
And then finally we are using
this bracket notation again

324
00:15:43,980 --> 00:15:47,480
but in a different context from
how we were using it earlier.

325
00:15:47,480 --> 00:15:51,860
>> So here this looks like a normal
variable declaration that we've seen.

326
00:15:51,860 --> 00:15:54,890
So we've seen int x semi-colon before.

327
00:15:54,890 --> 00:16:00,020
Well now we might see something
like int x brackets 5.

328
00:16:00,020 --> 00:16:04,020
And putting this idea into the
GetInt program that we have--

329
00:16:04,020 --> 00:16:08,850
so we can implement
this in the same way.

330
00:16:08,850 --> 00:16:13,630
>> Let's say in CS we tend to use
n as the number of something.

331
00:16:13,630 --> 00:16:16,150
So here we're going to
store four students.

332
00:16:16,150 --> 00:16:25,960
And now we can say int age
bracket n-- not quite get it yet--

333
00:16:25,960 --> 00:16:32,210
to declare an array of four students.

334
00:16:32,210 --> 00:16:38,050
So how this will look in
memory will be similar to this.

335
00:16:38,050 --> 00:16:39,570
Clear this.

336
00:16:39,570 --> 00:16:46,606
And we're going to have somewhere
in memory-- I'll put this up there.

337
00:16:46,606 --> 00:16:52,690

338
00:16:52,690 --> 00:16:53,808
>> So somewhere in memory.

339
00:16:53,808 --> 00:16:58,760

340
00:16:58,760 --> 00:16:59,727
One, two, three, four.

341
00:16:59,727 --> 00:17:03,383

342
00:17:03,383 --> 00:17:09,849
We have four integers in a row
for this array of four integers.

343
00:17:09,849 --> 00:17:13,820
So, currently, what is the
size of one of these boxes?

344
00:17:13,820 --> 00:17:17,190

345
00:17:17,190 --> 00:17:17,690
Yeah.

346
00:17:17,690 --> 00:17:18,390
It's four bytes.

347
00:17:18,390 --> 00:17:19,690
It's 32 bits.

348
00:17:19,690 --> 00:17:22,310
So now this is different
from the array that we

349
00:17:22,310 --> 00:17:24,020
saw earlier, the array of characters.

350
00:17:24,020 --> 00:17:28,540
In a string each box was only one byte,
because a character is only one byte.

351
00:17:28,540 --> 00:17:32,170
But with an array of integers, each
box has to be four bytes in order

352
00:17:32,170 --> 00:17:34,060
to fit an entire integer.

353
00:17:34,060 --> 00:17:37,197
So this is what an array of
four ints would look like.

354
00:17:37,197 --> 00:17:40,510

355
00:17:40,510 --> 00:17:43,870
>> And then back to code.

356
00:17:43,870 --> 00:17:47,460
Now we want to actually store
integers into that array.

357
00:17:47,460 --> 00:17:53,470
So now this is a very, very, very
common pattern that will at some point

358
00:17:53,470 --> 00:17:54,680
become muscle memory.

359
00:17:54,680 --> 00:17:56,710
So int i equals 0.

360
00:17:56,710 --> 00:17:57,940
i less than n.

361
00:17:57,940 --> 00:18:01,850
i plus plus.

362
00:18:01,850 --> 00:18:05,790
Age bracket i equals GetInt.

363
00:18:05,790 --> 00:18:15,100
>> So this for loop, this format,
you should get very used to.

364
00:18:15,100 --> 00:18:20,010
So this is generally how we will
iterate over almost any array.

365
00:18:20,010 --> 00:18:23,690
Now notice this sort of
explains why from the beginning

366
00:18:23,690 --> 00:18:29,870
we didn't have for loops going for int
i equals 1, i less than or equal to 10.

367
00:18:29,870 --> 00:18:34,200
The reason being that starting from
zero makes this work well with arrays.

368
00:18:34,200 --> 00:18:36,270
So arrays are zero indexed.

369
00:18:36,270 --> 00:18:40,360
If this array is of length 4,
the indices are 0 through 3.

370
00:18:40,360 --> 00:18:42,880
>> So through the first
iteration of this for loop

371
00:18:42,880 --> 00:18:49,930
we're going to be setting age
bracket 0 equal to a call to GetInt.

372
00:18:49,930 --> 00:18:52,440
So whatever I happened
to enter at the keyboard.

373
00:18:52,440 --> 00:18:56,970
In the second pass, we're
setting age1 equal to GetInt.

374
00:18:56,970 --> 00:18:58,230
Third pass, age2.

375
00:18:58,230 --> 00:18:59,880
Final pass age3.

376
00:18:59,880 --> 00:19:05,750
So if in the first pass of the loop
I enter the number 4 at the keyboard,

377
00:19:05,750 --> 00:19:07,740
then we'll insert a 4 here.

378
00:19:07,740 --> 00:19:11,470
If on the second pass I enter
50, we'll put a 50 here.

379
00:19:11,470 --> 00:19:15,180
On the third pass I might
enter negative 1, negative 1,

380
00:19:15,180 --> 00:19:21,810
and then finally if I enter 0-- and
now remember that this was index three.

381
00:19:21,810 --> 00:19:25,350
>> After we loop back, i is
going to be incremented to 4.

382
00:19:25,350 --> 00:19:27,770
i is no longer less than n, which is 4.

383
00:19:27,770 --> 00:19:29,840
And we break out of the loop.

384
00:19:29,840 --> 00:19:32,578
So what would be wrong with this?

385
00:19:32,578 --> 00:19:38,140

386
00:19:38,140 --> 00:19:38,729
[INAUDIBLE]?

387
00:19:38,729 --> 00:19:39,604
AUDIENCE: [INAUDIBLE]

388
00:19:39,604 --> 00:19:45,880

389
00:19:45,880 --> 00:19:46,400
>> Yes.

390
00:19:46,400 --> 00:19:51,550
So the array only has four places,
which means as indices 0 through 3.

391
00:19:51,550 --> 00:19:55,630
So if this were the case, I would
take on the value 4 at some point.

392
00:19:55,630 --> 00:20:00,910
age bracket 4 will be setting
whatever happens to be over here

393
00:20:00,910 --> 00:20:02,920
to what I have to say, enter 6.

394
00:20:02,920 --> 00:20:05,010
That'll be setting this to 6.

395
00:20:05,010 --> 00:20:06,560
>> But we don't know what's over here.

396
00:20:06,560 --> 00:20:08,836
This is not memory
that we had access to.

397
00:20:08,836 --> 00:20:10,710
So if you remember from
the previous lecture,

398
00:20:10,710 --> 00:20:14,350
he was printing out values of Zamyla and
at some point he hit this segmentation

399
00:20:14,350 --> 00:20:17,990
fault. So you will probably be seeing
many segmentation faults as you

400
00:20:17,990 --> 00:20:20,530
implement some of the problem sets.

401
00:20:20,530 --> 00:20:24,950
But this is one of the ways in which
you can encounter a segmentation

402
00:20:24,950 --> 00:20:28,540
fault, when you start accessing
memory in ways that you shouldn't be.

403
00:20:28,540 --> 00:20:34,117
So we did not have access to
this location and this is a bug.

404
00:20:34,117 --> 00:20:37,760

405
00:20:37,760 --> 00:20:40,190
>> So this is better.

406
00:20:40,190 --> 00:20:45,820
Now there is still a small
issue with this code.

407
00:20:45,820 --> 00:20:50,720
And that's basically that we're
still stuck at four students.

408
00:20:50,720 --> 00:20:52,940
Now if I want to use eight students, OK.

409
00:20:52,940 --> 00:20:54,350
It's not that big a deal.

410
00:20:54,350 --> 00:20:58,120
I can go in, change the
comment, and change n.

411
00:20:58,120 --> 00:20:59,760
Now this will work with eight students.

412
00:20:59,760 --> 00:21:02,190
If I compile this and run
this, it will show me--

413
00:21:02,190 --> 00:21:07,870
it will request integers for eight
students and it will just work.

414
00:21:07,870 --> 00:21:11,850
But it's less than ideal to need to
recompile the program every single time

415
00:21:11,850 --> 00:21:15,960
I want to change the number of students
that I want to enter the ages for.

416
00:21:15,960 --> 00:21:22,990
>> So the final improvement on
this, as we'll see here-- we're

417
00:21:22,990 --> 00:21:26,177
going to request the number of people.

418
00:21:26,177 --> 00:21:28,010
Here we have a number
of people in the rooms

419
00:21:28,010 --> 00:21:29,880
or any ages of people in the room.

420
00:21:29,880 --> 00:21:33,300
But we're going to request the number
of people in the room from the user.

421
00:21:33,300 --> 00:21:36,171
So this is the exact same do-while
loop that we've seen before.

422
00:21:36,171 --> 00:21:37,920
It's the exact same
do-while loop that you

423
00:21:37,920 --> 00:21:40,050
may be implementing on the problem set.

424
00:21:40,050 --> 00:21:43,102
So as long as they're
entering an n less than 1,

425
00:21:43,102 --> 00:21:45,310
so there's got to be at
least one person in the room.

426
00:21:45,310 --> 00:21:47,407
As long as they're
entering an n less than 1,

427
00:21:47,407 --> 00:21:48,990
then we're going to keep asking again.

428
00:21:48,990 --> 00:21:50,906
Please enter the number
of people in the room.

429
00:21:50,906 --> 00:21:53,550
Now, once we have the number
of people in the room--

430
00:21:53,550 --> 00:21:58,020
so I might enter that there
are 200 people in this room.

431
00:21:58,020 --> 00:22:05,480
Then down here we're going to come
and declare an array of size 200.

432
00:22:05,480 --> 00:22:10,220
We're declaring array that's
big enough to hold 200 ages.

433
00:22:10,220 --> 00:22:15,370
Coming down, it's the for loop
that you will get very used to.

434
00:22:15,370 --> 00:22:19,490
So iterating over this array,
assigning to each location

435
00:22:19,490 --> 00:22:23,020
in that array an integer, and
then ultimately here we're

436
00:22:23,020 --> 00:22:28,340
just getting an example of iterating
over that array, not to assign values,

437
00:22:28,340 --> 00:22:30,150
but to access values.

438
00:22:30,150 --> 00:22:33,810
>> So over here we see that we
are saying, a year from now,

439
00:22:33,810 --> 00:22:40,470
person %i will be %i years old,
where the first %i is i plus 1.

440
00:22:40,470 --> 00:22:43,010
So i is this index variable.

441
00:22:43,010 --> 00:22:49,420
And the second %i is going to be the
value stored in the ages array plus 1.

442
00:22:49,420 --> 00:22:54,217
So this plus 1 is just because we're
saying-- this plus 1, ages i plus 1.

443
00:22:54,217 --> 00:22:57,050
This plus 1 is just because we're
saying, a year from now the person

444
00:22:57,050 --> 00:22:58,280
will be this old.

445
00:22:58,280 --> 00:23:01,080
>> So why is this i plus 1?

446
00:23:01,080 --> 00:23:04,064
Why we have a plus 1 there?

447
00:23:04,064 --> 00:23:04,564
Yeah.

448
00:23:04,564 --> 00:23:07,410

449
00:23:07,410 --> 00:23:07,930
Yes.

450
00:23:07,930 --> 00:23:10,510
So remember arrays are zero indexed.

451
00:23:10,510 --> 00:23:14,840
So if we are printing this out for
someone to just read the output,

452
00:23:14,840 --> 00:23:19,380
then probably they want to see something
like person one, person number one,

453
00:23:19,380 --> 00:23:21,160
will be 20 years old.

454
00:23:21,160 --> 00:23:23,570
Person number two will be 15 years old.

455
00:23:23,570 --> 00:23:27,420
They'd rather not see person
number zero is 15 years old.

456
00:23:27,420 --> 00:23:36,460
>> So compiling this and just seeing what
it looks like-- Create some space.

457
00:23:36,460 --> 00:23:43,560
Make ages compiles.

458
00:23:43,560 --> 00:23:45,080
Running ages.

459
00:23:45,080 --> 00:23:46,580
We see number of people in the room.

460
00:23:46,580 --> 00:23:48,850
So I'll say there are
three people in the room.

461
00:23:48,850 --> 00:23:54,000
Age of person number one,
let's say 15, 20, 25.

462
00:23:54,000 --> 00:23:59,680
And now I'll say a year from
now they will be 16, 21, 26.

463
00:23:59,680 --> 00:24:02,900
Let's see that this works with
an n that isn't equal to 3.

464
00:24:02,900 --> 00:24:07,940
So if I say number of people is 5, one,
two, three, two, one, a year from now

465
00:24:07,940 --> 00:24:11,170
they'll be two, three,
four, three, two years old.

466
00:24:11,170 --> 00:24:16,500
So I could just as
easily have n be 10,000.

467
00:24:16,500 --> 00:24:21,270
Now I will be sitting here for quite
a while entering ages, but this works.

468
00:24:21,270 --> 00:24:26,000
>> So now in memory somewhere we
have an array of size 10,000,

469
00:24:26,000 --> 00:24:28,830
so ultimately 40,000
bytes, because there are

470
00:24:28,830 --> 00:24:31,222
four bytes for each of those integers.

471
00:24:31,222 --> 00:24:33,180
So there's an array of
size 10,000 where we can

472
00:24:33,180 --> 00:24:36,201
store the ages of those 10,000 people.

473
00:24:36,201 --> 00:24:36,700
All right.

474
00:24:36,700 --> 00:24:40,070
Questions about any of this?

475
00:24:40,070 --> 00:24:41,892
Yeah.

476
00:24:41,892 --> 00:24:43,350
What if you gave a negative number?

477
00:24:43,350 --> 00:24:44,870
Let's see what happens.

478
00:24:44,870 --> 00:24:49,320
So in this particular case-- number
of people in the room, negative one.

479
00:24:49,320 --> 00:24:52,580
It rejected that,
because up here we happen

480
00:24:52,580 --> 00:24:57,180
to be handling the fact that if n is
less than one we're going to ask again.

481
00:24:57,180 --> 00:25:01,780
If you try to declare an
array of negative size,

482
00:25:01,780 --> 00:25:03,950
it generally doesn't work.

483
00:25:03,950 --> 00:25:05,570
>> So let's try.

484
00:25:05,570 --> 00:25:08,000
Let's ignore whatever
value they input for n

485
00:25:08,000 --> 00:25:10,571
and just say int ages negative one.

486
00:25:10,571 --> 00:25:12,410
Let's see if it even compiles.

487
00:25:12,410 --> 00:25:14,100
I am not sure.

488
00:25:14,100 --> 00:25:14,920
No.

489
00:25:14,920 --> 00:25:18,280
So ages is declared as an
array with a negative size.

490
00:25:18,280 --> 00:25:22,540
So upfront it recognizes an array cannot
be of negative size and rejects it.

491
00:25:22,540 --> 00:25:26,840
Now, if we didn't handle
this do-while loop correctly,

492
00:25:26,840 --> 00:25:28,810
if we weren't checking
if n is less than 1--

493
00:25:28,810 --> 00:25:32,690
let's say we just
didn't have this at all

494
00:25:32,690 --> 00:25:35,940
and instead we just grab an integer.

495
00:25:35,940 --> 00:25:40,710
No matter what that integer is,
we declare an array of that size.

496
00:25:40,710 --> 00:25:44,250
>> So the compiler cannot
possibly complain now.

497
00:25:44,250 --> 00:25:48,780
If I compile this--
so it can't complain,

498
00:25:48,780 --> 00:25:51,480
because it can't know that I'm
going to enter a negative number,

499
00:25:51,480 --> 00:25:52,550
which might be invalid.

500
00:25:52,550 --> 00:25:54,633
For all it knows, I might
enter a positive number,

501
00:25:54,633 --> 00:25:56,000
which is perfectly valid.

502
00:25:56,000 --> 00:26:01,090
So I imagine if I enter negative 1
people in the room, segmentation fault.

503
00:26:01,090 --> 00:26:06,040
>> So, OK.

504
00:26:06,040 --> 00:26:13,160
So let's add this back just
keep it what it originally was.

505
00:26:13,160 --> 00:26:15,640
So make ages.

506
00:26:15,640 --> 00:26:18,120
Now if I want to try a
negative age-- so let's

507
00:26:18,120 --> 00:26:19,710
say there are five people in the room.

508
00:26:19,710 --> 00:26:23,180
Age of person number one
is negative 4, person three

509
00:26:23,180 --> 00:26:26,500
is zero, person three-- OK.

510
00:26:26,500 --> 00:26:29,850
So here, a year from now, person number
one will be negative 3 years old.

511
00:26:29,850 --> 00:26:32,830
So probably doesn't make sense.

512
00:26:32,830 --> 00:26:37,220
But that's just because looking
at the code all we're doing

513
00:26:37,220 --> 00:26:40,260
is requesting GetInt.

514
00:26:40,260 --> 00:26:44,110
>> Now, if we had had the
GetPositiveInt function

515
00:26:44,110 --> 00:26:49,690
or we had just simply done this
sort of same while loop down there,

516
00:26:49,690 --> 00:26:52,340
then this would work perfectly fine.

517
00:26:52,340 --> 00:26:54,200
But in this particular
case, we just don't

518
00:26:54,200 --> 00:26:57,772
happen to be handling negative values.

519
00:26:57,772 --> 00:26:59,147
Any other questions about arrays?

520
00:26:59,147 --> 00:27:02,290

521
00:27:02,290 --> 00:27:03,250
OK.

522
00:27:03,250 --> 00:27:09,380
>> So we've now seen arrays.

523
00:27:09,380 --> 00:27:12,500
And we're going to need to use
this for command-line arguments.

524
00:27:12,500 --> 00:27:14,680
So in problem set two--
I know many of you

525
00:27:14,680 --> 00:27:18,040
might still be working on problem set
one, but problem set two is coming up.

526
00:27:18,040 --> 00:27:22,260
In problem set two, you're going to
need to be dealing with strings, arrays,

527
00:27:22,260 --> 00:27:23,950
and command-line arguments.

528
00:27:23,950 --> 00:27:26,270
>> So what are command line arguments?

529
00:27:26,270 --> 00:27:29,570
Now, you can see down here a
little teaser for exactly what's

530
00:27:29,570 --> 00:27:30,950
going to be happening.

531
00:27:30,950 --> 00:27:32,950
We see int main, inc argc,
string argv brackets.

532
00:27:32,950 --> 00:27:34,560

533
00:27:34,560 --> 00:27:38,130
So first let's try to interpret
what that's trying to say.

534
00:27:38,130 --> 00:27:40,800
Now, OK.

535
00:27:40,800 --> 00:27:44,637
>> So at the command line you should be
getting used to some of these commands

536
00:27:44,637 --> 00:27:48,580
now, and you've probably run
cd in the terminal before.

537
00:27:48,580 --> 00:27:52,100
So if we say cd pset1,
you know that that should

538
00:27:52,100 --> 00:27:55,050
be changing into the pset1 directory.

539
00:27:55,050 --> 00:27:59,120
>> Now notice that you've never
written a program like this before.

540
00:27:59,120 --> 00:28:03,120
Each program that you've written,
you would run, say, dot slash Mario,

541
00:28:03,120 --> 00:28:06,779
dot slash greedy, and then it
might prompt you for input.

542
00:28:06,779 --> 00:28:08,570
Now, that's not what
change directory does.

543
00:28:08,570 --> 00:28:12,770
When you run cd, it doesn't then say,
which directory do you want to cd into?

544
00:28:12,770 --> 00:28:17,200
Instead, you just say, cd pset1, and
it just goes into the pset1 directory.

545
00:28:17,200 --> 00:28:20,430
>> So similarly we have other examples.

546
00:28:20,430 --> 00:28:21,540
make hello.

547
00:28:21,540 --> 00:28:25,760
When you run make, it doesn't then say,
which program would you like to make?

548
00:28:25,760 --> 00:28:29,620
You just say, at the
command line make hello.

549
00:28:29,620 --> 00:28:31,060
>> Move is another example.

550
00:28:31,060 --> 00:28:34,840
This one we are moving the
mario.c file up one directory.

551
00:28:34,840 --> 00:28:38,060
So now we know with this example
we're really passing two arguments.

552
00:28:38,060 --> 00:28:42,090
There's mario.c as the first argument,
and dot dot is the second argument.

553
00:28:42,090 --> 00:28:46,140
And then when you run make, you
see that really long command line--

554
00:28:46,140 --> 00:28:50,580
that really long command
printed at the command line.

555
00:28:50,580 --> 00:28:53,590
So that long command-- this
is just a short part of it,

556
00:28:53,590 --> 00:28:56,090
but now we have three
command-line arguments.

557
00:28:56,090 --> 00:28:59,750
Dot dash zero, hello, and hello.c.

558
00:28:59,750 --> 00:29:03,497
>> So these are command-line
arguments, arguments

559
00:29:03,497 --> 00:29:05,580
that you're passing at the
command line so that it

560
00:29:05,580 --> 00:29:08,680
doesn't have to be prompted
when you run the program.

561
00:29:08,680 --> 00:29:13,090
It would be frustrating if when
you ran clang it said, "OK,

562
00:29:13,090 --> 00:29:15,630
which program-- which
file are you compiling?

563
00:29:15,630 --> 00:29:17,010
Hello.c.

564
00:29:17,010 --> 00:29:19,440
What flags would you
like to enter? dash o.

565
00:29:19,440 --> 00:29:21,190
What would you like
the file to be called?

566
00:29:21,190 --> 00:29:21,690
hello.

567
00:29:21,690 --> 00:29:25,290
No, you just run clang
dash o hello hello.c.

568
00:29:25,290 --> 00:29:28,820
>> So looking back at this.

569
00:29:28,820 --> 00:29:32,920
Now argc-- argc is the argument counts.

570
00:29:32,920 --> 00:29:36,620
It's the number of command-line
arguments entered at the command line.

571
00:29:36,620 --> 00:29:39,720
Well, argv-- technically
the v stands for vector,

572
00:29:39,720 --> 00:29:41,460
which basically means array.

573
00:29:41,460 --> 00:29:42,680
But you can ignore that.

574
00:29:42,680 --> 00:29:47,540
Argv-- we have string argv,
so string argv brackets.

575
00:29:47,540 --> 00:29:50,150
So this is another form of
brackets you haven't seen before.

576
00:29:50,150 --> 00:29:52,300
So we've seen bracket
notation when we've said,

577
00:29:52,300 --> 00:29:53,970
like, string s equals Zamyla.

578
00:29:53,970 --> 00:29:56,910
s bracket 0 accesses the character Z.

579
00:29:56,910 --> 00:30:00,720
>> We've also seen brackets when
we said int ages bracket 5.

580
00:30:00,720 --> 00:30:03,160
That declared an array of size 5.

581
00:30:03,160 --> 00:30:06,280
So here is a version of the
brackets we haven't seen before.

582
00:30:06,280 --> 00:30:09,630
So this sort of string argv that
would be completely familiar

583
00:30:09,630 --> 00:30:12,050
that it would just be a string.

584
00:30:12,050 --> 00:30:14,520
Now the brackets indicate
that this is an array.

585
00:30:14,520 --> 00:30:19,920
So string argv brackets means
that argv is an array of strings.

586
00:30:19,920 --> 00:30:22,540
Now technically a string
is an array of characters.

587
00:30:22,540 --> 00:30:26,400
So this is now an array
of an array of characters.

588
00:30:26,400 --> 00:30:31,490
But it's much easier to think about
this as just an array of strings.

589
00:30:31,490 --> 00:30:34,900
>> So why might the brackets be empty?

590
00:30:34,900 --> 00:30:38,170
Like, why can't we say,
bracket 5, bracket n?

591
00:30:38,170 --> 00:30:40,700

592
00:30:40,700 --> 00:30:41,200
Yeah.

593
00:30:41,200 --> 00:30:43,731

594
00:30:43,731 --> 00:30:44,230
Yeah.

595
00:30:44,230 --> 00:30:46,396
We don't know how many
inputs there are going to be.

596
00:30:46,396 --> 00:30:53,560
So if we look at the clang example,
we say clang dash o hello hello.c.

597
00:30:53,560 --> 00:30:56,710
In this particular case, there happen
to be three command-line arguments.

598
00:30:56,710 --> 00:31:00,522
And so the brackets-- we'll see
in a second it wouldn't be three.

599
00:31:00,522 --> 00:31:01,730
It technically would be four.

600
00:31:01,730 --> 00:31:04,030
But the brackets, we would
say, there are three.

601
00:31:04,030 --> 00:31:08,220
But now if we looked at move
mario.c dot dot, the brackets

602
00:31:08,220 --> 00:31:09,760
we would want to put two in them.

603
00:31:09,760 --> 00:31:12,884
>> And there are a lot of commands that
have a variable number of command line

604
00:31:12,884 --> 00:31:13,620
arguments.

605
00:31:13,620 --> 00:31:17,430
So what this version of the
bracket notation indicates

606
00:31:17,430 --> 00:31:20,820
is that argv is an array of strings.

607
00:31:20,820 --> 00:31:24,360
But we don't know how many
strings are in that array.

608
00:31:24,360 --> 00:31:27,090
And how do we then know how
many strings are in the array?

609
00:31:27,090 --> 00:31:28,870
That's the whole point argc.

610
00:31:28,870 --> 00:31:32,300
argc tells us how long argv is.

611
00:31:32,300 --> 00:31:36,500
>> So the last thing to keep in
mind is that, technically,

612
00:31:36,500 --> 00:31:40,820
the command itself counts as one
of the command-line arguments.

613
00:31:40,820 --> 00:31:45,330
So cd pset1, there are two
command-line arguments.

614
00:31:45,330 --> 00:31:50,260
The program in itself, cd, and then
the actual argument part of it, pset1.

615
00:31:50,260 --> 00:31:54,490
Any program that you've written thus far
has had one command-line argument-- dot

616
00:31:54,490 --> 00:31:55,320
slash Mario.

617
00:31:55,320 --> 00:31:57,350
That is the only command-line argument.

618
00:31:57,350 --> 00:32:00,900
>> So now looking at clang
dash o hello hello.c.

619
00:32:00,900 --> 00:32:01,905
So what is argc?

620
00:32:01,905 --> 00:32:05,260

621
00:32:05,260 --> 00:32:06,080
4.

622
00:32:06,080 --> 00:32:08,140
So argc is 4.

623
00:32:08,140 --> 00:32:12,140
Clang, so argv bracket 0 is clang.

624
00:32:12,140 --> 00:32:15,630
argv bracket 1 is dash 0.

625
00:32:15,630 --> 00:32:21,870
argv bracket 2 is hello, and
argv bracket 3 is hello.c.

626
00:32:21,870 --> 00:32:26,813
OK, so questions on this, and then we'll
look at some programmatic examples.

627
00:32:26,813 --> 00:32:29,460

628
00:32:29,460 --> 00:32:30,480
>> OK.

629
00:32:30,480 --> 00:32:36,260
So we'll take a look at hello3.c.

630
00:32:36,260 --> 00:32:41,890
So this should be familiar from
one of the first c examples

631
00:32:41,890 --> 00:32:45,800
we had where we would just say, hello
world, but now this is more general.

632
00:32:45,800 --> 00:32:52,300
So here we are saying hello
%s backslash n argv bracket 1.

633
00:32:52,300 --> 00:32:57,440
Notice-- so up till this point, this is
what my template file has looked like.

634
00:32:57,440 --> 00:33:01,800
I had int main(void), and then I would
do something in the main function.

635
00:33:01,800 --> 00:33:05,100
Now instead, once we start dealing
with command-line arguments,

636
00:33:05,100 --> 00:33:07,890
we need to state a
different form of main.

637
00:33:07,890 --> 00:33:11,930
>> So looking at hello3
again, the main is going

638
00:33:11,930 --> 00:33:15,990
to take two arguments now-- int argc,
the number of command-line arguments,

639
00:33:15,990 --> 00:33:20,970
and string argv brackets, the actual
strings entered at the command line.

640
00:33:20,970 --> 00:33:26,560
So I'm going to change that
template to reflect that fact.

641
00:33:26,560 --> 00:33:29,060
Now whenever you write
a program, if you don't

642
00:33:29,060 --> 00:33:33,720
need to take any command-line
arguments, then just use int main(void).

643
00:33:33,720 --> 00:33:37,070
But now when you're writing
command-line argument programs, which

644
00:33:37,070 --> 00:33:40,350
you're going to be doing for problem
set two-- so now that you're running

645
00:33:40,350 --> 00:33:42,630
programs that need to take
command-line arguments,

646
00:33:42,630 --> 00:33:45,250
you need to have main of this form.

647
00:33:45,250 --> 00:33:51,290
>> So here-- this is the big usage
of the command-line argument.

648
00:33:51,290 --> 00:33:54,100
So printing argv 1.

649
00:33:54,100 --> 00:33:59,180
OK so let's compile
and run this program.

650
00:33:59,180 --> 00:34:02,440
Make hello3.

651
00:34:02,440 --> 00:34:03,570
Compiles.

652
00:34:03,570 --> 00:34:06,870
Dot slash hello3.

653
00:34:06,870 --> 00:34:08,920
And let's say, "Rob."

654
00:34:08,920 --> 00:34:10,760
Hello Rob.

655
00:34:10,760 --> 00:34:14,940
If I say, "hello Maria," hello Maria.

656
00:34:14,940 --> 00:34:15,719
Hello Maria.

657
00:34:15,719 --> 00:34:18,639
Hannah still says, "hello
Maria," because I'm not

658
00:34:18,639 --> 00:34:21,340
doing anything with our argv 2.

659
00:34:21,340 --> 00:34:22,590
Argv 2 now would be "Hannah."

660
00:34:22,590 --> 00:34:25,030
Argc would be 3.

661
00:34:25,030 --> 00:34:27,735
What if I did this?

662
00:34:27,735 --> 00:34:31,980

663
00:34:31,980 --> 00:34:34,679
So hello null.

664
00:34:34,679 --> 00:34:38,760
>> He briefly touched on the fact
that, technically, GetString

665
00:34:38,760 --> 00:34:42,429
might return null, but we'll get a
lot more into what null actually is.

666
00:34:42,429 --> 00:34:47,449
But take it as a matter of
fact that no is generally bad.

667
00:34:47,449 --> 00:34:50,179
We did something wrong if
it's printing "hello null."

668
00:34:50,179 --> 00:34:52,179
And the reason we did
something wrong is-- well,

669
00:34:52,179 --> 00:34:56,179
when I ran dot slash hello3, argc was 1.

670
00:34:56,179 --> 00:34:59,680
So that means the length of argv was 1.

671
00:34:59,680 --> 00:35:05,110
If an array is of length 1,
the only valid index is zero.

672
00:35:05,110 --> 00:35:08,550
And so here argv 1 is outside
the range of this array.

673
00:35:08,550 --> 00:35:13,410
It was similar to before when I tried
to store 6 outside the end of the array.

674
00:35:13,410 --> 00:35:18,100
So I'm trying to access something
outside of the argv counts,

675
00:35:18,100 --> 00:35:21,340
and we're getting null.

676
00:35:21,340 --> 00:35:24,360
>> So a better version of
this, an improvement,

677
00:35:24,360 --> 00:35:27,010
is explicitly checking argc.

678
00:35:27,010 --> 00:35:33,580
So if argc equals 2, that means we ran
something like dot slash hello3 Rob.

679
00:35:33,580 --> 00:35:36,840
And it will print "hello Rob."

680
00:35:36,840 --> 00:35:39,850
If argc does not equal
2, then it's just going

681
00:35:39,850 --> 00:35:42,560
to ignore whatever you put
at the command-line argument

682
00:35:42,560 --> 00:35:43,960
as command-line arguments.

683
00:35:43,960 --> 00:35:47,168
Or if you didn't put any at all, it's
just going to ignore that and just say,

684
00:35:47,168 --> 00:35:47,960
"hello you."

685
00:35:47,960 --> 00:35:51,490
>> So compiling this.

686
00:35:51,490 --> 00:35:54,500
Make hello4.

687
00:35:54,500 --> 00:35:56,790
And running hello4.

688
00:35:56,790 --> 00:36:00,010
Running it this way,
what should be printed?

689
00:36:00,010 --> 00:36:01,330
"Hello you."

690
00:36:01,330 --> 00:36:02,810
Hello you.

691
00:36:02,810 --> 00:36:05,870
What about hello4 Rob?

692
00:36:05,870 --> 00:36:06,950
"Hello Rob."

693
00:36:06,950 --> 00:36:10,580
And finally, hello Rob Maria
is just "hello You" again,

694
00:36:10,580 --> 00:36:13,677
because you didn't really enter
something that it expected.

695
00:36:13,677 --> 00:36:15,510
You entered more names
than it could handle,

696
00:36:15,510 --> 00:36:19,500
so it just defaulted to
the hello you behavior.

697
00:36:19,500 --> 00:36:23,040
So questions on this?

698
00:36:23,040 --> 00:36:26,290
Or command-line arguments?

699
00:36:26,290 --> 00:36:28,690
>> OK, so taking a look at a
couple more examples of using

700
00:36:28,690 --> 00:36:34,230
command-line arguments-- first
we have argv dash 1 dot c.

701
00:36:34,230 --> 00:36:38,510
So the comments give away what
this program should be doing.

702
00:36:38,510 --> 00:36:42,460
But notice now-- this for loop,
this matches the exact pattern

703
00:36:42,460 --> 00:36:43,390
I was saying before.

704
00:36:43,390 --> 00:36:46,240
We just happen to be
using argc instead of n.

705
00:36:46,240 --> 00:36:48,880
Now argc is really the n.

706
00:36:48,880 --> 00:36:51,260
It's the length of the argv array.

707
00:36:51,260 --> 00:36:59,600
So are iterating over the argv
array printf-ing each argv value.

708
00:36:59,600 --> 00:37:04,730
>> So if I make this.

709
00:37:04,730 --> 00:37:08,232
Make argv 1.

710
00:37:08,232 --> 00:37:09,940
It compiles.

711
00:37:09,940 --> 00:37:11,620
Dot slash argv 1.

712
00:37:11,620 --> 00:37:15,530
Just running this, it
prints dot slash argv 1

713
00:37:15,530 --> 00:37:18,500
since that was the only command-line
argument-- the program name.

714
00:37:18,500 --> 00:37:22,080
There will always be at least--
argc cannot be less than one,

715
00:37:22,080 --> 00:37:25,910
since there will always at least
be the program name to run.

716
00:37:25,910 --> 00:37:32,040
So argv 1 Rob will print argv 1
and then on the new line "Rob."

717
00:37:32,040 --> 00:37:36,350
>> So in the first iteration
of this loop, i is 0.

718
00:37:36,350 --> 00:37:39,090
Argv 0 is the program name.

719
00:37:39,090 --> 00:37:40,010
Dot slash argv 1.

720
00:37:40,010 --> 00:37:43,770
And then argv 1 is my first
command-line argument, which is Rob.

721
00:37:43,770 --> 00:37:45,920
At this point, we are equal to argc.

722
00:37:45,920 --> 00:37:48,210
We break out of the loop and we're done.

723
00:37:48,210 --> 00:37:53,940
So this will work for an arbitrary
number of command-line arguments.

724
00:37:53,940 --> 00:37:58,550
Notice it prints argv 0, argv
1, argv 2, argv 3, argv 4.

725
00:37:58,550 --> 00:38:00,150
And there is no argv 5.

726
00:38:00,150 --> 00:38:01,460
argc is equal to 5.

727
00:38:01,460 --> 00:38:06,960
So at argc-- at i equals 5,
we break out of the loop.

728
00:38:06,960 --> 00:38:07,950
OK.

729
00:38:07,950 --> 00:38:11,315
So questions on that before we
look at a more complex example?

730
00:38:11,315 --> 00:38:14,190

731
00:38:14,190 --> 00:38:16,860
>> So argv 2.

732
00:38:16,860 --> 00:38:17,830
All right.

733
00:38:17,830 --> 00:38:20,610
So we're still printing
the command-line arguments.

734
00:38:20,610 --> 00:38:23,170
But now notice we have
a nested for loop.

735
00:38:23,170 --> 00:38:24,670
So what is this doing?

736
00:38:24,670 --> 00:38:28,430
So the first loop is doing
exactly what it did before.

737
00:38:28,430 --> 00:38:30,950
We're still looping over
each command-line argument,

738
00:38:30,950 --> 00:38:34,260
but now this second loop-- we've
also seen something like this before.

739
00:38:34,260 --> 00:38:38,600
When he was iterating over
Zamyla printing out Z-A-M-Y-L-A.

740
00:38:38,600 --> 00:38:44,816
So this second loop for int j equals
0, n equals strlen of argv bracket i.

741
00:38:44,816 --> 00:38:49,170
>> So let's first think for
the-- let's walk through.

742
00:38:49,170 --> 00:38:53,560
Let's think what the computer would
do if I ran this program as just dot

743
00:38:53,560 --> 00:38:56,030
slash argv dash 2.

744
00:38:56,030 --> 00:39:03,590
So if I ran this code, then
argc is going to be equal to 1.

745
00:39:03,590 --> 00:39:07,050
And string argv-- there's only
going to be one index in argv,

746
00:39:07,050 --> 00:39:12,370
and that's going to be equal to dot
slash argv 2-- the program name.

747
00:39:12,370 --> 00:39:19,170
>> OK, so now i equals 0, i less than
1, i plus plus for int j equals 0,

748
00:39:19,170 --> 00:39:23,880
n equals strlen of argv bracket 0, so in
the first iteration of this loop. argv

749
00:39:23,880 --> 00:39:27,250
bracket 0 is dot slash argv 2.

750
00:39:27,250 --> 00:39:29,320
So what is the length of that string?

751
00:39:29,320 --> 00:39:32,480
Well, dot slash A-R-G-V dash 2.

752
00:39:32,480 --> 00:39:35,020
So strlen of that will be 8.

753
00:39:35,020 --> 00:39:37,500
So j equals 0, n equals 8.

754
00:39:37,500 --> 00:39:39,530
As long as j is less than 8, j++.

755
00:39:39,530 --> 00:39:44,080
And with that we're going to be
printing a single character, which

756
00:39:44,080 --> 00:39:47,350
is argv bracket i bracket j.

757
00:39:47,350 --> 00:39:49,826
>> So the only i is zero.

758
00:39:49,826 --> 00:39:51,700
We still only have one
command-line argument.

759
00:39:51,700 --> 00:39:53,890
In that first iteration
of the for loop, we're

760
00:39:53,890 --> 00:39:56,950
going to be printing
argv bracket 0 bracket 0.

761
00:39:56,950 --> 00:39:58,325
And then j is going to increment.

762
00:39:58,325 --> 00:40:01,650
And we're going to printing
argv bracket 0 bracket 1.

763
00:40:01,650 --> 00:40:04,150
And then argv bracket 0 bracket 2.

764
00:40:04,150 --> 00:40:09,030
>> So this is our first encounter
of multi-dimensional arrays.

765
00:40:09,030 --> 00:40:12,770
Remember earlier that I said
that argv is technically

766
00:40:12,770 --> 00:40:15,950
an array of arrays of characters.

767
00:40:15,950 --> 00:40:24,360
So here if I said something like
string s equals argv bracket i,

768
00:40:24,360 --> 00:40:29,590
and then I said, s bracket j, this
would be accomplishing the same thing.

769
00:40:29,590 --> 00:40:31,960
Now, you've seen s bracket j before.

770
00:40:31,960 --> 00:40:36,680
That's just access the j-th
character of this string.

771
00:40:36,680 --> 00:40:48,010
So with this, we are getting the
j-th character of the i-th argv.

772
00:40:48,010 --> 00:40:51,450
>> So what should this ultimately output?

773
00:40:51,450 --> 00:40:53,210
Make argv 2.

774
00:40:53,210 --> 00:40:54,730
It compiles.

775
00:40:54,730 --> 00:40:56,340
Dot slash argv 2.

776
00:40:56,340 --> 00:41:03,790
"Rob Maria Hannah,"
and give us some room.

777
00:41:03,790 --> 00:41:07,050
So we see that this is outputting
dot on its own line and slash

778
00:41:07,050 --> 00:41:08,920
on its own line and a on its own line.

779
00:41:08,920 --> 00:41:11,260
It's printing out each
individual character

780
00:41:11,260 --> 00:41:12,950
of each command-line argument.

781
00:41:12,950 --> 00:41:15,960
And then in between them,
because of this new line

782
00:41:15,960 --> 00:41:19,380
we're printing down here, in
between them it'll print a new line.

783
00:41:19,380 --> 00:41:24,540
>> So this is similar to
the prior argv dash 1,

784
00:41:24,540 --> 00:41:26,459
which printed each
command-line argument,

785
00:41:26,459 --> 00:41:28,500
but now we're printing
the command-line arguments

786
00:41:28,500 --> 00:41:31,950
and then iterating through each
character of each command-line argument

787
00:41:31,950 --> 00:41:35,400
to get this output.

788
00:41:35,400 --> 00:41:36,870
OK?

789
00:41:36,870 --> 00:41:40,570
So questions on this?

790
00:41:40,570 --> 00:41:45,130
>> One thing to note is that
command-line arguments--

791
00:41:45,130 --> 00:41:49,990
so they are separated by spaces as
you would naturally expect them to be.

792
00:41:49,990 --> 00:41:53,050
So a string can have spaces in it.

793
00:41:53,050 --> 00:41:57,380
It's not super important, but if I
wanted the third command-line argument

794
00:41:57,380 --> 00:42:01,226
to have a space in it, then I
could say something like this.

795
00:42:01,226 --> 00:42:04,470

796
00:42:04,470 --> 00:42:05,550
OK?

797
00:42:05,550 --> 00:42:12,190
So this now still only has three
command-line arguments-- well 4.

798
00:42:12,190 --> 00:42:17,620
Dot slash argv dash 2, Rob,
Maria, and Hannah Bloomberg.

799
00:42:17,620 --> 00:42:18,320
OK.

800
00:42:18,320 --> 00:42:19,310
Questions on this?

801
00:42:19,310 --> 00:42:22,700

802
00:42:22,700 --> 00:42:24,894
>> There's nothing special
about the space character.

803
00:42:24,894 --> 00:42:27,810
It just happens to be that the
command-line treats the space character

804
00:42:27,810 --> 00:42:29,226
as how you separate each argument.

805
00:42:29,226 --> 00:42:32,048

806
00:42:32,048 --> 00:42:33,000
All right.

807
00:42:33,000 --> 00:42:39,950
So then Problem set
two-- you're going to be

808
00:42:39,950 --> 00:42:43,240
looking at secret-key cryptography.

809
00:42:43,240 --> 00:42:47,700
So, similar to that example
we saw from A Christmas Story,

810
00:42:47,700 --> 00:42:52,840
you're going to be implementing some
algorithms that, given a message,

811
00:42:52,840 --> 00:42:55,560
you're going to be able
to encrypt that message

812
00:42:55,560 --> 00:42:58,730
that only someone with that secret
key, with that decoder ring,

813
00:42:58,730 --> 00:43:01,090
should be able to decrypt.

814
00:43:01,090 --> 00:43:04,839
>> So that is the standard edition.

815
00:43:04,839 --> 00:43:07,130
You're going to be implementing
two different versions.

816
00:43:07,130 --> 00:43:09,620
If you happen to take a look
at the hacker edition-- now,

817
00:43:09,620 --> 00:43:12,600
we're going to give
you a string like this,

818
00:43:12,600 --> 00:43:15,240
which represents an encrypted password.

819
00:43:15,240 --> 00:43:19,990
So your goal is to figure out
what the decrypted password is.

820
00:43:19,990 --> 00:43:26,950
Now this is actually how passwords
are stored in a lot of computers,

821
00:43:26,950 --> 00:43:31,290
and it just stores this
random string of characters.

822
00:43:31,290 --> 00:43:34,440
You have to figure out how to get
from this random string of characters

823
00:43:34,440 --> 00:43:36,140
to what the original password was.

824
00:43:36,140 --> 00:43:39,060

825
00:43:39,060 --> 00:43:43,290
>> And finally, after this
problem set, you should

826
00:43:43,290 --> 00:43:46,100
be able to understand what this means.

827
00:43:46,100 --> 00:43:51,650
So you will learn how to decrypt
this sort of random string.

828
00:43:51,650 --> 00:43:56,390
Similarly, if you remember from week
0, you might have seen this URL.

829
00:43:56,390 --> 00:44:00,210
And you should be able to
decrypt this eventually.

830
00:44:00,210 --> 00:44:04,810
You might not be happy when you
decrypt it and click on the link.

831
00:44:04,810 --> 00:44:05,700
All right.

832
00:44:05,700 --> 00:44:06,591
That's it for today.

833
00:44:06,591 --> 00:44:12,095
So see you next week!

834
00:44:12,095 --> 00:44:18,315
>> [ELECTRONIC MUSIC PLAYING]

835
00:44:18,315 --> 00:47:15,619
