1
00:00:00,000 --> 00:00:00,960

2
00:00:00,960 --> 00:00:03,360
>> [MUSIC PLAYING]

3
00:00:03,360 --> 00:00:11,050

4
00:00:11,050 --> 00:00:12,065
>> DAVIN: All right, guys.

5
00:00:12,065 --> 00:00:13,642

6
00:00:13,642 --> 00:00:15,350
So this is the review
for the first quiz.

7
00:00:15,350 --> 00:00:17,751
Is everybody ready for
the quiz on Wednesday?

8
00:00:17,751 --> 00:00:18,292
ALLISON: Woo!

9
00:00:18,292 --> 00:00:18,743
STUDENT: Woo!

10
00:00:18,743 --> 00:00:19,242
DAVIN: Yeah.

11
00:00:19,242 --> 00:00:19,920
ALLISON: Yeah!

12
00:00:19,920 --> 00:00:20,920
DAVIN: That guy's ready.

13
00:00:20,920 --> 00:00:22,200
That guy, two hands, nice.

14
00:00:22,200 --> 00:00:23,234

15
00:00:23,234 --> 00:00:25,900
So quiz review today, it's going
to be about an hour and a half.

16
00:00:25,900 --> 00:00:27,940
We're going to go over all the major
concepts you should know for the quiz.

17
00:00:27,940 --> 00:00:31,434
We're going to go over some coding by
hand examples, which are on every quiz.

18
00:00:31,434 --> 00:00:34,350
And if you have questions, feel free
to raise your hand and everything

19
00:00:34,350 --> 00:00:34,945
like that.

20
00:00:34,945 --> 00:00:36,695
Well, logistics about
the quiz are online.

21
00:00:36,695 --> 00:00:38,450
So we're going to split people
up into different rooms.

22
00:00:38,450 --> 00:00:39,491
It's based on their name.

23
00:00:39,491 --> 00:00:43,630
So if you have any questions about where
to go or about what material is, like,

24
00:00:43,630 --> 00:00:46,810
the official word on what's going
to be on the quiz, check online.

25
00:00:46,810 --> 00:00:48,420
And that's all up to date.

26
00:00:48,420 --> 00:00:51,280
So if there are no questions to
begin with, we're going to start.

27
00:00:51,280 --> 00:00:52,790

28
00:00:52,790 --> 00:00:53,710
And here's Allison.

29
00:00:53,710 --> 00:00:56,060

30
00:00:56,060 --> 00:00:57,000
>> [CLAPS]

31
00:00:57,000 --> 00:00:59,300
>> ALLISON: OK, thanks, Rob.

32
00:00:59,300 --> 00:01:00,280
Appreciate it.

33
00:01:00,280 --> 00:01:01,350

34
00:01:01,350 --> 00:01:03,050
Davin should have flipped to this.

35
00:01:03,050 --> 00:01:07,240
This is the non-exhaustive list of
topics, as always, as Davin just said.

36
00:01:07,240 --> 00:01:10,860
Consult the documentation
online about quiz zero.

37
00:01:10,860 --> 00:01:13,680
But this is pretty much--
it's on the syllabus

38
00:01:13,680 --> 00:01:15,550
is everything we've gone over thus far.

39
00:01:15,550 --> 00:01:18,290
Everything here is fair game,
as well as anything else

40
00:01:18,290 --> 00:01:21,380
that may have been mentioned in lecture.

41
00:01:21,380 --> 00:01:25,070
>> My section, here, is
just a lot of review.

42
00:01:25,070 --> 00:01:27,775
There are a couple exercises
that you guys might work on.

43
00:01:27,775 --> 00:01:30,650
But for the most part, we really
want to get to Davin with those code

44
00:01:30,650 --> 00:01:31,710
by hand exercises.

45
00:01:31,710 --> 00:01:33,940
>> So I am going to fly through this.

46
00:01:33,940 --> 00:01:36,330
If you have any questions, stop me.

47
00:01:36,330 --> 00:01:37,270
Raise your hand.

48
00:01:37,270 --> 00:01:39,250
I promise I'll probably see you.

49
00:01:39,250 --> 00:01:41,042
If not, just wave it around.

50
00:01:41,042 --> 00:01:42,250
I'm going to be talking fast.

51
00:01:42,250 --> 00:01:43,950
I hope everyone's OK with that.

52
00:01:43,950 --> 00:01:48,020
>> OK, special word, Davin obviously
forgot to flip through these slides.

53
00:01:48,020 --> 00:01:51,880
[LAUGHS] You're in trouble, man.

54
00:01:51,880 --> 00:01:55,770
So tips for quiz zero,
practice coding on paper.

55
00:01:55,770 --> 00:01:58,950
You guys are going to get some
practice with that now with Davin,

56
00:01:58,950 --> 00:02:00,655
so you won't be completely by yourself.

57
00:02:00,655 --> 00:02:03,030
I think we're actually going
through these two functions.

58
00:02:03,030 --> 00:02:04,500
So you'll be well prepared there.

59
00:02:04,500 --> 00:02:05,958
>> Be familiar with your problem sets.

60
00:02:05,958 --> 00:02:08,150
There have been questions
on previous quizzes

61
00:02:08,150 --> 00:02:12,680
that will ask you, for example, to code
up something very similar to Mario.

62
00:02:12,680 --> 00:02:15,060
So being very familiar with
your problem sets, as well

63
00:02:15,060 --> 00:02:17,827
as the questions we ask you
in the beginning on the form

64
00:02:17,827 --> 00:02:19,660
that you fill out, will
serve you very well.

65
00:02:19,660 --> 00:02:20,940

66
00:02:20,940 --> 00:02:23,380
>> Do a previous quiz under
the time constraints.

67
00:02:23,380 --> 00:02:25,430
These quizzes are long.

68
00:02:25,430 --> 00:02:26,850
The time goes really fast.

69
00:02:26,850 --> 00:02:30,480
And often, you don't realize how
fast it goes until you actually

70
00:02:30,480 --> 00:02:32,180
put yourself under those constraints.

71
00:02:32,180 --> 00:02:36,500
So if you can just carve out, you know,
75 minutes, either tonight or tomorrow

72
00:02:36,500 --> 00:02:41,020
to take one of these quizzes under
that, you will be in much better shape.

73
00:02:41,020 --> 00:02:43,060
>> And also, creating your reference sheet.

74
00:02:43,060 --> 00:02:45,290
Remember, you get one
page front and back

75
00:02:45,290 --> 00:02:47,040
as reference for your quiz on Wednesday.

76
00:02:47,040 --> 00:02:49,074
Creating that is a great way to study.

77
00:02:49,074 --> 00:02:51,990
Anything that you're having trouble
with you want to include on there.

78
00:02:51,990 --> 00:02:55,627
Anything that your TFs have been,
like, this is really important.

79
00:02:55,627 --> 00:02:57,960
You should know this, are
maybe things you have on there

80
00:02:57,960 --> 00:02:59,931
if you don't have them memorized.

81
00:02:59,931 --> 00:03:02,680
Even if you do know them really
well, sometimes having it on there

82
00:03:02,680 --> 00:03:07,030
is just kind of comfort for you,
which I know quizzes are stressful.

83
00:03:07,030 --> 00:03:09,260
So any comfort you get can help.

84
00:03:09,260 --> 00:03:13,072
All right, also, get sleep and
eat and like the normal things

85
00:03:13,072 --> 00:03:14,280
that we tell you for quizzes.

86
00:03:14,280 --> 00:03:16,320

87
00:03:16,320 --> 00:03:18,890
>> So starting off easy,
data types and sizes.

88
00:03:18,890 --> 00:03:22,720
As I said, this is just going
to be me throwing a lot of stuff

89
00:03:22,720 --> 00:03:24,320
up here that you should know.

90
00:03:24,320 --> 00:03:27,600
So we have our chars
that are one bytes, ints

91
00:03:27,600 --> 00:03:30,390
that are four bytes, long
long, which are eight bytes.

92
00:03:30,390 --> 00:03:33,280
Basically, it's just you
want to hold larger integers.

93
00:03:33,280 --> 00:03:35,490
Floats, which are four,
doubles, which are eight.

94
00:03:35,490 --> 00:03:38,150
Again, just gives you more
space for your floats.

95
00:03:38,150 --> 00:03:41,290
And then type star, so any
pointer on a 32-bit machine,

96
00:03:41,290 --> 00:03:44,650
which is all you guys need
to know, is four bytes.

97
00:03:44,650 --> 00:03:46,542
>> So all things you should
know, maybe things

98
00:03:46,542 --> 00:03:48,250
you want to have on
your reference sheet.

99
00:03:48,250 --> 00:03:50,350

100
00:03:50,350 --> 00:03:53,520
OK, binary conversion
to binary, conversion

101
00:03:53,520 --> 00:03:56,860
to hexadecimal, back and forth,
all things you should know.

102
00:03:56,860 --> 00:03:59,480
So from binary to decimal.

103
00:03:59,480 --> 00:04:03,309
You guys want to take a quick minute
and try and figure out each of these

104
00:04:03,309 --> 00:04:04,600
and then tell me what they are?

105
00:04:04,600 --> 00:04:06,500

106
00:04:06,500 --> 00:04:10,240
>> I also have candy in my bag, so anyone
who answers gets candy, by the way.

107
00:04:10,240 --> 00:04:13,560

108
00:04:13,560 --> 00:04:14,480
And I have lots of it.

109
00:04:14,480 --> 00:04:15,760

110
00:04:15,760 --> 00:04:16,870
Let me grab this.

111
00:04:16,870 --> 00:04:18,480
I'm going to give this to Gabe.

112
00:04:18,480 --> 00:04:21,829
So you can hand out candy to
whoever's nice and cooperative.

113
00:04:21,829 --> 00:04:23,490
>> OK, I saw a hand there in the back.

114
00:04:23,490 --> 00:04:26,418

115
00:04:26,418 --> 00:04:28,370
>> STUDENT: Yeah, the first one is 42.

116
00:04:28,370 --> 00:04:30,280
>> ALLISON: Yes, first one is 42, correct.

117
00:04:30,280 --> 00:04:31,163

118
00:04:31,163 --> 00:04:32,038
STUDENT: [INAUDIBLE].

119
00:04:32,038 --> 00:04:34,810
[LAUGHTER]

120
00:04:34,810 --> 00:04:37,030
ALLISON: Second one,
there back in yellow?

121
00:04:37,030 --> 00:04:38,910
STUDENT: 110010.

122
00:04:38,910 --> 00:04:43,410
ALLISON: Correct, and this
last one, down here on bottom?

123
00:04:43,410 --> 00:04:44,570
Also, yeah, you know want?

124
00:04:44,570 --> 00:04:45,550
Just toss out candy.

125
00:04:45,550 --> 00:04:46,483
How about candy for everyone?

126
00:04:46,483 --> 00:04:47,510
>> STUDENT: [INAUDIBLE] when we're done.

127
00:04:47,510 --> 00:04:48,051
>> ALLISON: Shh.

128
00:04:48,051 --> 00:04:49,380

129
00:04:49,380 --> 00:04:50,910
And then the last one.

130
00:04:50,910 --> 00:04:52,000
Who wants to answer?

131
00:04:52,000 --> 00:04:52,744
Right there.

132
00:04:52,744 --> 00:04:54,480
>> STUDENT: 11100.

133
00:04:54,480 --> 00:04:56,820
>> ALLISON: 11100, look at that.

134
00:04:56,820 --> 00:04:58,790
Congratulations, great job, everyone.

135
00:04:58,790 --> 00:05:03,370
OK, everyone kind of understand
the process for doing this?

136
00:05:03,370 --> 00:05:08,700
You have, going from binary to decimal
the way I tend to do it, is writing out

137
00:05:08,700 --> 00:05:09,920
the powers of 2.

138
00:05:09,920 --> 00:05:18,350
So I say, OK, 0 times 2 to 0, so
that's 0, 1 times 2 to the first,

139
00:05:18,350 --> 00:05:21,400
is 2 going onwards that way.

140
00:05:21,400 --> 00:05:25,790
Does anyone want me to explicitly
go through an example of binary?

141
00:05:25,790 --> 00:05:26,840

142
00:05:26,840 --> 00:05:28,140
OK, cool.

143
00:05:28,140 --> 00:05:30,390
>> Decimal to binary is very similar.

144
00:05:30,390 --> 00:05:31,550

145
00:05:31,550 --> 00:05:33,630
I tend to write out the powers of 2.

146
00:05:33,630 --> 00:05:38,660
Start with the one that is the greatest,
but doesn't go past the decimal

147
00:05:38,660 --> 00:05:39,710
that you're looking for.

148
00:05:39,710 --> 00:05:42,870
And then kind of work your way
backwards adding up things as necessary.

149
00:05:42,870 --> 00:05:45,200
>> And then with addition, it's
just like normal addition.

150
00:05:45,200 --> 00:05:51,110
If you ever have the case where you're
adding two 1s, it obviously becomes 2.

151
00:05:51,110 --> 00:05:56,875
2 in binary is now 1 0 so you need
to carry your 1 into the next column.

152
00:05:56,875 --> 00:05:57,375
Cool.

153
00:05:57,375 --> 00:05:59,220

154
00:05:59,220 --> 00:06:03,240
>> Hexadecimal, this might be something
that is slightly less familiar.

155
00:06:03,240 --> 00:06:06,600
So as Rob was just telling me
beforehand, his trick for this

156
00:06:06,600 --> 00:06:10,210
is to just split it up
into four byte chunks, OK?

157
00:06:10,210 --> 00:06:11,050
Bits, sorry.

158
00:06:11,050 --> 00:06:11,720
See?

159
00:06:11,720 --> 00:06:12,220
Thanks Rob.

160
00:06:12,220 --> 00:06:15,874
This is why you're here. [NOISE]
OK, so we just break it up

161
00:06:15,874 --> 00:06:16,790
into four bits chunks.

162
00:06:16,790 --> 00:06:21,570
So with binaries to hexadecimal,
we look at the first 4,

163
00:06:21,570 --> 00:06:25,573
which is if we have four 1s in a
row, what number does that symbolize?

164
00:06:25,573 --> 00:06:26,540
>> STUDENT: F.

165
00:06:26,540 --> 00:06:32,751
>> ALLISON: So in this case,
what is 11111111 or-- yes?

166
00:06:32,751 --> 00:06:33,250
STUDENT: FF.

167
00:06:33,250 --> 00:06:34,600
ALLISON: Perfect, FF.

168
00:06:34,600 --> 00:06:36,900
So great, candy for you.

169
00:06:36,900 --> 00:06:41,100
Now, for how hexadecimal to binary, we
just think about it kind of in reverse.

170
00:06:41,100 --> 00:06:46,420
For each number or letter that
we have in our hexadecimal,

171
00:06:46,420 --> 00:06:53,930
just convert it to its four bit
[LAUGHS] to its four bit conversion.

172
00:06:53,930 --> 00:06:58,696
So 5, in this case, what is 5 if
we're representing it with four bits?

173
00:06:58,696 --> 00:06:59,608
>> STUDENT: 010?

174
00:06:59,608 --> 00:07:00,520
Mm-hm.

175
00:07:00,520 --> 00:07:03,605
And then A, which is
actually 10, would be?

176
00:07:03,605 --> 00:07:06,230

177
00:07:06,230 --> 00:07:08,040
1010.

178
00:07:08,040 --> 00:07:09,670
So we have that, here.

179
00:07:09,670 --> 00:07:13,990
So converting between hexadecimal
and binary actually isn't that bad.

180
00:07:13,990 --> 00:07:16,565
If you look at it in four bit
chunks, going to be golden.

181
00:07:16,565 --> 00:07:18,330

182
00:07:18,330 --> 00:07:19,300
Everyone-- yes?

183
00:07:19,300 --> 00:07:21,903
>> ROB: This is silly,
but I always remember

184
00:07:21,903 --> 00:07:23,500
A, since A's supposed to be 10.

185
00:07:23,500 --> 00:07:26,230
And binary's just 10 10, so--

186
00:07:26,230 --> 00:07:27,310
>> ALLISON: Ah, there we go.

187
00:07:27,310 --> 00:07:28,615
>> ROB: Hey.

188
00:07:28,615 --> 00:07:30,020
>> ALLISON: Hey, candy for Rob.

189
00:07:30,020 --> 00:07:31,707

190
00:07:31,707 --> 00:07:33,290
There is non-chocolate stuff in there.

191
00:07:33,290 --> 00:07:34,180
So you can have some.

192
00:07:34,180 --> 00:07:35,790

193
00:07:35,790 --> 00:07:36,760
So ASCII math.

194
00:07:36,760 --> 00:07:38,206

195
00:07:38,206 --> 00:07:38,705
Behave.

196
00:07:38,705 --> 00:07:40,630

197
00:07:40,630 --> 00:07:44,720
So ASCII math, as you guys
probably well remember

198
00:07:44,720 --> 00:07:48,480
p set 2 with Visioneer and
Caesar, you did a lot of this.

199
00:07:48,480 --> 00:07:49,610

200
00:07:49,610 --> 00:07:51,980
Remember, the characters are
fundamentally just numbers.

201
00:07:51,980 --> 00:07:54,780
So we can do math with them,
just like we do math with ints.

202
00:07:54,780 --> 00:07:58,090
>> So we have just a little
simple thing here.

203
00:07:58,090 --> 00:08:00,940
We have some in A that's
initialized to 65.

204
00:08:00,940 --> 00:08:07,440
And B equal to the ASCII value of A
plus 1, char C equal to D minus 1,

205
00:08:07,440 --> 00:08:09,060
and char D equal to 68.

206
00:08:09,060 --> 00:08:13,130
So then we are going to print
all of them, as we see here.

207
00:08:13,130 --> 00:08:15,650
And can anyone tell me
what this will print out?

208
00:08:15,650 --> 00:08:17,335

209
00:08:17,335 --> 00:08:18,210
STUDENT: [INAUDIBLE].

210
00:08:18,210 --> 00:08:20,540
ALLISON: Exactly, so
one thing to notice is

211
00:08:20,540 --> 00:08:22,900
that we are printing out
characters each time, here.

212
00:08:22,900 --> 00:08:28,290
We are designating even though A and B
are ints when we declared them above.

213
00:08:28,290 --> 00:08:32,870
We are printing them as characters by
the percent C and our printf statement,

214
00:08:32,870 --> 00:08:34,610
so they will all print as characters.

215
00:08:34,610 --> 00:08:40,730
And of course, the ASCII value 65 will
print as A. The ASCII value of A plus 1

216
00:08:40,730 --> 00:08:43,669
would be 66, which would
proud to B. So in fact, we

217
00:08:43,669 --> 00:08:49,107
get A B C D. Everyone good there?

218
00:08:49,107 --> 00:08:49,690
Any questions?

219
00:08:49,690 --> 00:08:50,721

220
00:08:50,721 --> 00:08:51,220
Awesome.

221
00:08:51,220 --> 00:08:52,500

222
00:08:52,500 --> 00:08:53,455
>> OK, scope.

223
00:08:53,455 --> 00:08:55,090

224
00:08:55,090 --> 00:08:59,950
So scope is obviously a very
important thing to understand, here.

225
00:08:59,950 --> 00:09:03,250
A lot of you, if you
have compiling errors,

226
00:09:03,250 --> 00:09:06,085
and it says you don't have
access to some variable,

227
00:09:06,085 --> 00:09:08,540
it's probably because you
defined it within a loop

228
00:09:08,540 --> 00:09:12,210
and then tried to access it
out of it, or visa versa.

229
00:09:12,210 --> 00:09:16,410
>> So scope at its core,
it just determines where

230
00:09:16,410 --> 00:09:20,800
we say a variable exists, where we
can change it, where we can access it.

231
00:09:20,800 --> 00:09:24,550
It's just kind of saying these are
the only places where you have access

232
00:09:24,550 --> 00:09:26,060
to this variable.

233
00:09:26,060 --> 00:09:30,080
>> So the two scopes that we talk about
during class are global and local.

234
00:09:30,080 --> 00:09:35,080
So global variables we talk about
when you are defining them above main.

235
00:09:35,080 --> 00:09:38,390
It means that your entire
program has access to it,

236
00:09:38,390 --> 00:09:42,090
and it exists for as long
as the program runs, OK?

237
00:09:42,090 --> 00:09:45,100
Local means that it's
more confined to a region.

238
00:09:45,100 --> 00:09:50,520
So whenever you have specific functions
like swap, we always talk about.

239
00:09:50,520 --> 00:09:54,380
We always talk about swap with A and
B. A and B exist within that function.

240
00:09:54,380 --> 00:09:55,690
They don't exist anywhere else.

241
00:09:55,690 --> 00:09:56,860

242
00:09:56,860 --> 00:10:00,610
>> As well, when you have if
statements or for loops.

243
00:10:00,610 --> 00:10:04,670
Whenever we have, for example, in
a for loop we have int I equals 0.

244
00:10:04,670 --> 00:10:06,630
We have some condition and we update it.

245
00:10:06,630 --> 00:10:10,270
I only exists within the
braces of that for loop.

246
00:10:10,270 --> 00:10:13,270
If you try to access it elsewhere,
your compiler would yell at you.

247
00:10:13,270 --> 00:10:14,560
It'd be like, what are you trying to do?

248
00:10:14,560 --> 00:10:15,400
This doesn't exist.

249
00:10:15,400 --> 00:10:16,644

250
00:10:16,644 --> 00:10:18,435
So that's the two
different types of scope.

251
00:10:18,435 --> 00:10:19,486

252
00:10:19,486 --> 00:10:20,860
Does that make sense to everyone?

253
00:10:20,860 --> 00:10:23,870

254
00:10:23,870 --> 00:10:27,890
>> So for example here, this
is just some simple program.

255
00:10:27,890 --> 00:10:29,120

256
00:10:29,120 --> 00:10:32,890
What do you guys think is
going to happen at each point

257
00:10:32,890 --> 00:10:34,210
that we try to print?

258
00:10:34,210 --> 00:10:40,150
So this one here,
what's going to happen?

259
00:10:40,150 --> 00:10:43,047

260
00:10:43,047 --> 00:10:44,255
STUDENT: It will print three.

261
00:10:44,255 --> 00:10:44,880
ALLISON: Right.

262
00:10:44,880 --> 00:10:45,930
It'll print three.

263
00:10:45,930 --> 00:10:47,272
What about here?

264
00:10:47,272 --> 00:10:48,230
STUDENT: It won't work.

265
00:10:48,230 --> 00:10:48,910
ALLISON: It won't work.

266
00:10:48,910 --> 00:10:50,290
You're out of scope, right?

267
00:10:50,290 --> 00:10:55,160
Local variable doesn't exist
outside of these braces, all right?

268
00:10:55,160 --> 00:10:56,462
And then what about here?

269
00:10:56,462 --> 00:10:57,850
>> STUDENT: [INAUDIBLE].

270
00:10:57,850 --> 00:10:59,210
>> ALLISON: What?

271
00:10:59,210 --> 00:10:59,900
Rob, go.

272
00:10:59,900 --> 00:11:00,854
>> ROB: I just said.

273
00:11:00,854 --> 00:11:04,200
Global variables should be
global underscore variable.

274
00:11:04,200 --> 00:11:05,660
>> ALLISON: Ah, yes, sorry.

275
00:11:05,660 --> 00:11:06,200
Thanks, Rob.

276
00:11:06,200 --> 00:11:07,480

277
00:11:07,480 --> 00:11:10,170
Rob's like our resident compiler.

278
00:11:10,170 --> 00:11:12,684
He'll just yell at us when we
need it. [LAUGHS] Yes, that

279
00:11:12,684 --> 00:11:14,225
should be global underscore variable.

280
00:11:14,225 --> 00:11:15,760

281
00:11:15,760 --> 00:11:18,430
So assuming that that
was global underscore

282
00:11:18,430 --> 00:11:20,260
variable, what's going to happen here?

283
00:11:20,260 --> 00:11:21,260
STUDENT: That will work.

284
00:11:21,260 --> 00:11:22,093
ALLISON: It'll work.

285
00:11:22,093 --> 00:11:24,655
So it'll print, so just
a very simple example.

286
00:11:24,655 --> 00:11:27,650

287
00:11:27,650 --> 00:11:29,870
OK, prototypes.

288
00:11:29,870 --> 00:11:33,680
So obviously, we really
emphasize for you guys

289
00:11:33,680 --> 00:11:36,460
to make functions if it
make sense in your programs.

290
00:11:36,460 --> 00:11:38,460
But of course, when you
make your own functions,

291
00:11:38,460 --> 00:11:40,930
typically you'll define them after main.

292
00:11:40,930 --> 00:11:42,430
And you'll try to call them in main.

293
00:11:42,430 --> 00:11:46,030
And if you don't use a prototype,
your compiler will yell at you.

294
00:11:46,030 --> 00:11:49,590
>> Prototype is basically
just telling your compiler

295
00:11:49,590 --> 00:11:52,400
that I have this function below main.

296
00:11:52,400 --> 00:11:54,970
I'm going to call it before I define it.

297
00:11:54,970 --> 00:11:56,360
Just hold on.

298
00:11:56,360 --> 00:12:00,660
I promise that it's defined, and you
will have everything that you need.

299
00:12:00,660 --> 00:12:05,900
>> So the way we do it is just your return
type, your function name, your input

300
00:12:05,900 --> 00:12:06,400
list.

301
00:12:06,400 --> 00:12:09,760
It's basically the first line
of your function declaration.

302
00:12:09,760 --> 00:12:11,510
It's really all it is.

303
00:12:11,510 --> 00:12:14,440
But this is just a
general kind of format.

304
00:12:14,440 --> 00:12:17,220
>> So in our example here,
which you guys should

305
00:12:17,220 --> 00:12:19,700
have seen in section
at some point, we have

306
00:12:19,700 --> 00:12:23,220
some int cube that
takes some int of input.

307
00:12:23,220 --> 00:12:25,870
And we have our main
function, which calls cube.

308
00:12:25,870 --> 00:12:28,670
And cube is defined after the fact.

309
00:12:28,670 --> 00:12:34,450
>> So if we didn't have int cube input
at the top, when we called cube

310
00:12:34,450 --> 00:12:36,620
within main, our compiler
would get mad at us.

311
00:12:36,620 --> 00:12:38,890
It'd be like, what
are you talking about?

312
00:12:38,890 --> 00:12:40,360
Cube does not exist.

313
00:12:40,360 --> 00:12:41,910
I don't know what you're asking for.

314
00:12:41,910 --> 00:12:43,490
And I'm just going stop.

315
00:12:43,490 --> 00:12:47,330
>> But because we did our prototype
at the top, we've said,

316
00:12:47,330 --> 00:12:49,800
you know, when you see
cube, don't worry about it.

317
00:12:49,800 --> 00:12:51,990
I promise it's defined later.

318
00:12:51,990 --> 00:12:53,750
And it'll let you do what you want.

319
00:12:53,750 --> 00:12:57,750
So if you ever have a function
that is declared after you call it

320
00:12:57,750 --> 00:13:00,570
for the first time, you need to
have it prototyped at the top.

321
00:13:00,570 --> 00:13:01,640

322
00:13:01,640 --> 00:13:02,720
>> Yes?

323
00:13:02,720 --> 00:13:04,412
>> ROB: It's squared, not cubing.

324
00:13:04,412 --> 00:13:05,855
>> ALLISON: Oh my God.

325
00:13:05,855 --> 00:13:09,435
I didn't have-- Gabe, I thought
you were our proofreader.

326
00:13:09,435 --> 00:13:10,740

327
00:13:10,740 --> 00:13:12,760
OK guys, bear with me, here.

328
00:13:12,760 --> 00:13:14,440
I hope everyone's getting the idea.

329
00:13:14,440 --> 00:13:15,560

330
00:13:15,560 --> 00:13:20,380
OK, so this should have
been squared, not cubed.

331
00:13:20,380 --> 00:13:22,700
But the idea remains the same.

332
00:13:22,700 --> 00:13:23,702

333
00:13:23,702 --> 00:13:26,660
Any function that we're calling after
the fact should have a prototype.

334
00:13:26,660 --> 00:13:27,730

335
00:13:27,730 --> 00:13:28,970
Everyone good with that?

336
00:13:28,970 --> 00:13:30,730

337
00:13:30,730 --> 00:13:32,310
Any other typos?

338
00:13:32,310 --> 00:13:32,810
OK.

339
00:13:32,810 --> 00:13:34,730

340
00:13:34,730 --> 00:13:36,230
Any typos here before we start, Rob?

341
00:13:36,230 --> 00:13:37,356

342
00:13:37,356 --> 00:13:42,380
[LAUGHS] OK, so structs.

343
00:13:42,380 --> 00:13:45,040
Basically, structs allow you
to create your own data type.

344
00:13:45,040 --> 00:13:49,264
So much like an int or a char or
a float, it's just another type.

345
00:13:49,264 --> 00:13:51,680
I like to think of it as, like,
create your own data type.

346
00:13:51,680 --> 00:13:53,740
So it allows you to do that.

347
00:13:53,740 --> 00:13:56,160
And it holds different types of data.

348
00:13:56,160 --> 00:14:01,030
>> So if you remember, in an array, we
can only hold things of similar type.

349
00:14:01,030 --> 00:14:04,660
Structs allow us to hold multiple
things of different types.

350
00:14:04,660 --> 00:14:08,944
So in this case here, we
have a struct called Student,

351
00:14:08,944 --> 00:14:10,650
named here at the bottom.

352
00:14:10,650 --> 00:14:13,540
And we have some int id
and some string name.

353
00:14:13,540 --> 00:14:14,620

354
00:14:14,620 --> 00:14:17,300
So this is just another data type.

355
00:14:17,300 --> 00:14:18,950
We now have a data type called Student.

356
00:14:18,950 --> 00:14:20,330

357
00:14:20,330 --> 00:14:24,750
>> So because we can think of
it as just another data type,

358
00:14:24,750 --> 00:14:27,760
we can declare variables
as we would any other.

359
00:14:27,760 --> 00:14:32,680
So instead of just having, like, an
int student, we just have a student,

360
00:14:32,680 --> 00:14:33,390
student 1.

361
00:14:33,390 --> 00:14:33,560
Oh, look.

362
00:14:33,560 --> 00:14:34,059
It's Rob.

363
00:14:34,059 --> 00:14:35,750

364
00:14:35,750 --> 00:14:38,880
So here we're declaring
a struct, or a variable

365
00:14:38,880 --> 00:14:40,940
called student 1 of type student.

366
00:14:40,940 --> 00:14:45,370
So it's going to have id
and name associated with it.

367
00:14:45,370 --> 00:14:48,430
>> And the way we access these
elements within our struct

368
00:14:48,430 --> 00:14:50,100
is with the dot operator, here.

369
00:14:50,100 --> 00:14:51,910

370
00:14:51,910 --> 00:14:54,660
So in this case, we
declared some student 1.

371
00:14:54,660 --> 00:14:57,080
We assigned the ID to be 1.

372
00:14:57,080 --> 00:14:58,840
And we assigned the name to be Rob.

373
00:14:58,840 --> 00:15:03,010

374
00:15:03,010 --> 00:15:04,960
OK, everyone good with that?

375
00:15:04,960 --> 00:15:06,787
Use it just like-- yes?

376
00:15:06,787 --> 00:15:09,530
>> STUDENT: Yeah, typedef-- when
do we need to use typedef?

377
00:15:09,530 --> 00:15:13,190
>> ALLISON: So typedef just
says that-- Rob, you

378
00:15:13,190 --> 00:15:16,990
can correct me on this if I'm wrong--
but typedef is just actually declaring

379
00:15:16,990 --> 00:15:19,330
it as a type that you can use, right?

380
00:15:19,330 --> 00:15:22,550
>> ROB: Yeah, it's basically,
so it's just creating

381
00:15:22,550 --> 00:15:24,215
an alias, or a nickname for a type.

382
00:15:24,215 --> 00:15:25,590
So you can type that [INAUDIBLE].

383
00:15:25,590 --> 00:15:27,140

384
00:15:27,140 --> 00:15:30,350
So [INAUDIBLE] exists,
and now we just have

385
00:15:30,350 --> 00:15:32,090
[INAUDIBLE] means
exactly the same thing.

386
00:15:32,090 --> 00:15:37,210
And so here, we're typed, I think,
some struct type 2 [INAUDIBLE].

387
00:15:37,210 --> 00:15:40,680
So it's just a nickname
for a given type.

388
00:15:40,680 --> 00:15:44,344
>> STUDENT: String [INAUDIBLE] library
was typed up like char star.

389
00:15:44,344 --> 00:15:51,380

390
00:15:51,380 --> 00:15:54,390
>> ALLISON: For our purposes here,
if you're declaring a struct,

391
00:15:54,390 --> 00:15:55,600
just do typedef struct.

392
00:15:55,600 --> 00:15:57,680

393
00:15:57,680 --> 00:16:04,490
OK, so beforehand, this is
just a normal variable here.

394
00:16:04,490 --> 00:16:06,390
We access it with a dot.

395
00:16:06,390 --> 00:16:08,580
if we have a pointer to
a struct, we can actually

396
00:16:08,580 --> 00:16:10,700
use an arrow, which is pretty cool.

397
00:16:10,700 --> 00:16:17,130
>> So in this case, we have a pointer to
a student 1 that is of type student.

398
00:16:17,130 --> 00:16:19,020
Remember, with your
pointer construction,

399
00:16:19,020 --> 00:16:23,710
you want whatever type your pointer
is pointing to to be at the beginning.

400
00:16:23,710 --> 00:16:25,960
So we have some student 1, here.

401
00:16:25,960 --> 00:16:27,370

402
00:16:27,370 --> 00:16:31,050
And since this student
1 is now a pointed,

403
00:16:31,050 --> 00:16:36,520
we can actually go student 1 arrow name
instead of dot, because it's a pointer,

404
00:16:36,520 --> 00:16:37,640
and assign Rob.

405
00:16:37,640 --> 00:16:40,720
And now if we want to
change Rob to Davin,

406
00:16:40,720 --> 00:16:43,570
this is just showing you
a different way to do it.

407
00:16:43,570 --> 00:16:48,850
>> So instead of using the arrow, you
can also-- I will finish this and then

408
00:16:48,850 --> 00:16:52,860
take that question-- you could
also do reference student 1.

409
00:16:52,860 --> 00:16:56,170
That's saying like go to
whatever is at student 1, which

410
00:16:56,170 --> 00:16:58,840
would be our student struct.

411
00:16:58,840 --> 00:17:03,910
Access it with a dot and the element
that you want, and then reassign it.

412
00:17:03,910 --> 00:17:05,326
There was a question.

413
00:17:05,326 --> 00:17:08,034
STUDENT: Yes, so how come you have
to use [INAUDIBLE] when you're

414
00:17:08,034 --> 00:17:10,367
doing student star without
[INAUDIBLE] student?

415
00:17:10,367 --> 00:17:12,200
ALLISON: Because this
is creating a pointer.

416
00:17:12,200 --> 00:17:13,616
ROB: We're going to talk about it.

417
00:17:13,616 --> 00:17:16,119
ALLISON: We're going to talk
about that later in the review.

418
00:17:16,119 --> 00:17:17,660
So just hold onto that thought.

419
00:17:17,660 --> 00:17:20,560
If it still bothers you at the
end, come talk to one of us.

420
00:17:20,560 --> 00:17:23,380
>> So these do exactly the same thing.

421
00:17:23,380 --> 00:17:25,579
We're just showing you two
different ways to do it.

422
00:17:25,579 --> 00:17:29,470
Student 1 is now a pointer, so
you can access the Name element

423
00:17:29,470 --> 00:17:30,960
within the struct with an arrow.

424
00:17:30,960 --> 00:17:36,440
Or you can dereference your pointer, and
then access it as you normally would.

425
00:17:36,440 --> 00:17:38,430
Does that makes sense to every one?

426
00:17:38,430 --> 00:17:39,480

427
00:17:39,480 --> 00:17:43,890
If the whole pointer things are a little
confusing, Gabe will talk about that,

428
00:17:43,890 --> 00:17:45,740
and then maybe this
will make more sense.

429
00:17:45,740 --> 00:17:46,240
Yes?

430
00:17:46,240 --> 00:17:48,387
>> STUDENT: Yes, so how is
this different from the?

431
00:17:48,387 --> 00:17:49,470
ALLISON: The previous one?

432
00:17:49,470 --> 00:17:52,330
So the student 1 in this
case is not a pointer.

433
00:17:52,330 --> 00:17:54,380
It's just your actual struct.

434
00:17:54,380 --> 00:17:55,400
>> STUDENT: OK.

435
00:17:55,400 --> 00:17:57,645
>> ALLISON: Whereas this one
is a pointer to a struct.

436
00:17:57,645 --> 00:17:58,910

437
00:17:58,910 --> 00:18:02,060
>> STUDENT: OK, but does it kind of
end up working the same [INAUDIBLE].

438
00:18:02,060 --> 00:18:03,310
>> ALLISON: It effectively works the same.

439
00:18:03,310 --> 00:18:04,560
Your syntax is just different.

440
00:18:04,560 --> 00:18:05,185
STUDENT: OK.

441
00:18:05,185 --> 00:18:07,600
>> ALLISON: Yeah, they are
effectively the same.

442
00:18:07,600 --> 00:18:11,321
It's just depending on context,
you may want one over the other.

443
00:18:11,321 --> 00:18:11,820
Yes?

444
00:18:11,820 --> 00:18:13,956
>> STUDENT: When you do
references to the 1--

445
00:18:13,956 --> 00:18:14,580
ALLISON: Mm-hm?

446
00:18:14,580 --> 00:18:16,880
STUDENT: Why do you
have the parentheses?

447
00:18:16,880 --> 00:18:19,575
ALLISON: Because student
1 is the pointer.

448
00:18:19,575 --> 00:18:22,200
So you need to make sure you're
just dereferencing the pointer.

449
00:18:22,200 --> 00:18:23,380
>> STUDENT: OK.

450
00:18:23,380 --> 00:18:26,700
>> ALLISON: So in this case here,
the parentheses around it

451
00:18:26,700 --> 00:18:29,875
means you're dereferencing student 1.

452
00:18:29,875 --> 00:18:35,390
So you're going to where student
1 points, which is your struct.

453
00:18:35,390 --> 00:18:38,010
So now you can think
of it as that struct,

454
00:18:38,010 --> 00:18:39,785
so we can use our normal dot operation.

455
00:18:39,785 --> 00:18:42,752

456
00:18:42,752 --> 00:18:43,585
Any other questions?

457
00:18:43,585 --> 00:18:45,840

458
00:18:45,840 --> 00:18:48,120
Cool, awesome.

459
00:18:48,120 --> 00:18:51,359
>> So last thing, I think
is my last slide, woo!

460
00:18:51,359 --> 00:18:52,775
OK, so floating point imprecision.

461
00:18:52,775 --> 00:18:54,090

462
00:18:54,090 --> 00:18:56,820
We talked briefly about
this during lecture.

463
00:18:56,820 --> 00:19:00,030
Basically, we have
infinitely many real numbers.

464
00:19:00,030 --> 00:19:02,237
And if any of you guys
love math, there's

465
00:19:02,237 --> 00:19:03,570
all sorts of cool stuff with us.

466
00:19:03,570 --> 00:19:05,010

467
00:19:05,010 --> 00:19:07,190
>> But there are infinitely
many real numbers.

468
00:19:07,190 --> 00:19:09,850
But they're only finite
many bits that we have.

469
00:19:09,850 --> 00:19:13,240
So you're always going to
have imprecision, is all.

470
00:19:13,240 --> 00:19:16,269
And that's that's just kind of
like something you should know.

471
00:19:16,269 --> 00:19:19,060
That like we may ask you why does
floating point imprecision exist?

472
00:19:19,060 --> 00:19:20,004

473
00:19:20,004 --> 00:19:21,420
So just something you should know.

474
00:19:21,420 --> 00:19:23,770
And with that, I'm turning
it over to Pointers.

475
00:19:23,770 --> 00:19:27,720

476
00:19:27,720 --> 00:19:28,520
>> BINKY: Hello, guys.

477
00:19:28,520 --> 00:19:29,616
My name's Binky.

478
00:19:29,616 --> 00:19:30,990
I'm going to talk about pointers.

479
00:19:30,990 --> 00:19:33,247

480
00:19:33,247 --> 00:19:35,830
Yeah, so pointers is actually
my favorite part in this course.

481
00:19:35,830 --> 00:19:39,740
So just to make clear what Allison
was talking about here, so the reason

482
00:19:39,740 --> 00:19:43,810
why-- the only difference here,
the big difference was the way

483
00:19:43,810 --> 00:19:44,760
we declare things.

484
00:19:44,760 --> 00:19:47,560
So student star means this
is a pointer to a student.

485
00:19:47,560 --> 00:19:52,960
Whereas the slide before, student is an
actual struct, like an actual student,

486
00:19:52,960 --> 00:19:54,400
containing any of those things.

487
00:19:54,400 --> 00:19:57,050
>> And the reason why we
want to-- yes, Davin?

488
00:19:57,050 --> 00:19:58,630
>> DAVIN: What does the arrow mean?

489
00:19:58,630 --> 00:20:04,240
>> BINKY: The arrow means
exactly the same as this.

490
00:20:04,240 --> 00:20:06,150
So you don't really need the arrow.

491
00:20:06,150 --> 00:20:11,060
Like, if you're only program
in C, you can just use this.

492
00:20:11,060 --> 00:20:12,850
Sorry, I don't what that is.

493
00:20:12,850 --> 00:20:14,920
You can just use this syntax.

494
00:20:14,920 --> 00:20:17,430
>> But some people, when
they were designing C,

495
00:20:17,430 --> 00:20:19,870
they figured that people
used that syntax so much,

496
00:20:19,870 --> 00:20:23,970
that they will like just come up
with a syntax structure for it.

497
00:20:23,970 --> 00:20:26,820
And this took place in
the form of this arrow.

498
00:20:26,820 --> 00:20:29,210
And it's really nice, because
it symbolizes something

499
00:20:29,210 --> 00:20:33,670
like we're actually following
this arrow, this pointer,

500
00:20:33,670 --> 00:20:35,300
toward some space in memory.

501
00:20:35,300 --> 00:20:40,410
And when we get there, we want to
look to the name of that student,

502
00:20:40,410 --> 00:20:42,150
if that makes sense.

503
00:20:42,150 --> 00:20:43,000
OK?

504
00:20:43,000 --> 00:20:44,290
>> So this is exactly the same.

505
00:20:44,290 --> 00:20:46,310
This is exactly the same thing as this.

506
00:20:46,310 --> 00:20:48,130
They get compiled exactly the same, OK?

507
00:20:48,130 --> 00:20:50,100

508
00:20:50,100 --> 00:20:55,580
And the reason here why we malloc
something, is because in this case,

509
00:20:55,580 --> 00:20:59,120
our variable is actually
just a pointer variable.

510
00:20:59,120 --> 00:21:02,900
So we only have some space in
memory that's holding a pointer.

511
00:21:02,900 --> 00:21:06,570
We don't really have any space
that holds the actual struct.

512
00:21:06,570 --> 00:21:08,660
>> So this has to be done in two steps.

513
00:21:08,660 --> 00:21:11,545
We have to create the
memory to put the struct in.

514
00:21:11,545 --> 00:21:14,445
And we have to create the
memory to put the pointer in.

515
00:21:14,445 --> 00:21:16,570
So they're basically two
different variables, here.

516
00:21:16,570 --> 00:21:19,730
One of them is of type student,
except it doesn't really have a name.

517
00:21:19,730 --> 00:21:21,900
And the other one is
of type student star.

518
00:21:21,900 --> 00:21:24,900
And then student 1 points
there, if that make sense.

519
00:21:24,900 --> 00:21:25,871

520
00:21:25,871 --> 00:21:26,370
OK?

521
00:21:26,370 --> 00:21:28,160

522
00:21:28,160 --> 00:21:31,860
>> So the reason why we use
pointers is because everything

523
00:21:31,860 --> 00:21:35,510
in a computer, every variable
in a computer has two things.

524
00:21:35,510 --> 00:21:36,580
It has its value.

525
00:21:36,580 --> 00:21:38,420
And it has its address.

526
00:21:38,420 --> 00:21:41,390
And a good way to
conceptualize this is there's

527
00:21:41,390 --> 00:21:44,230
many problems when you
try to use functions.

528
00:21:44,230 --> 00:21:47,200
And we're going to try to
look into one of those.

529
00:21:47,200 --> 00:21:50,370
Namely, it's going to
think of memory as boxes.

530
00:21:50,370 --> 00:21:52,810
>> You always thought of variables
when you say na equals 5.

531
00:21:52,810 --> 00:21:54,430
You think of putting 5 into a box.

532
00:21:54,430 --> 00:21:55,520

533
00:21:55,520 --> 00:22:00,030
So what if you want to pass
that int into a function?

534
00:22:00,030 --> 00:22:03,230
You just pass-- I don't
know-- x into a function.

535
00:22:03,230 --> 00:22:06,090
But what happens is
normally as humans, you

536
00:22:06,090 --> 00:22:09,050
would think something like I'm
passing the box to a person.

537
00:22:09,050 --> 00:22:12,070
And it doesn't really
happen in computers.

538
00:22:12,070 --> 00:22:17,770
What happens is you copy the value
of the box to the person's box.

539
00:22:17,770 --> 00:22:22,440
>> So what I'm trying to say is that if
you have a function-- sorry-- here,

540
00:22:22,440 --> 00:22:27,700
if we have a function like to five up
there, if you try to pass a variable,

541
00:22:27,700 --> 00:22:29,450
it's just going to copy.

542
00:22:29,450 --> 00:22:35,771
If a initialize nx equals 3, it's going
to copy this value up to the variable a

543
00:22:35,771 --> 00:22:36,270
up there.

544
00:22:36,270 --> 00:22:37,005

545
00:22:37,005 --> 00:22:39,630
OK, and this is kind of the reason
why we want to use pointers.

546
00:22:39,630 --> 00:22:42,550
Because instead of
giving just the value,

547
00:22:42,550 --> 00:22:44,850
instead of just passing just
the value to a function,

548
00:22:44,850 --> 00:22:46,530
we want to pass by reference.

549
00:22:46,530 --> 00:22:50,630
What we call pass by reference is kind
of giving the box to the function,

550
00:22:50,630 --> 00:22:53,890
so that the function can also
change the values within that box.

551
00:22:53,890 --> 00:22:57,280
>> OK, so just some basic pointer
stuff is to create pointers,

552
00:22:57,280 --> 00:23:00,300
you just declare it a type, and
you put a star right after it.

553
00:23:00,300 --> 00:23:02,307
And the type is just
what you're pointing at.

554
00:23:02,307 --> 00:23:04,390
So if it's an int star,
you're pointing at an int.

555
00:23:04,390 --> 00:23:05,940
If it's a char star,
you're pointing at a chart.

556
00:23:05,940 --> 00:23:07,790
And if it's a student star,
you're pointing at a student.

557
00:23:07,790 --> 00:23:08,770
OK?

558
00:23:08,770 --> 00:23:10,510
>> And they're all 4 bytes long.

559
00:23:10,510 --> 00:23:13,010
Because this variable
it doesn't actually

560
00:23:13,010 --> 00:23:15,380
need to hold a char,
an int, or a student.

561
00:23:15,380 --> 00:23:16,890
It only needs to hold an address.

562
00:23:16,890 --> 00:23:21,390
That's why they're all 4 bytes
long in a normal 32-bit machine.

563
00:23:21,390 --> 00:23:21,890
OK?

564
00:23:21,890 --> 00:23:25,600
So here, x is a variable that points
to an int. y points to a char. z points

565
00:23:25,600 --> 00:23:26,580
to a float.

566
00:23:26,580 --> 00:23:27,480
Any questions here?

567
00:23:27,480 --> 00:23:29,841

568
00:23:29,841 --> 00:23:30,340
Cool.

569
00:23:30,340 --> 00:23:32,550
And there are two
different symbols they have

570
00:23:32,550 --> 00:23:34,341
to keep in mind when
coming to the pointer.

571
00:23:34,341 --> 00:23:36,540
So referencing and
dereferencing are the big ones.

572
00:23:36,540 --> 00:23:38,100

573
00:23:38,100 --> 00:23:41,602
So the ampersand of the
variable name gives you the?

574
00:23:41,602 --> 00:23:42,310
STUDENT: Address.

575
00:23:42,310 --> 00:23:43,380
BINKY: Address.

576
00:23:43,380 --> 00:23:47,330
So if you declare int a
equals 5, then ampersand

577
00:23:47,330 --> 00:23:49,214
of a is going to give you the address.

578
00:23:49,214 --> 00:23:51,130
And you can actually try
to print that and see

579
00:23:51,130 --> 00:23:54,640
what address in memory
your variable has.

580
00:23:54,640 --> 00:23:57,380
And then dereferencing--
so that was referencing,

581
00:23:57,380 --> 00:24:00,380
getting the address-- dereferencing
is the exact opposite.

582
00:24:00,380 --> 00:24:04,120
OK, just like times is the
opposite of a division,

583
00:24:04,120 --> 00:24:06,060
star is the opposite of ampersand.

584
00:24:06,060 --> 00:24:09,710
So dereferencing means go there.

585
00:24:09,710 --> 00:24:14,280
So if you give star-- I
don't know-- 50, that's

586
00:24:14,280 --> 00:24:20,320
going to try to go to the address of
number 50 inside of your computer.

587
00:24:20,320 --> 00:24:22,840
OK, and why do we see
that they are opposites?

588
00:24:22,840 --> 00:24:27,320
Because what happens if you do
something like star ampersand a?

589
00:24:27,320 --> 00:24:28,470

590
00:24:28,470 --> 00:24:33,460
Well, ampersand a gives you the address
of a variable, the address of a.

591
00:24:33,460 --> 00:24:35,830
But star means go there.

592
00:24:35,830 --> 00:24:38,930
>> So what happens if you
go to the address of a?

593
00:24:38,930 --> 00:24:40,400
You just get to a, right?

594
00:24:40,400 --> 00:24:41,410

595
00:24:41,410 --> 00:24:43,600
So going to the address of
a is the same thing as a.

596
00:24:43,600 --> 00:24:47,580
That's why they're usually
referred to the same-- this

597
00:24:47,580 --> 00:24:50,480
and this are referred to
as opposite operators.

598
00:24:50,480 --> 00:24:50,980
OK?

599
00:24:50,980 --> 00:24:52,780

600
00:24:52,780 --> 00:24:53,790
So cool.

601
00:24:53,790 --> 00:24:57,240
>> Under the hood, for example,
if we declare int x equals 5,

602
00:24:57,240 --> 00:24:58,040
we have a variable.

603
00:24:58,040 --> 00:25:00,790
And remember that I said every
variable-- and this is a good thing

604
00:25:00,790 --> 00:25:03,820
to keep in mind-- it has two
different things associated with.

605
00:25:03,820 --> 00:25:06,460
It has an addressed and a value.

606
00:25:06,460 --> 00:25:07,140
OK?

607
00:25:07,140 --> 00:25:09,180
>> So the value in this case is 5.

608
00:25:09,180 --> 00:25:12,140
And the address is-- let's say, I'm
making something up-- it's 0x04.

609
00:25:12,140 --> 00:25:13,180

610
00:25:13,180 --> 00:25:17,200
And the only reason why we usually
represent addresses in hexadecimal

611
00:25:17,200 --> 00:25:19,770
is one, because it's like good.

612
00:25:19,770 --> 00:25:21,600
It goes well with binary.

613
00:25:21,600 --> 00:25:23,500
It's easy to convert to and from binary.

614
00:25:23,500 --> 00:25:26,890
And it doesn't get too big if
you have a very big number.

615
00:25:26,890 --> 00:25:29,990
So we like to use hexadecimal
in printing addresses.

616
00:25:29,990 --> 00:25:31,890
But I could represent
this as an integer.

617
00:25:31,890 --> 00:25:32,750
It's fine.

618
00:25:32,750 --> 00:25:35,450
>> And so it has an address
4 and a value of 5.

619
00:25:35,450 --> 00:25:38,080
And then I said int star pointer.

620
00:25:38,080 --> 00:25:40,070
So this is a different type, notice.

621
00:25:40,070 --> 00:25:43,220
Int star pointer equals
the address of x.

622
00:25:43,220 --> 00:25:46,425
So what is going to be the value of ptr?

623
00:25:46,425 --> 00:25:47,710

624
00:25:47,710 --> 00:25:51,600
It's going to be the
address of x, down here.

625
00:25:51,600 --> 00:25:54,190
OK, so the value is going to
be the same as the address.

626
00:25:54,190 --> 00:25:56,130
That's the assignment operate I'm doing.

627
00:25:56,130 --> 00:25:59,380
And then ptr is going to have
its own address, which turns out,

628
00:25:59,380 --> 00:26:02,050
in this case, the 8, OK?

629
00:26:02,050 --> 00:26:03,850

630
00:26:03,850 --> 00:26:05,900
>> And then I create a new integer copy.

631
00:26:05,900 --> 00:26:08,790
And I say int copy equals go there.

632
00:26:08,790 --> 00:26:11,140
So go to what ptr is pointing to.

633
00:26:11,140 --> 00:26:13,940
Well, what this ptr have?

634
00:26:13,940 --> 00:26:14,740
Ptr has 0x04.

635
00:26:14,740 --> 00:26:16,060

636
00:26:16,060 --> 00:26:18,400
What happens if I try to go there?

637
00:26:18,400 --> 00:26:23,650
I will find the guy who has
address x and who has address 4.

638
00:26:23,650 --> 00:26:25,970
And who has address four is x.

639
00:26:25,970 --> 00:26:26,950
Does that make sense?

640
00:26:26,950 --> 00:26:28,295

641
00:26:28,295 --> 00:26:28,795
Yes?

642
00:26:28,795 --> 00:26:32,060
>> STUDENT: In this case, is
the pointer in a stack?

643
00:26:32,060 --> 00:26:36,024
>> BINKY: In this case,
it's-- good question.

644
00:26:36,024 --> 00:26:38,690
I didn't really think about this
when making up these addresses.

645
00:26:38,690 --> 00:26:42,570
But if this is, like, all
these are local variables,

646
00:26:42,570 --> 00:26:46,372
then x is going to live in-- everything
is going to live in the stack.

647
00:26:46,372 --> 00:26:48,330
So everything is going
to be pointing to stack.

648
00:26:48,330 --> 00:26:49,360

649
00:26:49,360 --> 00:26:52,700
You only get to the heap when
you start to use malloc, right?

650
00:26:52,700 --> 00:26:59,430
>> So if you recall stack is every time
you call a function in your program,

651
00:26:59,430 --> 00:27:02,800
like, main for example, or any
other function, like printf.

652
00:27:02,800 --> 00:27:06,334
All of the local variables are
going to get put in a stack frame.

653
00:27:06,334 --> 00:27:08,500
And they're going to get
like piled up in the stack.

654
00:27:08,500 --> 00:27:09,930
That's what's called a stack.

655
00:27:09,930 --> 00:27:12,200
And all those local variables
are going to be there.

656
00:27:12,200 --> 00:27:14,940
And the heap-- and we're going
to talk more about this later--

657
00:27:14,940 --> 00:27:19,050
the heap is where all of
dynamically allocated memory lives.

658
00:27:19,050 --> 00:27:20,270
Cool?

659
00:27:20,270 --> 00:27:21,680
>> We go to this slide.

660
00:27:21,680 --> 00:27:22,800
Yes?

661
00:27:22,800 --> 00:27:25,490
>> STUDENT: Why isn't int
copy returning 0x04?

662
00:27:25,490 --> 00:27:27,870

663
00:27:27,870 --> 00:27:30,066
>> BINKY: Why isn't int
copy returning 0x04?

664
00:27:30,066 --> 00:27:32,450
>> STUDENT: Why isn't that [INAUDIBLE]?

665
00:27:32,450 --> 00:27:35,530
>> BINKY: Because what is a value of ptr?

666
00:27:35,530 --> 00:27:37,394

667
00:27:37,394 --> 00:27:38,370
>> STUDENT: 0x04.

668
00:27:38,370 --> 00:27:38,960
>> BINKY: 0x04.

669
00:27:38,960 --> 00:27:40,910
What happens if you go to 0x04?

670
00:27:40,910 --> 00:27:41,620
What do you get?

671
00:27:41,620 --> 00:27:42,371
>> STUDENT: Oh, OK.

672
00:27:42,371 --> 00:27:42,995
BINKY: You see?

673
00:27:42,995 --> 00:27:43,536
STUDENT: Yes.

674
00:27:43,536 --> 00:27:44,890
BINKY: So you get 5.

675
00:27:44,890 --> 00:27:49,170
So copy is going to have
5, if that makes sense.

676
00:27:49,170 --> 00:27:49,809
Yes?

677
00:27:49,809 --> 00:27:52,803
>> STUDENT: Could we have gotten
5 in the value box [INAUDIBLE]

678
00:27:52,803 --> 00:27:55,300
if we put int copy [INAUDIBLE].

679
00:27:55,300 --> 00:27:56,710
>> BINKY: Int-- we would, yeah.

680
00:27:56,710 --> 00:27:59,080
That would have done
pretty much the same thing.

681
00:27:59,080 --> 00:28:02,080
But this way, we can pass
address to functions.

682
00:28:02,080 --> 00:28:05,050
And that's the cool thing
we're going to do right now.

683
00:28:05,050 --> 00:28:06,770

684
00:28:06,770 --> 00:28:13,090
>> So this kind of exercise always comes up
on-- very usually comes up on quizzes.

685
00:28:13,090 --> 00:28:15,870
So it's really good to try to
do that kind of thing yourself.

686
00:28:15,870 --> 00:28:21,210
So try to keep track of what the address
is and want the values of the variables

687
00:28:21,210 --> 00:28:22,620
are at each point.

688
00:28:22,620 --> 00:28:24,370
So this is exactly
what we're going to do.

689
00:28:24,370 --> 00:28:26,988
Here, we have steps, one,
two, three, four, five.

690
00:28:26,988 --> 00:28:30,530
One, two, three, four, five.

691
00:28:30,530 --> 00:28:33,330
And we're going to keep track
of the values of x and a.

692
00:28:33,330 --> 00:28:34,650

693
00:28:34,650 --> 00:28:40,530
>> So what this is doing, if this is a
buggy code, we're trying to do to five.

694
00:28:40,530 --> 00:28:43,610
So we're trying to get in a
variable and change its value to 5.

695
00:28:43,610 --> 00:28:44,630

696
00:28:44,630 --> 00:28:49,900
And remember my analogy of having a
box and handing the box to someone?

697
00:28:49,900 --> 00:28:51,515
So main has this box called x.

698
00:28:51,515 --> 00:28:52,570

699
00:28:52,570 --> 00:28:54,170
And it contains the value 3.

700
00:28:54,170 --> 00:28:55,230

701
00:28:55,230 --> 00:28:57,455
And I'm trying to hand
this box to to five.

702
00:28:57,455 --> 00:28:58,560

703
00:28:58,560 --> 00:29:01,510
>> And I want to five to change
the value of this box to 5.

704
00:29:01,510 --> 00:29:03,080

705
00:29:03,080 --> 00:29:05,120
And then I just print the value of x.

706
00:29:05,120 --> 00:29:06,475

707
00:29:06,475 --> 00:29:08,850
This is what my function--
this is what I'm trying to do.

708
00:29:08,850 --> 00:29:12,450
I'm just trying to update
the value of x to 5.

709
00:29:12,450 --> 00:29:13,512

710
00:29:13,512 --> 00:29:14,970
Is it clear what the function does?

711
00:29:14,970 --> 00:29:16,210

712
00:29:16,210 --> 00:29:21,440
>> OK, so what are going to be the
values of x and a right here,

713
00:29:21,440 --> 00:29:27,734
the first line, right before the first
line-- I would say-- of the program?

714
00:29:27,734 --> 00:29:28,940
>> STUDENT: Probably garbage.

715
00:29:28,940 --> 00:29:30,023
>> BINKY: Just garbage stuff.

716
00:29:30,023 --> 00:29:32,590
So I just put N/A. So
we don't really know.

717
00:29:32,590 --> 00:29:37,400
Like, a doesn't even exist yet,
because we haven't called to five.

718
00:29:37,400 --> 00:29:38,980
Int a is not declared.

719
00:29:38,980 --> 00:29:40,030

720
00:29:40,030 --> 00:29:42,920
And x is going to exist
here, but we haven't really

721
00:29:42,920 --> 00:29:45,370
assigned any value to it, so OK?

722
00:29:45,370 --> 00:29:46,570

723
00:29:46,570 --> 00:29:52,340
>> And then, what are going to be the
values of x and a in number two?

724
00:29:52,340 --> 00:29:54,530

725
00:29:54,530 --> 00:29:55,410
>> STUDENT: [INAUDIBLE].

726
00:29:55,410 --> 00:29:57,540
>> BINKY: So x is going to be 3.

727
00:29:57,540 --> 00:29:59,650
That's easy, because
we're assigning 3 to it.

728
00:29:59,650 --> 00:30:03,500
And a still doesn't exist
because a just lives in to five.

729
00:30:03,500 --> 00:30:05,800
So I'm going to have 3 and nothing.

730
00:30:05,800 --> 00:30:08,590
or like garbage, whatever,
not really defined.

731
00:30:08,590 --> 00:30:11,640

732
00:30:11,640 --> 00:30:13,140
And now, this is the important line.

733
00:30:13,140 --> 00:30:14,931
Here, we're going to
actually call to five.

734
00:30:14,931 --> 00:30:17,140

735
00:30:17,140 --> 00:30:18,680
And remember what I said.

736
00:30:18,680 --> 00:30:20,240
We never pass in the box.

737
00:30:20,240 --> 00:30:23,110
We just copy the value of
the box to another box.

738
00:30:23,110 --> 00:30:27,000
That's all computers do, copy
things from one place to another.

739
00:30:27,000 --> 00:30:33,550
>> So to five, what it actually does
is it copies the value of x to a.

740
00:30:33,550 --> 00:30:35,130
So what is going to be here?

741
00:30:35,130 --> 00:30:36,210
The values of x and a.

742
00:30:36,210 --> 00:30:38,670

743
00:30:38,670 --> 00:30:43,360
3 and 3, we'll just copy
it over from x to a.

744
00:30:43,360 --> 00:30:44,710

745
00:30:44,710 --> 00:30:45,320
Cool.

746
00:30:45,320 --> 00:30:46,140
>> Now we're here.

747
00:30:46,140 --> 00:30:47,610

748
00:30:47,610 --> 00:30:49,430
And now we're going
to update a equals 5.

749
00:30:49,430 --> 00:30:50,900

750
00:30:50,900 --> 00:30:53,070
What's going to happen in line four?

751
00:30:53,070 --> 00:30:55,120

752
00:30:55,120 --> 00:30:56,010
>> STUDENT: [INAUDIBLE].

753
00:30:56,010 --> 00:30:59,685
>> BINKY: a gets updated,
but x didn't get updated.

754
00:30:59,685 --> 00:31:02,050

755
00:31:02,050 --> 00:31:05,250
Because x still lives in main, it's a
completely different block of memory.

756
00:31:05,250 --> 00:31:06,970
It's a different variable.

757
00:31:06,970 --> 00:31:07,900
a is another variable.

758
00:31:07,900 --> 00:31:10,000
They happen to have the
same value because I

759
00:31:10,000 --> 00:31:13,980
copied over the value of x to a.

760
00:31:13,980 --> 00:31:20,070
But now when I do a equals 5, it
doesn't really effect x in any way.

761
00:31:20,070 --> 00:31:21,450
This is the trickier part.

762
00:31:21,450 --> 00:31:23,380
Does it make sense to everybody?

763
00:31:23,380 --> 00:31:24,093
Yes?

764
00:31:24,093 --> 00:31:25,717
STUDENT: One more question, you have 3.

765
00:31:25,717 --> 00:31:27,741
Why is a already-- oh, no, it's 3.

766
00:31:27,741 --> 00:31:28,490
Sorry, never mind.

767
00:31:28,490 --> 00:31:29,310
I read 5.

768
00:31:29,310 --> 00:31:30,415
>> BINKY: Yeah, 3, 3.

769
00:31:30,415 --> 00:31:31,540
>> STUDENT: [INAUDIBLE], yeah.

770
00:31:31,540 --> 00:31:35,290
BINKY: And then we assign 5 to
a, but doesn't really change x.

771
00:31:35,290 --> 00:31:36,369
Good?

772
00:31:36,369 --> 00:31:36,910
STUDENT: Yes.

773
00:31:36,910 --> 00:31:37,410
BINKY: Yes?

774
00:31:37,410 --> 00:31:42,330
Can you explain again how
a gets copied [INAUDIBLE]?

775
00:31:42,330 --> 00:31:48,480
>> BINKY: OK, so when you call to five
of x, so this line of code here.

776
00:31:48,480 --> 00:31:50,100

777
00:31:50,100 --> 00:31:52,340
to five of x, what is x?

778
00:31:52,340 --> 00:31:55,160

779
00:31:55,160 --> 00:31:58,340
x is just 3 at this point, right?

780
00:31:58,340 --> 00:32:03,320
So you could just think of putting
a 3 in here and forgetting about x.

781
00:32:03,320 --> 00:32:04,410
Just put a 3 here.

782
00:32:04,410 --> 00:32:10,880
Like, we're going to copy over the
value of x to the int a that's up there.

783
00:32:10,880 --> 00:32:12,310

784
00:32:12,310 --> 00:32:13,630
OK?

785
00:32:13,630 --> 00:32:14,780
>> So the value of x is 3.

786
00:32:14,780 --> 00:32:17,680
We're going to copy 3 over to a.

787
00:32:17,680 --> 00:32:20,040
And all this other block of
memory, this other variable

788
00:32:20,040 --> 00:32:22,640
called a will have 3, as well.

789
00:32:22,640 --> 00:32:23,580
Does that make sense?

790
00:32:23,580 --> 00:32:24,780

791
00:32:24,780 --> 00:32:25,794
Yes?

792
00:32:25,794 --> 00:32:31,008
>> STUDENT: If you give to five like
have it as integer x instead of a,

793
00:32:31,008 --> 00:32:32,910
would that fix everything?

794
00:32:32,910 --> 00:32:36,290
>> BINKY: If it's an integer-- no,
that would not fix everything.

795
00:32:36,290 --> 00:32:37,590
So that's a very good question.

796
00:32:37,590 --> 00:32:40,480
It doesn't really matter what
you call those variables.

797
00:32:40,480 --> 00:32:44,510
Again, it will be an issue of scope,
because they're not the same x.

798
00:32:44,510 --> 00:32:46,526
They're completely
different spaces in memory.

799
00:32:46,526 --> 00:32:47,400
STUDENT: [INAUDIBLE].

800
00:32:47,400 --> 00:32:49,020
BINKY: So it doesn't really
matter what you call them.

801
00:32:49,020 --> 00:32:50,480
That doesn't fix things, OK?

802
00:32:50,480 --> 00:32:53,390

803
00:32:53,390 --> 00:32:54,430
More questions?

804
00:32:54,430 --> 00:32:55,762
Yes?

805
00:32:55,762 --> 00:32:58,498
>> STUDENT: How is it back to
number five [INAUDIBLE]?

806
00:32:58,498 --> 00:32:59,661

807
00:32:59,661 --> 00:33:01,160
BINKY: OK, we haven't done that yet.

808
00:33:01,160 --> 00:33:03,432
Let's go to number five, then.

809
00:33:03,432 --> 00:33:04,650
>> STUDENT: [INAUDIBLE]?

810
00:33:04,650 --> 00:33:05,565
>> BINKY: What?

811
00:33:05,565 --> 00:33:08,179
>> STUDENT: Do you have a return at all?

812
00:33:08,179 --> 00:33:09,970
BINKY: We don't have
a return, not of main.

813
00:33:09,970 --> 00:33:12,940
But main returns 0 automatically
if you don't return anything.

814
00:33:12,940 --> 00:33:14,400

815
00:33:14,400 --> 00:33:15,188
Yes?

816
00:33:15,188 --> 00:33:22,658
>> STUDENT: Could you make main-- or
could you make to five return a?

817
00:33:22,658 --> 00:33:24,170

818
00:33:24,170 --> 00:33:27,990
>> BINKY: We could have
to five return a, yes.

819
00:33:27,990 --> 00:33:32,527
But then we would have to assign x
equals the return value of to five,

820
00:33:32,527 --> 00:33:34,360
which would be a slightly
different program.

821
00:33:34,360 --> 00:33:35,440
It would work.

822
00:33:35,440 --> 00:33:38,730
But what we want to do is what is
called change something in place.

823
00:33:38,730 --> 00:33:41,690
So we want to actually
change that box and not worry

824
00:33:41,690 --> 00:33:44,390
about having to return
values or anything.

825
00:33:44,390 --> 00:33:44,890
OK?

826
00:33:44,890 --> 00:33:46,490

827
00:33:46,490 --> 00:33:50,150
>> This is just like the swap function
David showed in lecture, except I'm

828
00:33:50,150 --> 00:33:51,740
only dealing with one variable.

829
00:33:51,740 --> 00:33:55,960
And he used two, so int a and b and
then temporary variable and whatnot.

830
00:33:55,960 --> 00:33:57,020
OK?

831
00:33:57,020 --> 00:33:58,070
So what's the last line?

832
00:33:58,070 --> 00:34:04,400
After to five returns, it's
simply the a is going to go away.

833
00:34:04,400 --> 00:34:06,120

834
00:34:06,120 --> 00:34:10,179
We won't have a anymore, and
only x will still live on.

835
00:34:10,179 --> 00:34:12,130
>> And guess what? x
didn't change its value,

836
00:34:12,130 --> 00:34:15,520
after all, because we're
only changing the value of a.

837
00:34:15,520 --> 00:34:17,370
That's why x was 3 throughout.

838
00:34:17,370 --> 00:34:17,870
OK?

839
00:34:17,870 --> 00:34:20,195

840
00:34:20,195 --> 00:34:21,130
Good.

841
00:34:21,130 --> 00:34:23,560
So this program does not
achieve what we wanted.

842
00:34:23,560 --> 00:34:24,760
Now let's fix it.

843
00:34:24,760 --> 00:34:27,440
>> And the fix program is using pointers.

844
00:34:27,440 --> 00:34:32,300
What we do is we have three
lines that are different.

845
00:34:32,300 --> 00:34:34,020
The first ones is we're not passing x.

846
00:34:34,020 --> 00:34:35,535
We're passing the address of x.

847
00:34:35,535 --> 00:34:37,330

848
00:34:37,330 --> 00:34:40,876
So instead copying over
the value of the box,

849
00:34:40,876 --> 00:34:42,500
I'm still going to copy over something.

850
00:34:42,500 --> 00:34:45,380
But I'm copying over
the address of the box.

851
00:34:45,380 --> 00:34:48,780
>> So if I pass the address of the
box to to five, then to five

852
00:34:48,780 --> 00:34:51,560
will be able to find that in
memory and change its value.

853
00:34:51,560 --> 00:34:53,980

854
00:34:53,980 --> 00:34:59,580
>> So and then up there, I have
that a is not an int anymore.

855
00:34:59,580 --> 00:35:00,882
a is an int star.

856
00:35:00,882 --> 00:35:02,090
It's a pointer to an integer.

857
00:35:02,090 --> 00:35:03,790

858
00:35:03,790 --> 00:35:07,310
And then, because I'm passing the
address here, and then what I do

859
00:35:07,310 --> 00:35:10,530
is not a equals 5, because
a is holding an address.

860
00:35:10,530 --> 00:35:16,710
So what I want to do is go there and
update the contents of this address

861
00:35:16,710 --> 00:35:18,305
with 5.

862
00:35:18,305 --> 00:35:21,130
>> OK, so let's go through
all of lines one by one.

863
00:35:21,130 --> 00:35:22,410

864
00:35:22,410 --> 00:35:26,024
So when I start here, I
still have N/A, N/A, N/A

865
00:35:26,024 --> 00:35:28,440
for everything in the first
line, because I haven't really

866
00:35:28,440 --> 00:35:29,390
declared stuff yet.

867
00:35:29,390 --> 00:35:30,980

868
00:35:30,980 --> 00:35:35,110
And then line two, I have x equals 3.

869
00:35:35,110 --> 00:35:38,020
A int star a don't exist,
same thing as before.

870
00:35:38,020 --> 00:35:39,160

871
00:35:39,160 --> 00:35:40,640
>> Now it gets interesting.

872
00:35:40,640 --> 00:35:42,300
So I'm going to pass.

873
00:35:42,300 --> 00:35:45,720
And let's assume that the address
of x is 12 in hexadecimal.

874
00:35:45,720 --> 00:35:46,880

875
00:35:46,880 --> 00:35:48,420
Let's just assume this.

876
00:35:48,420 --> 00:35:49,221
I made it up.

877
00:35:49,221 --> 00:35:51,680

878
00:35:51,680 --> 00:35:53,500
So what am I passing here is a to five.

879
00:35:53,500 --> 00:35:54,460
I'm passing 12.

880
00:35:54,460 --> 00:35:56,390

881
00:35:56,390 --> 00:35:58,610
>> So what value does a have?

882
00:35:58,610 --> 00:36:04,785

883
00:36:04,785 --> 00:36:06,210
>> STUDENT: [INAUDIBLE].

884
00:36:06,210 --> 00:36:06,950
>> BINKY: Sorry?

885
00:36:06,950 --> 00:36:08,145
>> STUDENT: [INAUDIBLE].

886
00:36:08,145 --> 00:36:10,520
BINKY: Yeah, like, to let's
assume that we are here, now.

887
00:36:10,520 --> 00:36:11,540

888
00:36:11,540 --> 00:36:12,040
I'm asking.

889
00:36:12,040 --> 00:36:12,915
>> STUDENT: [INAUDIBLE].

890
00:36:12,915 --> 00:36:13,590

891
00:36:13,590 --> 00:36:14,890
>> BINKY: It has been initiated.

892
00:36:14,890 --> 00:36:15,860
>> STUDENT: [INAUDIBLE].

893
00:36:15,860 --> 00:36:17,985
BINKY: Because we passed
something to the function.

894
00:36:17,985 --> 00:36:19,431

895
00:36:19,431 --> 00:36:19,930
Yes?

896
00:36:19,930 --> 00:36:20,899
>> STUDENT: Address of x.

897
00:36:20,899 --> 00:36:22,690
BINKY: It's going to
have the address of x.

898
00:36:22,690 --> 00:36:25,800
And the address of x is 12, good.

899
00:36:25,800 --> 00:36:30,990
So x is going to be 3, because
we haven't really changed x yet.

900
00:36:30,990 --> 00:36:36,700
And then a is going to be 0x12, so
the address of x, because that's

901
00:36:36,700 --> 00:36:38,840
what we passed to to five.

902
00:36:38,840 --> 00:36:40,940
>> And then what happens
if we try to go there?

903
00:36:40,940 --> 00:36:42,145
What are we going to find?

904
00:36:42,145 --> 00:36:47,120
So if you try to print star a,
we're going to follow this address

905
00:36:47,120 --> 00:36:48,620
and get the value inside.

906
00:36:48,620 --> 00:36:50,470
And the value is just
the same value that x

907
00:36:50,470 --> 00:36:53,980
has because that's the
address of x, which will be 3.

908
00:36:53,980 --> 00:36:55,440

909
00:36:55,440 --> 00:36:56,930
Are we good?

910
00:36:56,930 --> 00:36:59,990
>> OK, and then now, we actually go there.

911
00:36:59,990 --> 00:37:05,510
And we update whatever
is in this address 12.

912
00:37:05,510 --> 00:37:07,390
We make it 5.

913
00:37:07,390 --> 00:37:10,560
So now both x and star a are 5.

914
00:37:10,560 --> 00:37:13,170

915
00:37:13,170 --> 00:37:13,680
>> Why is that?

916
00:37:13,680 --> 00:37:17,070
Because the address of x is 12.

917
00:37:17,070 --> 00:37:20,920
And a has also 12 as its value.

918
00:37:20,920 --> 00:37:23,780
So if we follow 12, we're
just going to find x.

919
00:37:23,780 --> 00:37:27,400
So whatever we do with
star a is going to happen

920
00:37:27,400 --> 00:37:30,790
to x, because a contains
the address of x.

921
00:37:30,790 --> 00:37:31,918

922
00:37:31,918 --> 00:37:32,418
OK?

923
00:37:32,418 --> 00:37:34,090

924
00:37:34,090 --> 00:37:37,750
>> And this is like the crux of the fix.

925
00:37:37,750 --> 00:37:41,500
So now we're able,
from to five, actually

926
00:37:41,500 --> 00:37:43,840
access memory that lived in main.

927
00:37:43,840 --> 00:37:47,980
So this memory doesn't live in to
five, like before, this address 12.

928
00:37:47,980 --> 00:37:50,980
And we were able to go there
and change its value to 5.

929
00:37:50,980 --> 00:37:53,990
>> And then when we return,
we forget about a.

930
00:37:53,990 --> 00:37:55,720
We forget about star a.

931
00:37:55,720 --> 00:37:57,020
And x is still five.

932
00:37:57,020 --> 00:37:58,327

933
00:37:58,327 --> 00:38:00,160
So if you want to
implement a swap function,

934
00:38:00,160 --> 00:38:05,010
you would just do the exact same thing,
except you need to int stars here,

935
00:38:05,010 --> 00:38:06,140
and so on and so forth.

936
00:38:06,140 --> 00:38:06,976
OK?

937
00:38:06,976 --> 00:38:07,475
Are we good?

938
00:38:07,475 --> 00:38:09,860

939
00:38:09,860 --> 00:38:10,610
Cool.

940
00:38:10,610 --> 00:38:12,410
>> So pointer arithmetic.

941
00:38:12,410 --> 00:38:13,960
This is a slightly tricky topic.

942
00:38:13,960 --> 00:38:16,554
So it turns out that
pointers are just integers.

943
00:38:16,554 --> 00:38:17,970
You can think of them as integers.

944
00:38:17,970 --> 00:38:21,080
Because in memory, you have like
memory address zero, one, two, three,

945
00:38:21,080 --> 00:38:21,900
four, five.

946
00:38:21,900 --> 00:38:23,900
So we can sum memory addresses.

947
00:38:23,900 --> 00:38:27,230
>> And that's usually what you do when
you're in and array, for example.

948
00:38:27,230 --> 00:38:30,540
An array is just like a contiguous
block of memory, of lots of chars,

949
00:38:30,540 --> 00:38:31,840
for example, lots of ints.

950
00:38:31,840 --> 00:38:34,420
So if you want to go to the
second int or to the third int,

951
00:38:34,420 --> 00:38:37,830
you can just sum something to the first
address, and you're going to get there.

952
00:38:37,830 --> 00:38:39,620
So this is really useful for that.

953
00:38:39,620 --> 00:38:41,850
>> And the thing to keep
in mind, though, is

954
00:38:41,850 --> 00:38:45,140
that it's not just like
normal arithmetic in the sense

955
00:38:45,140 --> 00:38:50,304
that if you're dealing with, say,
an int star, and you add 1 to it,

956
00:38:50,304 --> 00:38:52,220
then you're not going
to add 1 to the address,

957
00:38:52,220 --> 00:38:53,950
you're going to add 4 to the address.

958
00:38:53,950 --> 00:38:55,030

959
00:38:55,030 --> 00:38:56,670
Because an int is 4 bytes.

960
00:38:56,670 --> 00:38:57,720

961
00:38:57,720 --> 00:38:59,540
>> So this is just like
walking on an array.

962
00:38:59,540 --> 00:39:05,260
If we have an array of lots of ints and
then we try to go to the second one,

963
00:39:05,260 --> 00:39:08,790
it's basically just summing the
address of the first one plus 1.

964
00:39:08,790 --> 00:39:10,040

965
00:39:10,040 --> 00:39:13,425
But that won't be-- just let's say
that the address of the first one is 4.

966
00:39:13,425 --> 00:39:14,560

967
00:39:14,560 --> 00:39:16,250
Here, in this case.

968
00:39:16,250 --> 00:39:19,780

969
00:39:19,780 --> 00:39:22,850
And if we sum, so this
is what's happening.

970
00:39:22,850 --> 00:39:23,530
We have an int.

971
00:39:23,530 --> 00:39:25,640
Int x equals 5.

972
00:39:25,640 --> 00:39:26,950
X has a value 5.

973
00:39:26,950 --> 00:39:31,240
And we initialize this pointer, int
y int star y equals the address of x.

974
00:39:31,240 --> 00:39:33,660
>> Let's assume the address of x is 4.

975
00:39:33,660 --> 00:39:36,960
What's going to happen
now if I sum add 1 to y?

976
00:39:36,960 --> 00:39:39,110

977
00:39:39,110 --> 00:39:44,790
It's going to actually
sum 4 instead of just 1.

978
00:39:44,790 --> 00:39:50,920
So I add a 1, but it actually
added 4, because computer's smart.

979
00:39:50,920 --> 00:39:55,275
So it's going to actually add by i times
the size of the type of the pointer.

980
00:39:55,275 --> 00:39:56,340

981
00:39:56,340 --> 00:39:56,840
OK?

982
00:39:56,840 --> 00:39:58,030

983
00:39:58,030 --> 00:40:02,440
>> So if it were a char, for example,
if this were a char star y,

984
00:40:02,440 --> 00:40:07,141
and if we added 1 then this would
be 5, because char is 1 byte long.

985
00:40:07,141 --> 00:40:07,640
Good?

986
00:40:07,640 --> 00:40:10,560

987
00:40:10,560 --> 00:40:13,190
>> And finally, we got to
pointers and arrays.

988
00:40:13,190 --> 00:40:16,451
It turns out that every time
you're dealing with an array,

989
00:40:16,451 --> 00:40:18,075
you're actually dealing with a pointer.

990
00:40:18,075 --> 00:40:19,720

991
00:40:19,720 --> 00:40:24,777
The very nice conceptual reason for
this is that arrays are very big.

992
00:40:24,777 --> 00:40:27,360
So remember that I said that
every time you pass stuff around,

993
00:40:27,360 --> 00:40:29,097
you copy everything.

994
00:40:29,097 --> 00:40:31,180
So if you have an array
that's really, really big,

995
00:40:31,180 --> 00:40:32,990
you don't really want to
copy everything every time

996
00:40:32,990 --> 00:40:35,710
you pass it around to another
function, because that's just

997
00:40:35,710 --> 00:40:37,190
massive amounts of work.

998
00:40:37,190 --> 00:40:39,710
So what you do is just past
the address of the first byte.

999
00:40:39,710 --> 00:40:40,969

1000
00:40:40,969 --> 00:40:44,010
And then the function will have access
to all the elements in that array.

1001
00:40:44,010 --> 00:40:48,670
So you passed the array by its address,
so the address of the first byte.

1002
00:40:48,670 --> 00:40:53,010
>> So if we declare int
array 3, here, we know

1003
00:40:53,010 --> 00:40:57,470
how to access the first element
using the bracket notation.

1004
00:40:57,470 --> 00:41:02,410
If you remember the bracket
notation, array bracket 0 equals 1.

1005
00:41:02,410 --> 00:41:06,330
Well, this would be exactly the
same as just go there and put 1.

1006
00:41:06,330 --> 00:41:07,370

1007
00:41:07,370 --> 00:41:09,110
OK, is exactly the same thing.

1008
00:41:09,110 --> 00:41:13,010
So the bracket notation in here
will be the same as this line.

1009
00:41:13,010 --> 00:41:18,600
>> And guess what the bracket notation
for array bracket 1 will be?

1010
00:41:18,600 --> 00:41:20,440
It will just be the same thing as this.

1011
00:41:20,440 --> 00:41:22,500
So add one to array.

1012
00:41:22,500 --> 00:41:24,370
Move one along in memory.

1013
00:41:24,370 --> 00:41:26,310
Go there, and put a 2.

1014
00:41:26,310 --> 00:41:28,050

1015
00:41:28,050 --> 00:41:28,579
OK?

1016
00:41:28,579 --> 00:41:29,870
And this line's the same thing.

1017
00:41:29,870 --> 00:41:34,860
We want to go to the third
box, so array plus 2.

1018
00:41:34,860 --> 00:41:37,465
Go there, and put a 3.

1019
00:41:37,465 --> 00:41:39,340
So in memory, what's
going to happen is we're

1020
00:41:39,340 --> 00:41:44,400
going to have 1, 2, and 3 as the
three elements of this array.

1021
00:41:44,400 --> 00:41:46,970
>> We could have done this using
our familiar bracket notation.

1022
00:41:46,970 --> 00:41:49,410
I just want you guys to know
that they are the same thing.

1023
00:41:49,410 --> 00:41:50,530

1024
00:41:50,530 --> 00:41:53,010
OK, questions about this?

1025
00:41:53,010 --> 00:41:56,115

1026
00:41:56,115 --> 00:41:56,615
Nice.

1027
00:41:56,615 --> 00:41:57,990

1028
00:41:57,990 --> 00:41:59,880
Now, I'm going to hand
it over to Hannah,

1029
00:41:59,880 --> 00:42:00,330
>> HANNAH: Yay, yee-haw.

1030
00:42:00,330 --> 00:42:02,246
>> BINKY: Talking about
memory and article stuff.

1031
00:42:02,246 --> 00:42:06,554
[APPLAUSE]

1032
00:42:06,554 --> 00:42:10,150
>> HANNAH: Hi, cool, so we're
going to talk a little bit more

1033
00:42:10,150 --> 00:42:13,090
about memory, which we just
addressed using pointers.

1034
00:42:13,090 --> 00:42:16,060
So there are two main parts of
memory that we're concerned with.

1035
00:42:16,060 --> 00:42:18,830
We have the stack, which grows
up in the bottom, and heap, which

1036
00:42:18,830 --> 00:42:20,600
goes down from the top.

1037
00:42:20,600 --> 00:42:24,690
And the stack is going to hold
all of our instance variables.

1038
00:42:24,690 --> 00:42:28,860
So each calls to a function gets
its own little frame on the stack.

1039
00:42:28,860 --> 00:42:32,160
So as Gabe mentioned earlier, if we
call the function again and again,

1040
00:42:32,160 --> 00:42:34,180
we're going to stack
things up on the stack.

1041
00:42:34,180 --> 00:42:35,220

1042
00:42:35,220 --> 00:42:38,570
>> And similarly, the heap,
which starts at the top

1043
00:42:38,570 --> 00:42:42,660
is going to hold all of the memory
that we dynamically allocate.

1044
00:42:42,660 --> 00:42:45,110
And so as we dynamically
allocate memory,

1045
00:42:45,110 --> 00:42:47,580
this will come down towards the bottom.

1046
00:42:47,580 --> 00:42:51,340
Couple things to be aware of when
we're using the stack and the heap,

1047
00:42:51,340 --> 00:42:55,200
with the stack, if we have too
many-- let's say-- recursive calls,

1048
00:42:55,200 --> 00:42:58,392
and we're calling a function again,
and again, and again, and again,

1049
00:42:58,392 --> 00:43:00,350
and it's stacking up,
stacking up, stacking up.

1050
00:43:00,350 --> 00:43:01,570
And it's going to crash into the heap.

1051
00:43:01,570 --> 00:43:03,040
We're going to run out of memory.

1052
00:43:03,040 --> 00:43:05,100
That's going to cause a
problem for the computer.

1053
00:43:05,100 --> 00:43:06,770
And that's called the stack overflow.

1054
00:43:06,770 --> 00:43:09,728
So that's definitely something you
should be aware of and try to avoid.

1055
00:43:09,728 --> 00:43:10,228

1056
00:43:10,228 --> 00:43:14,050
And the heap, have to remember
not to accidentally leak memory.

1057
00:43:14,050 --> 00:43:17,950
Any time you use malloc, don't
forget to free that memory.

1058
00:43:17,950 --> 00:43:20,040
Otherwise, it'll just
be on the heap wasted,

1059
00:43:20,040 --> 00:43:23,230
and the computer won't know that
it is free to use that memory.

1060
00:43:23,230 --> 00:43:25,810
So those are a couple things
to be very careful with when

1061
00:43:25,810 --> 00:43:28,580
you're dealing with
the stack and the heap.

1062
00:43:28,580 --> 00:43:30,412
Any questions with this?

1063
00:43:30,412 --> 00:43:31,304
Awesome.

1064
00:43:31,304 --> 00:43:31,900
>> OK, cool.

1065
00:43:31,900 --> 00:43:32,940

1066
00:43:32,940 --> 00:43:36,810
So this kind of has the same
idea as stack overflow, where

1067
00:43:36,810 --> 00:43:39,850
we're going beyond the
bounds of what memory

1068
00:43:39,850 --> 00:43:41,960
is we're supposed to be able to use.

1069
00:43:41,960 --> 00:43:45,077
So take, for example, a buffer, or you
could just think of it as an array.

1070
00:43:45,077 --> 00:43:47,660
And we said, OK, we're going to
create this nice little array.

1071
00:43:47,660 --> 00:43:49,140
It's going to be a string.

1072
00:43:49,140 --> 00:43:50,630
Or it's going to store characters.

1073
00:43:50,630 --> 00:43:51,720
And it's just going to say hello.

1074
00:43:51,720 --> 00:43:52,678
And it's indeterminate.

1075
00:43:52,678 --> 00:43:53,990
That's it.

1076
00:43:53,990 --> 00:43:58,240
>> But if I were someone evil and wanted to
do something bad with this array, what

1077
00:43:58,240 --> 00:44:02,310
I could do is try to write
past the end of the string.

1078
00:44:02,310 --> 00:44:04,490
And as you'll see, if
I write far enough,

1079
00:44:04,490 --> 00:44:06,980
I can actually affect
the return address.

1080
00:44:06,980 --> 00:44:09,530
And if I start to affect
the return address,

1081
00:44:09,530 --> 00:44:11,730
I affect how the program actually runs.

1082
00:44:11,730 --> 00:44:15,900
And instead of returning, you
know, a happy string like hello, I

1083
00:44:15,900 --> 00:44:19,460
could do something bad, like go to
somewhere else in your computer, still

1084
00:44:19,460 --> 00:44:22,146
memory, change it,
whatever I want to do.

1085
00:44:22,146 --> 00:44:25,020
So that's what this would look like
is if I just kind of filled it up

1086
00:44:25,020 --> 00:44:27,400
with random garbage value,
in this case, just a.

1087
00:44:27,400 --> 00:44:30,490
And then when I actually
got to the memory address,

1088
00:44:30,490 --> 00:44:33,740
I started filling it with something
that did what I wanted it to do.

1089
00:44:33,740 --> 00:44:34,952

1090
00:44:34,952 --> 00:44:36,410
Any questions with buffer overflow?

1091
00:44:36,410 --> 00:44:38,450

1092
00:44:38,450 --> 00:44:40,730
Awesome, flying right
through this stuff.

1093
00:44:40,730 --> 00:44:43,530
>> OK, so we talked a lot of
about pointer with Gabe.

1094
00:44:43,530 --> 00:44:45,790
How do we actually get a pointer?

1095
00:44:45,790 --> 00:44:48,070
How do we get an address in memory?

1096
00:44:48,070 --> 00:44:51,040
Well, we can use this nice
function call malloc, which

1097
00:44:51,040 --> 00:44:53,370
is going to get a
little piece of memory,

1098
00:44:53,370 --> 00:44:55,480
specifically in the
heap, as we discussed,

1099
00:44:55,480 --> 00:44:59,780
and it's going to give you back a
pointer to that address in memory.

1100
00:44:59,780 --> 00:45:01,950
And the argument that we
have to give to malloc

1101
00:45:01,950 --> 00:45:04,280
is how much space in memory we want.

1102
00:45:04,280 --> 00:45:06,100
>> So you can see the size in byte.

1103
00:45:06,100 --> 00:45:08,670
Let's say, for example, or
actually, in this example,

1104
00:45:08,670 --> 00:45:12,040
we allocate enough
space for 10 integers.

1105
00:45:12,040 --> 00:45:15,640
So probably what we're going to want
to put here is an array of 10 integers.

1106
00:45:15,640 --> 00:45:19,641
So we give it size of ints, which
we learned was how many bytes?

1107
00:45:19,641 --> 00:45:20,140
STUDENT: 4.

1108
00:45:20,140 --> 00:45:22,920
HANNAH: 4, beautiful, and we
want 10 of those in a row,

1109
00:45:22,920 --> 00:45:28,050
so that we have enough space to
store all 10 integers, in this case.

1110
00:45:28,050 --> 00:45:31,290
Something super important,
any time you call malloc,

1111
00:45:31,290 --> 00:45:32,880
you have to check for null.

1112
00:45:32,880 --> 00:45:37,310
If you don't check for null, well,
malloc if it runs out of space

1113
00:45:37,310 --> 00:45:40,400
and can no longer give you any
more memory, it will return null.

1114
00:45:40,400 --> 00:45:42,060

1115
00:45:42,060 --> 00:45:45,630
So if you don't check,
malloc may return null.

1116
00:45:45,630 --> 00:45:51,265
And then if we try to
dereference a null pointer,

1117
00:45:51,265 --> 00:45:54,960
we're going to get a segmentation fault,
which we will talk about right now.

1118
00:45:54,960 --> 00:45:56,150

1119
00:45:56,150 --> 00:45:56,650
Awesome.

1120
00:45:56,650 --> 00:45:58,300
>> OK, questions with malloc?

1121
00:45:58,300 --> 00:46:00,044

1122
00:46:00,044 --> 00:46:00,544
Yes?

1123
00:46:00,544 --> 00:46:05,460
>> STUDENT: Does checking null
[INAUDIBLE] don't do it on the quiz?

1124
00:46:05,460 --> 00:46:08,100
>> HANNAH: Sure, the question was
does it matter-- on the quiz,

1125
00:46:08,100 --> 00:46:10,420
will you get points off if
you don't check for null?

1126
00:46:10,420 --> 00:46:12,794
Yes, you will get points off
if you don't check for null.

1127
00:46:12,794 --> 00:46:16,030
Any time you call malloc , both on the
quiz and your psets and in real life,

1128
00:46:16,030 --> 00:46:17,155
you have to check for null.

1129
00:46:17,155 --> 00:46:18,330
Good question.

1130
00:46:18,330 --> 00:46:19,689
>> GABE: What if I don't free?

1131
00:46:19,689 --> 00:46:21,730
HANNAH: Gabe wants to know
what if we don't free.

1132
00:46:21,730 --> 00:46:25,030
Then we will have a
memory leak in our heap.

1133
00:46:25,030 --> 00:46:26,140
Any other questions?

1134
00:46:26,140 --> 00:46:27,550
Yes?

1135
00:46:27,550 --> 00:46:30,120
>> STUDENT: Can you-- go over
buffer overflow real quick again?

1136
00:46:30,120 --> 00:46:30,530
>> HANNAH: Sure.

1137
00:46:30,530 --> 00:46:33,071
The question was can we go over
buffer overflow really quick.

1138
00:46:33,071 --> 00:46:35,050
Let's go back to those slides.

1139
00:46:35,050 --> 00:46:37,430
So a buffer, you can just
think of it as an array, right?

1140
00:46:37,430 --> 00:46:39,360
You have some space in memory.

1141
00:46:39,360 --> 00:46:43,580
And when we first create our array,
we know arrays have fixed size,

1142
00:46:43,580 --> 00:46:45,470
or our buffer has a fixed size.

1143
00:46:45,470 --> 00:46:51,360
>> So let's say in this case, we have just
enough space to write the string hello.

1144
00:46:51,360 --> 00:46:57,340
If we go past that bound, if we go past
what our array we said it could hold,

1145
00:46:57,340 --> 00:46:59,780
we could actually start
writing into memory

1146
00:46:59,780 --> 00:47:01,780
that the computer doesn't
want us to write into.

1147
00:47:01,780 --> 00:47:02,810

1148
00:47:02,810 --> 00:47:05,580
And specifically, if we hit
something like the return

1149
00:47:05,580 --> 00:47:08,700
address of the function, which,
like any other piece of memory,

1150
00:47:08,700 --> 00:47:11,420
is just somewhere in your
computer, you can actually

1151
00:47:11,420 --> 00:47:14,080
change that and start to do evil things.

1152
00:47:14,080 --> 00:47:15,272
Answer your question?

1153
00:47:15,272 --> 00:47:16,230
Awesome, anything else?

1154
00:47:16,230 --> 00:47:17,466
Yes?

1155
00:47:17,466 --> 00:47:21,948
>> STUDENT: So stack [INAUDIBLE], you
said go from the bottom going up.

1156
00:47:21,948 --> 00:47:25,434
Within stack range, does
the memory go from, like,

1157
00:47:25,434 --> 00:47:27,230
top down pertaining to each break?

1158
00:47:27,230 --> 00:47:28,646

1159
00:47:28,646 --> 00:47:32,100
>> HANNAH: How do you--
defer to Rob on this one.

1160
00:47:32,100 --> 00:47:35,370

1161
00:47:35,370 --> 00:47:38,213
>> ROB: It will grow in the same
direction as the stack grows.

1162
00:47:38,213 --> 00:47:38,712
HANNAH: OK.

1163
00:47:38,712 --> 00:47:40,967
ROB: So I get confused.

1164
00:47:40,967 --> 00:47:42,331
This is going to be abstraction.

1165
00:47:42,331 --> 00:47:42,831
HANNAH: OK.

1166
00:47:42,831 --> 00:47:44,000
ROB: This is correct.

1167
00:47:44,000 --> 00:47:49,420
So if the stack is growing
up, then generally-- it

1168
00:47:49,420 --> 00:47:52,380
doesn't have to be like this.
but you can declare int x.

1169
00:47:52,380 --> 00:47:54,120
Then you declare int y.

1170
00:47:54,120 --> 00:47:57,300
Then int x will generally be
lower on the stack than int y.

1171
00:47:57,300 --> 00:47:59,300
But that's just a fact.

1172
00:47:59,300 --> 00:48:02,410
That's not like an important seed thing.

1173
00:48:02,410 --> 00:48:06,800
>> ROB: So the question again was just
what happens each frame builds up.

1174
00:48:06,800 --> 00:48:08,960
So each function gets a
little piece of the stack.

1175
00:48:08,960 --> 00:48:13,030
And as you go up, within that
little piece, within that frame,

1176
00:48:13,030 --> 00:48:16,710
we'll say that variables
within that frame also move up.

1177
00:48:16,710 --> 00:48:17,473
Question?

1178
00:48:17,473 --> 00:48:18,688
>> ROB: Just to be on mic.

1179
00:48:18,688 --> 00:48:19,396
HANNAH: Oh, yeah.

1180
00:48:19,396 --> 00:48:20,440
ROB: I'll speak into you.

1181
00:48:20,440 --> 00:48:21,410
HANNAH: Oh, yeah, OK.

1182
00:48:21,410 --> 00:48:24,150
ROB: The exception is
for arrays and structs,

1183
00:48:24,150 --> 00:48:27,470
where arrays, a lower
index in the array,

1184
00:48:27,470 --> 00:48:29,930
and in structs at higher
field in the structs

1185
00:48:29,930 --> 00:48:35,040
are guaranteed to be at lower addresses
than a later value in the array.

1186
00:48:35,040 --> 00:48:36,720
So those are guaranteed.

1187
00:48:36,720 --> 00:48:40,310
But any particular variables within,
like int x and int y within a function,

1188
00:48:40,310 --> 00:48:43,030
there's no necessary relationship
between their addresses.

1189
00:48:43,030 --> 00:48:44,882

1190
00:48:44,882 --> 00:48:46,340
HANNAH: Another question over here?

1191
00:48:46,340 --> 00:48:51,620
STUDENT: So in buffer
flow, only buffer overflow

1192
00:48:51,620 --> 00:48:54,980
only happened when you
have, like, assigned

1193
00:48:54,980 --> 00:49:01,056
an amount of an array
that then is greater?

1194
00:49:01,056 --> 00:49:03,230
Like, can you?

1195
00:49:03,230 --> 00:49:05,435
So if you're asking for
something from the user--

1196
00:49:05,435 --> 00:49:06,018
>> HANNAH: Mm-hm.

1197
00:49:06,018 --> 00:49:08,600
STUDENT: Can they forcibly
give you something back

1198
00:49:08,600 --> 00:49:11,777
that's larger than whatever
you've allocated for them?

1199
00:49:11,777 --> 00:49:13,610
HANNAH: Sure, so the
question was basically,

1200
00:49:13,610 --> 00:49:16,217
can the user give you
more than you ask for?

1201
00:49:16,217 --> 00:49:16,800
STUDENT: Yeah.

1202
00:49:16,800 --> 00:49:18,480
HANNAH: Well, you could prevent
the user from doing that.

1203
00:49:18,480 --> 00:49:21,350
You could specifically say don't
give me more than x number by bytes

1204
00:49:21,350 --> 00:49:24,330
I've only given you room for x number
of bytes, x number of characters.

1205
00:49:24,330 --> 00:49:25,700
So that's something you want to prevent.

1206
00:49:25,700 --> 00:49:26,199
Yes?

1207
00:49:26,199 --> 00:49:30,270
What is the difference between
stack overflow and buffer overflow?

1208
00:49:30,270 --> 00:49:32,140
>> HANNAH: OK, so the stack
overflow-- oh, what

1209
00:49:32,140 --> 00:49:34,790
is the difference between stack
overflow and buffer overflow?

1210
00:49:34,790 --> 00:49:37,581
So we want to think of stack overflow
happening when we're actually

1211
00:49:37,581 --> 00:49:39,530
stacking up these function calls.

1212
00:49:39,530 --> 00:49:42,991
Let's say you have a recursive function,
because we know that every time you

1213
00:49:42,991 --> 00:49:45,240
call a function, it's gets
its own frame on the stack.

1214
00:49:45,240 --> 00:49:47,950
>> So we stack up too high, and
then we start to overflow.

1215
00:49:47,950 --> 00:49:50,530
And we use too much memory, And
we don't have anywhere left.

1216
00:49:50,530 --> 00:49:51,590
We get that error.

1217
00:49:51,590 --> 00:49:53,930
>> Buffer overflow is within a program.

1218
00:49:53,930 --> 00:49:57,180
We want might not necessarily have
run out of memory in the same way

1219
00:49:57,180 --> 00:50:00,080
that we might if we're stacking
up so many function calls,

1220
00:50:00,080 --> 00:50:04,540
but we write past the memory
that we know we can use.

1221
00:50:04,540 --> 00:50:06,170
And that allows us to do evil things.

1222
00:50:06,170 --> 00:50:08,060

1223
00:50:08,060 --> 00:50:08,560
Yeah?

1224
00:50:08,560 --> 00:50:10,950
>> ROB: Yes, you might want
to just repeat this,

1225
00:50:10,950 --> 00:50:12,699
but you can also think
of a stack overflow

1226
00:50:12,699 --> 00:50:15,374
as like a specific type
of buffer overflow.

1227
00:50:15,374 --> 00:50:17,665
Or you just think of your
stack as a really big buffer.

1228
00:50:17,665 --> 00:50:20,724
Then when you overflow you stack,
it's kind of like a buffer overflow.

1229
00:50:20,724 --> 00:50:23,390
But a stack overflow is just a
specific term used when the stack

1230
00:50:23,390 --> 00:50:24,310
itself overflows.

1231
00:50:24,310 --> 00:50:27,500
>> HANNAH: Right, so to
repeat for the video,

1232
00:50:27,500 --> 00:50:31,756
it you can think of stack overflow as
a specific type of buffer overflow.

1233
00:50:31,756 --> 00:50:33,040
Cool?

1234
00:50:33,040 --> 00:50:34,562
Any more questions before we go on?

1235
00:50:34,562 --> 00:50:35,380

1236
00:50:35,380 --> 00:50:35,880
Awesome.

1237
00:50:35,880 --> 00:50:37,130

1238
00:50:37,130 --> 00:50:39,727
>> OK, cool, so let's talk about
some common error messages.

1239
00:50:39,727 --> 00:50:42,060
This is something that has
shown up on multiple quizzes,

1240
00:50:42,060 --> 00:50:44,740
so something that's worth
taking a second look at.

1241
00:50:44,740 --> 00:50:46,860
I'm sure you've encountered
at least some of these

1242
00:50:46,860 --> 00:50:48,690
as you're doing your problem sets.

1243
00:50:48,690 --> 00:50:50,980
So make sure you can talk
about them on the quiz.

1244
00:50:50,980 --> 00:50:52,990
>> So the first one is
a segmentation fault.

1245
00:50:52,990 --> 00:50:55,250
And that's any time we
try to access memory

1246
00:50:55,250 --> 00:50:57,130
that we're not allowed to access.

1247
00:50:57,130 --> 00:51:00,280
So you migh have seen this,
for example, in breakout.

1248
00:51:00,280 --> 00:51:03,390
If detect collision
return null, and then you

1249
00:51:03,390 --> 00:51:05,500
tried to do something
with that null value,

1250
00:51:05,500 --> 00:51:08,147
the computer would give
you a segmentation fault.

1251
00:51:08,147 --> 00:51:10,730
So one, an important thing to
do in order to try to avoid this

1252
00:51:10,730 --> 00:51:12,000
is to always check for null.

1253
00:51:12,000 --> 00:51:13,300

1254
00:51:13,300 --> 00:51:16,180
>> You might have also seen
implicit declaration of function.

1255
00:51:16,180 --> 00:51:18,370
So this is what happens
when Allison showed you

1256
00:51:18,370 --> 00:51:20,150
how we make a prototype, right?

1257
00:51:20,150 --> 00:51:23,440
So let's say we have some
function that we define.

1258
00:51:23,440 --> 00:51:24,440
Let's say cube.

1259
00:51:24,440 --> 00:51:27,120
And that goes at the bottom
of our function, under main.

1260
00:51:27,120 --> 00:51:35,205
>> If we forget to tell the computer about
cube, when main tries to call cube,

1261
00:51:35,205 --> 00:51:36,830
the computer will be, like, oh my gosh.

1262
00:51:36,830 --> 00:51:38,300
I have no idea what that means.

1263
00:51:38,300 --> 00:51:39,760
I don't know what to do, here.

1264
00:51:39,760 --> 00:51:41,594
So the prototype says don't worry.

1265
00:51:41,594 --> 00:51:42,510
I'm going to tell you.

1266
00:51:42,510 --> 00:51:43,132
>> It'll come.

1267
00:51:43,132 --> 00:51:43,840
Don't yell at me.

1268
00:51:43,840 --> 00:51:46,697
Don't give me an implicit
declaration of function.

1269
00:51:46,697 --> 00:51:49,280
So if you get this error, one
thing you're going to want to do

1270
00:51:49,280 --> 00:51:50,821
is make sure you have your prototype.

1271
00:51:50,821 --> 00:51:52,320

1272
00:51:52,320 --> 00:51:53,230
OK?

1273
00:51:53,230 --> 00:51:55,680
>> And last but not least,
undeclared identifier

1274
00:51:55,680 --> 00:52:00,570
is essentially when you try to use a
variable that you haven't declared.

1275
00:52:00,570 --> 00:52:03,449
So all of a sudden you start
saying like n plus plus.

1276
00:52:03,449 --> 00:52:04,740
And the computer says what's n?

1277
00:52:04,740 --> 00:52:06,660
You never told me n was a thing.

1278
00:52:06,660 --> 00:52:10,930
>> So one thing you have to make sure you
did is tell the computer what n is.

1279
00:52:10,930 --> 00:52:13,320
So for example, n might be an integer.

1280
00:52:13,320 --> 00:52:14,999
And then you will avoid this error.

1281
00:52:14,999 --> 00:52:16,290
Any questions on common errors?

1282
00:52:16,290 --> 00:52:17,260
Yes?

1283
00:52:17,260 --> 00:52:19,344
>> STUDENT: For the implicit
declaration of function,

1284
00:52:19,344 --> 00:52:22,343
could it also be that you omitted one
of the libraries you were supposed

1285
00:52:22,343 --> 00:52:24,400
to include, rather than the prototype?

1286
00:52:24,400 --> 00:52:26,359
>> HANNAH: Right, so the
question was, could you

1287
00:52:26,359 --> 00:52:28,650
also get this error if you
forgot to include a library.

1288
00:52:28,650 --> 00:52:29,085
>> STUDENT: Yes.

1289
00:52:29,085 --> 00:52:30,876
>> HANNAH: Absolutely,
because in the same way

1290
00:52:30,876 --> 00:52:33,540
that we want to put our prototypes
before the main function,

1291
00:52:33,540 --> 00:52:37,717
if we have a library, those are going
to essentially include the prototypes,

1292
00:52:37,717 --> 00:52:39,425
include the definitions
of the functions.

1293
00:52:39,425 --> 00:52:40,585
Great question.

1294
00:52:40,585 --> 00:52:43,230
>> STUDENT: For a segmentation
fault, would that also

1295
00:52:43,230 --> 00:52:47,350
happen if we, like, tried
to access a variable,

1296
00:52:47,350 --> 00:52:51,947
like, in a different [INAUDIBLE]
than it was declared in?

1297
00:52:51,947 --> 00:52:54,030
HANNAH: Sure, so would we
get a segmentation fault

1298
00:52:54,030 --> 00:52:56,270
if we tried to access a
variable out of scope?

1299
00:52:56,270 --> 00:52:57,104
Was that a question?

1300
00:52:57,104 --> 00:52:57,645
STUDENT: Yes.

1301
00:52:57,645 --> 00:52:58,430
HANNAH: Beautiful.

1302
00:52:58,430 --> 00:53:01,840
So probably, you're going to get an
undeclared identifier error instead.

1303
00:53:01,840 --> 00:53:04,006
So it's just going to say
I don't know what that is.

1304
00:53:04,006 --> 00:53:04,920

1305
00:53:04,920 --> 00:53:05,920
Cool, anything else?

1306
00:53:05,920 --> 00:53:07,744

1307
00:53:07,744 --> 00:53:08,980
Yeah, OK, beautiful.

1308
00:53:08,980 --> 00:53:10,330

1309
00:53:10,330 --> 00:53:12,400
>> All righty, so recursion.

1310
00:53:12,400 --> 00:53:15,160
So I mentioned a couple times
that we might get a stack overflow

1311
00:53:15,160 --> 00:53:17,919
because we're calling our
recursive function so many times.

1312
00:53:17,919 --> 00:53:20,210
We're getting all these stack
frames, blah, blah, blah.

1313
00:53:20,210 --> 00:53:22,420
What even is a recursive function?

1314
00:53:22,420 --> 00:53:25,680
Well, a recursive function is
any function that calls itself.

1315
00:53:25,680 --> 00:53:26,820

1316
00:53:26,820 --> 00:53:30,160
>> Some things to be aware of when you
are implementing recursive function,

1317
00:53:30,160 --> 00:53:31,940
don't forget to include a base case.

1318
00:53:31,940 --> 00:53:34,010
A base case is the
point at which we end.

1319
00:53:34,010 --> 00:53:38,740
So, for example, if we're coding,
, say, Fibonacci recursively,

1320
00:53:38,740 --> 00:53:43,210
we want to make sure that when we get
to the 0 or the first Fibonacci number,

1321
00:53:43,210 --> 00:53:46,220
those two numbers have these cases,
because those aren't dependent

1322
00:53:46,220 --> 00:53:47,700
on things that came before.

1323
00:53:47,700 --> 00:53:48,990
Those have their own values.

1324
00:53:48,990 --> 00:53:51,270

1325
00:53:51,270 --> 00:53:55,320
>> Some pros to recursion, which is a
question we've seen on past quizzes.

1326
00:53:55,320 --> 00:53:57,930
They can lead to more
concise, elegant code.

1327
00:53:57,930 --> 00:54:00,510
And a lot of functions, a
lot of different algorithms,

1328
00:54:00,510 --> 00:54:02,350
actually lend themselves to recursion.

1329
00:54:02,350 --> 00:54:05,510
Their definition might be
recursive in and of itself.

1330
00:54:05,510 --> 00:54:06,980
So Fibonacci is one.

1331
00:54:06,980 --> 00:54:07,860
Factorial is one.

1332
00:54:07,860 --> 00:54:10,480
Merge sort is one-- all
things that you can look at.

1333
00:54:10,480 --> 00:54:12,650

1334
00:54:12,650 --> 00:54:13,460
OK, any questions?

1335
00:54:13,460 --> 00:54:13,960
Yes?

1336
00:54:13,960 --> 00:54:15,644

1337
00:54:15,644 --> 00:54:19,612
>> STUDENT: Is a corner case
similar to a base case?

1338
00:54:19,612 --> 00:54:22,590
Or is that for some other
kind of [INAUDIBLE]?

1339
00:54:22,590 --> 00:54:25,170
>> HANNAH: Sure, so a
corner case is any-- so

1340
00:54:25,170 --> 00:54:27,580
is corner case the same as base case?

1341
00:54:27,580 --> 00:54:32,825
A corner case is anything that your
code might behave a little differently.

1342
00:54:32,825 --> 00:54:34,450

1343
00:54:34,450 --> 00:54:38,610
Base case is sort of related, in
that they're like particular cases

1344
00:54:38,610 --> 00:54:40,240
that you want to look at.

1345
00:54:40,240 --> 00:54:43,240
But the idea of a base case is that
you want your recursive function

1346
00:54:43,240 --> 00:54:44,870
to stop at some point.

1347
00:54:44,870 --> 00:54:46,490
It can't keep calling itself forever.

1348
00:54:46,490 --> 00:54:47,781
It needs to stop at some point.

1349
00:54:47,781 --> 00:54:49,340

1350
00:54:49,340 --> 00:54:53,460
>> ROB: Yes, frequently, your base cases
might be examples of corner bases.

1351
00:54:53,460 --> 00:54:55,876
>> HANNAH: Right, cool, anything?

1352
00:54:55,876 --> 00:54:58,732
>> STUDENT: Could you explain
bases a little bit more?

1353
00:54:58,732 --> 00:55:01,600
I don't quite understand
[INAUDIBLE] base cases.

1354
00:55:01,600 --> 00:55:02,676
>> HANNAH: Of base cases?

1355
00:55:02,676 --> 00:55:03,140
>> STUDENT: Base cases, yeah.

1356
00:55:03,140 --> 00:55:03,770
>> HANNAH: Oh yeah, sure.

1357
00:55:03,770 --> 00:55:04,270
Let's see.

1358
00:55:04,270 --> 00:55:05,480
Do we have chalk over here?

1359
00:55:05,480 --> 00:55:06,690

1360
00:55:06,690 --> 00:55:07,320
Yes, we do.

1361
00:55:07,320 --> 00:55:09,530
OK, so really quickly, I'll
try to write big enough

1362
00:55:09,530 --> 00:55:11,320
so you can see on the screen.

1363
00:55:11,320 --> 00:55:13,490
Let's talk about, really
quickly, Fibonacci.

1364
00:55:13,490 --> 00:55:15,550
So I'll give you the Fibonacci sequence.

1365
00:55:15,550 --> 00:55:17,090
You can look up the definition.

1366
00:55:17,090 --> 00:55:26,050
>> Essentially, each number in the sequence
is the sum of the two previous numbers.

1367
00:55:26,050 --> 00:55:29,720
OK, so the way that I
just described Fibonacci,

1368
00:55:29,720 --> 00:55:31,530
you could hear the recursion, right?

1369
00:55:31,530 --> 00:55:35,280
When I said each number is the
sum of the two previous numbers,

1370
00:55:35,280 --> 00:55:36,420
we could say OK.

1371
00:55:36,420 --> 00:55:38,570
Well, the nth Fibonacci
number-- so let's

1372
00:55:38,570 --> 00:55:42,260
say we have this function
called fib-- fib of n

1373
00:55:42,260 --> 00:55:48,260
is going to be equal to fib
of n minus 1 plus-- sorry,

1374
00:55:48,260 --> 00:55:51,240
we'll going on to the next line
over here-- fib of n minus 2.

1375
00:55:51,240 --> 00:55:52,790

1376
00:55:52,790 --> 00:55:56,790
>> OK, so this works great if you're
looking at, for example, the zero, one,

1377
00:55:56,790 --> 00:55:59,410
two, three, four,
fifth Fibonacci number,

1378
00:55:59,410 --> 00:56:03,561
where you can say that
5 is equal to 2 plus 3.

1379
00:56:03,561 --> 00:56:05,060
But what if you're at the beginning?

1380
00:56:05,060 --> 00:56:07,184
What if you're just hitting
these first two values?

1381
00:56:07,184 --> 00:56:08,470

1382
00:56:08,470 --> 00:56:11,330
>> To get this 1, you can't
say add the previous two,

1383
00:56:11,330 --> 00:56:13,930
because that zero and-- I don't know.

1384
00:56:13,930 --> 00:56:15,390
So at some point, we need to stop.

1385
00:56:15,390 --> 00:56:21,250
At some point, we need to say that these
two just have their own definitions.

1386
00:56:21,250 --> 00:56:23,890
The 0 Fibonacci number is 0.

1387
00:56:23,890 --> 00:56:26,115
And the first Fibonacci number is 1.

1388
00:56:26,115 --> 00:56:34,120
>> So the way I might code this, I
would say if n is less than two,

1389
00:56:34,120 --> 00:56:35,130
then just return n.

1390
00:56:35,130 --> 00:56:36,494
And that would be my base case.

1391
00:56:36,494 --> 00:56:38,660
That's how I know to stop
with a recursive function.

1392
00:56:38,660 --> 00:56:40,640

1393
00:56:40,640 --> 00:56:41,410
Is that clear?

1394
00:56:41,410 --> 00:56:41,940
Awesome.

1395
00:56:41,940 --> 00:56:43,260
Anything else on recursion?

1396
00:56:43,260 --> 00:56:44,890

1397
00:56:44,890 --> 00:56:45,930
Beautiful.

1398
00:56:45,930 --> 00:56:48,750
>> Let's quickly talk about
search and sort run times.

1399
00:56:48,750 --> 00:56:52,660
And then I will give Davin some
time to talk about coding examples.

1400
00:56:52,660 --> 00:56:56,490
So here are the main search and
sorts that you should know about.

1401
00:56:56,490 --> 00:56:59,500
Guarantee-- I can't guarantee,
because I haven't seen the quiz--

1402
00:56:59,500 --> 00:57:01,940
but this comes up quiz
after quiz after quit.

1403
00:57:01,940 --> 00:57:04,050
So definitely use this chart.

1404
00:57:04,050 --> 00:57:05,682
Like, take this chart.

1405
00:57:05,682 --> 00:57:06,890
Put it onto your cheat sheet.

1406
00:57:06,890 --> 00:57:07,931
You'll be a happy person.

1407
00:57:07,931 --> 00:57:09,010

1408
00:57:09,010 --> 00:57:12,590
>> This tells us the run times of each
of these sort and search algorithms.

1409
00:57:12,590 --> 00:57:14,020

1410
00:57:14,020 --> 00:57:18,850
So linear search, you can see run
time, and same with binary search.

1411
00:57:18,850 --> 00:57:21,490
Go over what these algorithms
do, the general idea.

1412
00:57:21,490 --> 00:57:24,220
Look at some pseudocode,
if not code itself.

1413
00:57:24,220 --> 00:57:25,610

1414
00:57:25,610 --> 00:57:30,380
>> You'll see that bubble sort has a upper
bound in the worst case of n squared.

1415
00:57:30,380 --> 00:57:31,490

1416
00:57:31,490 --> 00:57:34,680
So if our array was completely
backwards before we wanted to sort it,

1417
00:57:34,680 --> 00:57:37,090
we would say that that's
going to take n squared steps.

1418
00:57:37,090 --> 00:57:38,160

1419
00:57:38,160 --> 00:57:41,730
But in the best case, so the
lower bound for the best case

1420
00:57:41,730 --> 00:57:44,300
is going to be if it's
already perfectly sorted.

1421
00:57:44,300 --> 00:57:46,671
Then all we have to do is
check that it's sorted.

1422
00:57:46,671 --> 00:57:47,921
Is there a question over here?

1423
00:57:47,921 --> 00:57:49,805
>> STUDENT: When would
you want to use sort?

1424
00:57:49,805 --> 00:57:50,747
The sort.

1425
00:57:50,747 --> 00:57:52,160
I'm just curious.

1426
00:57:52,160 --> 00:57:53,510
>> HANNAH: When would you
want to use selection sort?

1427
00:57:53,510 --> 00:57:54,010
This one?

1428
00:57:54,010 --> 00:57:55,705
The one that's n squared in both cases?

1429
00:57:55,705 --> 00:57:56,860
>> STUDENT: [INAUDIBLE].

1430
00:57:56,860 --> 00:57:58,151
>> HANNAH: So it's very different.

1431
00:57:58,151 --> 00:58:00,760
If you have specific
requirements for your program,

1432
00:58:00,760 --> 00:58:04,887
like things like if we just said
implement a search-- sorry--

1433
00:58:04,887 --> 00:58:06,720
implement a sort, you'll
probably want to go

1434
00:58:06,720 --> 00:58:09,950
for one of the ones that
has a best case of n,

1435
00:58:09,950 --> 00:58:12,410
or a lower bound in the best case of n.

1436
00:58:12,410 --> 00:58:14,790
But there might be
certain things like, say,

1437
00:58:14,790 --> 00:58:16,767
swaps are really
expensive for some reason.

1438
00:58:16,767 --> 00:58:18,850
Then you would want to do
bubble sort, because you

1439
00:58:18,850 --> 00:58:20,641
have to do so many
swaps, things like that.

1440
00:58:20,641 --> 00:58:21,710

1441
00:58:21,710 --> 00:58:23,098
Any other-- yes?

1442
00:58:23,098 --> 00:58:25,488
>> STUDENT: Would it be [INAUDIBLE]
to say that [INAUDIBLE]?

1443
00:58:25,488 --> 00:58:30,077

1444
00:58:30,077 --> 00:58:31,910
HANNAH: That's one thing
that would tell you

1445
00:58:31,910 --> 00:58:33,670
if you're looking at the implementation.

1446
00:58:33,670 --> 00:58:35,850
The way I would actually
think about why it's n

1447
00:58:35,850 --> 00:58:40,840
squared is that we have to run
through our array of length n,

1448
00:58:40,840 --> 00:58:42,765
each time making at most, n swaps.

1449
00:58:42,765 --> 00:58:43,980

1450
00:58:43,980 --> 00:58:46,220
And we have to do this process n times.

1451
00:58:46,220 --> 00:58:51,130
>> So when you have to make at most, n
swaps and for n runs through the array,

1452
00:58:51,130 --> 00:58:52,380
there's going to be n squared.

1453
00:58:52,380 --> 00:58:55,480
But yes, this will be revealed
through this double for loop,

1454
00:58:55,480 --> 00:58:59,428
as the question asked-- or
nested for loop, I should say.

1455
00:58:59,428 --> 00:59:00,890
OK?

1456
00:59:00,890 --> 00:59:03,375
>> And then merge sort, which
is the fastest sort we now,

1457
00:59:03,375 --> 00:59:07,560
or that we've covered in CS50,
know that the main algorithm is

1458
00:59:07,560 --> 00:59:10,150
this idea of breaking into
sorted pieces and then

1459
00:59:10,150 --> 00:59:11,980
merging together these sorted bits.

1460
00:59:11,980 --> 00:59:14,170
And will get us log n log n.

1461
00:59:14,170 --> 00:59:17,110
Any questions on searches and
sorts before I pass it on?

1462
00:59:17,110 --> 00:59:19,840

1463
00:59:19,840 --> 00:59:21,040
Let's see.

1464
00:59:21,040 --> 00:59:21,800
>> Oh, linked lists.

1465
00:59:21,800 --> 00:59:23,210
Sorry, I have one more topic.

1466
00:59:23,210 --> 00:59:25,000
OK, awesome, linked lists.

1467
00:59:25,000 --> 00:59:27,900
Problem with the arrays,
they have a fixed size.

1468
00:59:27,900 --> 00:59:30,634
So if you don't know how big
your input is going to be,

1469
00:59:30,634 --> 00:59:32,050
you don't want to create an array.

1470
00:59:32,050 --> 00:59:34,080
Because if we create an
array that is too small,

1471
00:59:34,080 --> 00:59:35,930
we might run into buffer overflow.

1472
00:59:35,930 --> 00:59:38,890
>> So instead, we could do something
with linked lists, which

1473
00:59:38,890 --> 00:59:44,280
allows us to have a dynamically
sized data structure

1474
00:59:44,280 --> 00:59:48,970
that will allow us to store a
more flexible amount of data.

1475
00:59:48,970 --> 00:59:54,030
So within each node in our
linked list, we have two pieces.

1476
00:59:54,030 --> 00:59:56,820
We have the actual value that it stores.

1477
00:59:56,820 --> 00:59:59,530
So that's just the thing you would
see in the array, for example.

1478
00:59:59,530 --> 01:00:04,600
And then we also keep track of a
pointer to the next thing in memory.

1479
01:00:04,600 --> 01:00:06,430
>> Unlike arrays, which
we know are all going

1480
01:00:06,430 --> 01:00:10,890
to be-- array elements are all one
after another in memory-- linked

1481
01:00:10,890 --> 01:00:13,300
lists could be anywhere in memory.

1482
01:00:13,300 --> 01:00:14,590
They're arbitrary locations.

1483
01:00:14,590 --> 01:00:16,410
So if we were to
actually go find them, we

1484
01:00:16,410 --> 01:00:19,770
need to keep track of the
next thing in our list.

1485
01:00:19,770 --> 01:00:22,840
>> And then in order to know
where that list as a whole is,

1486
01:00:22,840 --> 01:00:26,276
all we have to keep track of is the
very first element in our linked list.

1487
01:00:26,276 --> 01:00:27,900
And that'll allow us to follow through.

1488
01:00:27,900 --> 01:00:31,020

1489
01:00:31,020 --> 01:00:33,070
>> So this is how you might define a mode.

1490
01:00:33,070 --> 01:00:36,160
This is a great opportunity
to take advantage of structs.

1491
01:00:36,160 --> 01:00:39,660
Because you have this idea, well,
for a given node, I have two pieces.

1492
01:00:39,660 --> 01:00:41,770
I have the actual value itself.

1493
01:00:41,770 --> 01:00:45,610
And then I have a pointer to the
next element in the linked list.

1494
01:00:45,610 --> 01:00:49,150
So you see, we have an integer n,
which is going to be the actual value,

1495
01:00:49,150 --> 01:00:53,150
and then a pointer to
a node, called next.

1496
01:00:53,150 --> 01:00:56,431
So that's going to be the next
element in our linked list.

1497
01:00:56,431 --> 01:00:56,972
STUDENT: Yes?

1498
01:00:56,972 --> 01:01:01,920
Do you have to specify that
the star is like a struct?

1499
01:01:01,920 --> 01:01:05,620
>> HANNAH: Yes, so since this
is almost like a kind of,

1500
01:01:05,620 --> 01:01:07,980
it seems like a recursive
definition in that we

1501
01:01:07,980 --> 01:01:12,080
need to know what a node is
inside to finding a node.

1502
01:01:12,080 --> 01:01:14,450
Since it doesn't actually
know what a node is completely

1503
01:01:14,450 --> 01:01:17,283
until we get to the end of this--
and after this we can just call it

1504
01:01:17,283 --> 01:01:21,935
a node-- inside of this definition,
we need to call it a struct node.

1505
01:01:21,935 --> 01:01:22,560
Great question.

1506
01:01:22,560 --> 01:01:23,580

1507
01:01:23,580 --> 01:01:25,214
Anything else?

1508
01:01:25,214 --> 01:01:26,198
Yes?

1509
01:01:26,198 --> 01:01:29,150
>> STUDENT: Why do we
have to say node twice?

1510
01:01:29,150 --> 01:01:33,578
Because when we were in [INAUDIBLE]
we just had to do it in semicolon,

1511
01:01:33,578 --> 01:01:37,352
but now we have to find that
struct node? [INAUDIBLE].

1512
01:01:37,352 --> 01:01:39,060
HANNAH: So I believe
in the last example,

1513
01:01:39,060 --> 01:01:42,110
we were just creating anytime you
wanted to use a student after that, you

1514
01:01:42,110 --> 01:01:46,430
had to use struct node--
I'm sorry-- struct student.

1515
01:01:46,430 --> 01:01:51,575
This allowed us to, after the fact, just
use node add a new type, essentially.

1516
01:01:51,575 --> 01:01:53,324

1517
01:01:53,324 --> 01:01:53,990
That make sense?

1518
01:01:53,990 --> 01:01:54,984

1519
01:01:54,984 --> 01:01:57,150
So we'd have to go back and
look at the code before.

1520
01:01:57,150 --> 01:01:59,025
But I would guess that
we didn't use typedef.

1521
01:01:59,025 --> 01:02:02,050
And we asked the question,
why do we need to use typedef?

1522
01:02:02,050 --> 01:02:05,540
Typedef allows us to avoid the
word struct in the beginning.

1523
01:02:05,540 --> 01:02:06,221
Yes?

1524
01:02:06,221 --> 01:02:08,095
STUDENT: What sort of
questions would come up

1525
01:02:08,095 --> 01:02:10,400
in terms in terms of
nodes and linked lists?

1526
01:02:10,400 --> 01:02:15,110
>> HANNAH: So one thing is we could say how
might you search through a linked list?

1527
01:02:15,110 --> 01:02:16,930
OK, because it's a
little more complicated

1528
01:02:16,930 --> 01:02:18,520
than if we're searching
through an array.

1529
01:02:18,520 --> 01:02:21,472
We can just look at element zero,
element one, element two, blah, blah,

1530
01:02:21,472 --> 01:02:21,972
blah.

1531
01:02:21,972 --> 01:02:22,629

1532
01:02:22,629 --> 01:02:24,420
If we want to search
through a linked list,

1533
01:02:24,420 --> 01:02:27,229
we'd actually have to follow
this little maze of pointers.

1534
01:02:27,229 --> 01:02:29,270
So let's actually go
through this really quickly.

1535
01:02:29,270 --> 01:02:30,460

1536
01:02:30,460 --> 01:02:32,860
What we could do in
order to-- let's say we

1537
01:02:32,860 --> 01:02:35,430
want to just iterate through
our entirely linked list.

1538
01:02:35,430 --> 01:02:37,450
We would start at the head.

1539
01:02:37,450 --> 01:02:39,890
And then in order to
move to the next element,

1540
01:02:39,890 --> 01:02:43,680
instead of just incrementing by one
like we might in going through an array,

1541
01:02:43,680 --> 01:02:45,720
we're actually going to
follow the next pointer,

1542
01:02:45,720 --> 01:02:48,360
so we can find where in
memory the next element is.

1543
01:02:48,360 --> 01:02:49,357

1544
01:02:49,357 --> 01:02:51,690
So I know it's not enough to
take all this in right now,

1545
01:02:51,690 --> 01:02:52,650
but you'll have these slides.

1546
01:02:52,650 --> 01:02:54,730
So you can go through
this a little more slowly.

1547
01:02:54,730 --> 01:02:56,890
But essentially, what we want
to do is follow these pointers

1548
01:02:56,890 --> 01:02:58,550
through the entirety of the linked list.

1549
01:02:58,550 --> 01:03:00,258
So this is a question
you might be asked.

1550
01:03:00,258 --> 01:03:01,920

1551
01:03:01,920 --> 01:03:03,980
>> Something to notice with
insertion, let's say

1552
01:03:03,980 --> 01:03:07,925
we wanted to put a new element
at the front of our linked list.

1553
01:03:07,925 --> 01:03:10,800
We have to be very careful
about the order in which we

1554
01:03:10,800 --> 01:03:12,760
reassigned the pointers.

1555
01:03:12,760 --> 01:03:15,230
Because let's say I just said OK.

1556
01:03:15,230 --> 01:03:18,930
Make head point to this new element.

1557
01:03:18,930 --> 01:03:23,550
Just make it point to 1 Then, we've
essentially lost the rest of our list,

1558
01:03:23,550 --> 01:03:25,860
because I don't remember where 2 lives.

1559
01:03:25,860 --> 01:03:27,730
>> So we have to do in a
very specific order.

1560
01:03:27,730 --> 01:03:31,500
First, we make the new
element point to the head.

1561
01:03:31,500 --> 01:03:33,970
And then we make the head
point to the new element.

1562
01:03:33,970 --> 01:03:38,455
So let's see what that looks like
with arrows-- just like that.

1563
01:03:38,455 --> 01:03:42,080
So you first have the new
element point to the old head.

1564
01:03:42,080 --> 01:03:45,990
And now, we have the head
point to the new first element.

1565
01:03:45,990 --> 01:03:47,187
Any questions with this?

1566
01:03:47,187 --> 01:03:49,870

1567
01:03:49,870 --> 01:03:54,350
>> OK here's some code again, something
to look at a little bit later.

1568
01:03:54,350 --> 01:03:58,630
And now I will turn it over to Davin
for GDB and a little bit of practice

1569
01:03:58,630 --> 01:03:59,480
coding on paper.

1570
01:03:59,480 --> 01:04:00,597

1571
01:04:00,597 --> 01:04:01,096
Beautiful.

1572
01:04:01,096 --> 01:04:01,810
>> ROB: And Rob.

1573
01:04:01,810 --> 01:04:02,360
>> HANNAH: Oh, Davin and Rob.

1574
01:04:02,360 --> 01:04:03,055
I'm sorry.

1575
01:04:03,055 --> 01:04:03,596
>> STUDENT: Woo!

1576
01:04:03,596 --> 01:04:08,140

1577
01:04:08,140 --> 01:04:09,110
>> ROB: Thanks.

1578
01:04:09,110 --> 01:04:11,209
>> DAVIN: Do you want to say
everything real quick?

1579
01:04:11,209 --> 01:04:11,875
ROB: Yeah, yeah.

1580
01:04:11,875 --> 01:04:12,845
DAVIN: Once I'm up.

1581
01:04:12,845 --> 01:04:16,240

1582
01:04:16,240 --> 01:04:19,520
OK, while Rob puts the
microphone on, so what's GDB?

1583
01:04:19,520 --> 01:04:23,945
Everyone should have seen GDB in
class and also at office hours.

1584
01:04:23,945 --> 01:04:25,070
And you should be using it.

1585
01:04:25,070 --> 01:04:25,750
So what is GDB?

1586
01:04:25,750 --> 01:04:28,030

1587
01:04:28,030 --> 01:04:28,850
Anybody?

1588
01:04:28,850 --> 01:04:29,540
>> STUDENT: It's a debugger.

1589
01:04:29,540 --> 01:04:30,250
>> DAVIN: It's a debugger.

1590
01:04:30,250 --> 01:04:31,624
And what does it allow you to do?

1591
01:04:31,624 --> 01:04:33,064
Like, why do we like GDB?

1592
01:04:33,064 --> 01:04:34,480
STUDENT: To slow down the program.

1593
01:04:34,480 --> 01:04:36,740
DAVIN: Right, so you can walk
through it like a human pace.

1594
01:04:36,740 --> 01:04:38,490
And so what are some
commands you can do?

1595
01:04:38,490 --> 01:04:40,407
Well, break is probably
your favorite command.

1596
01:04:40,407 --> 01:04:43,240
Because that lets you break the
program and actually walk through it

1597
01:04:43,240 --> 01:04:44,280
line by line.

1598
01:04:44,280 --> 01:04:46,500
>> Run allows you to run it.

1599
01:04:46,500 --> 01:04:48,210
Next, like stepping through.

1600
01:04:48,210 --> 01:04:49,820
What's the between next and step?

1601
01:04:49,820 --> 01:04:52,190

1602
01:04:52,190 --> 01:04:53,190
Wait, say that out loud.

1603
01:04:53,190 --> 01:04:54,060
It was correct.

1604
01:04:54,060 --> 01:04:55,280
>> STUDENT: [INAUDIBLE].

1605
01:04:55,280 --> 01:04:56,190
>> DAVIN: Yes, awesome.

1606
01:04:56,190 --> 01:04:59,210
So like, next and step, if you're--
let's say you have a function you

1607
01:04:59,210 --> 01:04:59,950
define.

1608
01:04:59,950 --> 01:05:03,350
Let's say some in your main function,
and you're just hitting next, next,

1609
01:05:03,350 --> 01:05:03,850
next .

1610
01:05:03,850 --> 01:05:05,910
You're actually going to
execute that function,

1611
01:05:05,910 --> 01:05:07,285
but you're going to jump over it.

1612
01:05:07,285 --> 01:05:09,711
If you hit step, or
s or whatever, you're

1613
01:05:09,711 --> 01:05:11,460
going to actually jump
into that function,

1614
01:05:11,460 --> 01:05:14,110
and then you can hit next
to see the different calls

1615
01:05:14,110 --> 01:05:16,170
inside that particular function.

1616
01:05:16,170 --> 01:05:16,670
Yeah?

1617
01:05:16,670 --> 01:05:18,670
>> STUDENT: Is there a way
to jump, like, back out?

1618
01:05:18,670 --> 01:05:20,750
DAVIN: Finish, yeah,
finish with jump you out.

1619
01:05:20,750 --> 01:05:22,570
So it's going to finish that
function, and then you're

1620
01:05:22,570 --> 01:05:24,153
going to be back in main, for example.

1621
01:05:24,153 --> 01:05:25,250

1622
01:05:25,250 --> 01:05:27,370
Print will print it out one time.

1623
01:05:27,370 --> 01:05:29,381
Something I always use is display.

1624
01:05:29,381 --> 01:05:31,880
Display will print it out
constantly throughout the entirety

1625
01:05:31,880 --> 01:05:32,470
of your program.

1626
01:05:32,470 --> 01:05:33,810
>> For example, if you're
in a for loop, and you

1627
01:05:33,810 --> 01:05:37,018
want to see how something's changing,
and you don't want to, like, constantly

1628
01:05:37,018 --> 01:05:38,940
be doing like print,
print, print, display

1629
01:05:38,940 --> 01:05:43,230
will display that variable
continuously, every time you hit Next.

1630
01:05:43,230 --> 01:05:44,310
And continue.

1631
01:05:44,310 --> 01:05:45,905
So GBD, that's GDB.

1632
01:05:45,905 --> 01:05:47,160

1633
01:05:47,160 --> 01:05:49,180
>> STUDENT: What's the one
where you [INAUDIBLE]?

1634
01:05:49,180 --> 01:05:50,150

1635
01:05:50,150 --> 01:05:50,900
DAVIN: What is it?

1636
01:05:50,900 --> 01:05:52,310

1637
01:05:52,310 --> 01:05:54,390
>> STUDENT: What's the--
the local variables.

1638
01:05:54,390 --> 01:05:55,364

1639
01:05:55,364 --> 01:05:57,780
ROB: There is something actually
like locals or something.

1640
01:05:57,780 --> 01:05:58,140
I can't--

1641
01:05:58,140 --> 01:05:59,930
>> DAVIN: It might be
something like that, yeah.

1642
01:05:59,930 --> 01:06:00,830
>> HANNAH: In the locals?

1643
01:06:00,830 --> 01:06:01,510
>> DAVIN: That's it.

1644
01:06:01,510 --> 01:06:02,134
That's the one.

1645
01:06:02,134 --> 01:06:03,040
ROB: Beautiful.

1646
01:06:03,040 --> 01:06:04,030
>> DAVIN: Yeah.

1647
01:06:04,030 --> 01:06:06,010
>> STUDENT: What does continue do?

1648
01:06:06,010 --> 01:06:08,010
>> DAVIN: It continues-- so it's just
going to continue your programs.

1649
01:06:08,010 --> 01:06:09,843
So if you break and hit
continue, it's going

1650
01:06:09,843 --> 01:06:13,119
to just run that program until
it hits that break again.

1651
01:06:13,119 --> 01:06:14,910
So for example, if you
broke in a function,

1652
01:06:14,910 --> 01:06:16,720
and you're going to do like for
loop or something like that,

1653
01:06:16,720 --> 01:06:19,869
and you hit continue, it's going to
continue and go back to that break.

1654
01:06:19,869 --> 01:06:22,660
Or there's no break, it's going to
continue and finish the program.

1655
01:06:22,660 --> 01:06:25,000
>> ROB: So just like run stops
at the very first breakpoint

1656
01:06:25,000 --> 01:06:27,010
you hit, if you then
hit continue, it'll keep

1657
01:06:27,010 --> 01:06:28,070
going until it's the next breakpoint.

1658
01:06:28,070 --> 01:06:30,111
And then continue will go
to the next breakpoint.

1659
01:06:30,111 --> 01:06:31,264

1660
01:06:31,264 --> 01:06:32,680
DAVIN: Any other questions on GDB?

1661
01:06:32,680 --> 01:06:33,577

1662
01:06:33,577 --> 01:06:35,410
So I think in the past,
we've asked you what

1663
01:06:35,410 --> 01:06:37,690
GDB is and give an
example of some things you

1664
01:06:37,690 --> 01:06:40,770
can do with GDB, so
real simple, but yeah.

1665
01:06:40,770 --> 01:06:42,280
There you go.

1666
01:06:42,280 --> 01:06:43,250
And nodes?

1667
01:06:43,250 --> 01:06:49,571
>> ROB: Yes, so which direction was it?

1668
01:06:49,571 --> 01:06:50,851

1669
01:06:50,851 --> 01:06:51,726
STUDENT: That was it.

1670
01:06:51,726 --> 01:06:52,160
DAVIN: Wait.

1671
01:06:52,160 --> 01:06:52,270
ROB: This guy?

1672
01:06:52,270 --> 01:06:52,936
DAVIN: That one.

1673
01:06:52,936 --> 01:06:54,660
ROB: This guy, oh, I didn't realize.

1674
01:06:54,660 --> 01:06:56,940
So we weren't clear
on what the-- I don't

1675
01:06:56,940 --> 01:06:58,680
know who it was-- but the question.

1676
01:06:58,680 --> 01:07:01,180
We don't know exactly what you
were asking about it, so just

1677
01:07:01,180 --> 01:07:04,800
to clarify something.

1678
01:07:04,800 --> 01:07:07,750
So first, like I said before,
typedef you're always using just

1679
01:07:07,750 --> 01:07:09,305
create a nickname for a type.

1680
01:07:09,305 --> 01:07:13,420
So right here, the nickname we're
creating is for this type struct node.

1681
01:07:13,420 --> 01:07:18,070
>> So first, ignoring this node in the
typedef, so this struct node curly

1682
01:07:18,070 --> 01:07:21,060
brace down to next curly
brace is the struct node type.

1683
01:07:21,060 --> 01:07:23,470
And we need to that node
up there, because we

1684
01:07:23,470 --> 01:07:25,190
need to reference node in here.

1685
01:07:25,190 --> 01:07:29,380
So with this sort of recursive struct,
you need to give this struct a name,

1686
01:07:29,380 --> 01:07:31,340
or else you couldn't
say struct node in here.

1687
01:07:31,340 --> 01:07:33,340
Whereas before with student
when we were typed, I think,

1688
01:07:33,340 --> 01:07:35,423
we didn't have to say
student up there, because we

1689
01:07:35,423 --> 01:07:40,370
didn't have to say struct
student inside the struct itself.

1690
01:07:40,370 --> 01:07:43,730
So it's the recursive that
forces us to say node there.

1691
01:07:43,730 --> 01:07:46,610
>> This node is just the name we're
giving node for the typedef.

1692
01:07:46,610 --> 01:07:48,520
So that node is not
the same as that node.

1693
01:07:48,520 --> 01:07:51,567
But this struct node is the
same as that struct node.

1694
01:07:51,567 --> 01:07:54,150
DAVIN: So whenever you call,
like, node in your main function,

1695
01:07:54,150 --> 01:07:55,350
you're not going to
have to say struct node.

1696
01:07:55,350 --> 01:07:58,360
You can just say node, because
node is a different-- is basically

1697
01:07:58,360 --> 01:07:59,440
you're saying, OK.

1698
01:07:59,440 --> 01:08:01,490
Instead of having to call
struct node in my code,

1699
01:08:01,490 --> 01:08:04,050
I just want to rename it
as node to make it easier.

1700
01:08:04,050 --> 01:08:06,800
>> ROB: If you always
use typedef, then this

1701
01:08:06,800 --> 01:08:11,240
is the only place you're going to have
to declare a variable with struct node

1702
01:08:11,240 --> 01:08:11,740
star, yeah.

1703
01:08:11,740 --> 01:08:14,650

1704
01:08:14,650 --> 01:08:20,801
>> DAVIN: OK, so the last part
is hard to teach because--

1705
01:08:20,801 --> 01:08:22,185

1706
01:08:22,185 --> 01:08:22,685
ROB: What?

1707
01:08:22,685 --> 01:08:24,098

1708
01:08:24,098 --> 01:08:25,649
>> DAVIN: Because it's coding on paper.

1709
01:08:25,649 --> 01:08:28,689
So every year we have
code on paper questions.

1710
01:08:28,689 --> 01:08:32,510
So I think last year, 12 out of
80 points were code on paper.

1711
01:08:32,510 --> 01:08:36,720
Year before that, 10 out of 80,
year before that, 20 out of 100,

1712
01:08:36,720 --> 01:08:37,939
so quite a few of these.

1713
01:08:37,939 --> 01:08:40,970
So you're going to have to be able
to code up these functions by hand.

1714
01:08:40,970 --> 01:08:45,340
>> So I figured we might go through a
couple of them and see how people do,

1715
01:08:45,340 --> 01:08:47,340
kind of walk through
them slowly with people.

1716
01:08:47,340 --> 01:08:48,790

1717
01:08:48,790 --> 01:08:52,420
So generally, strlen and
atoi have been very popular.

1718
01:08:52,420 --> 01:08:55,670
Last year, I think we had
GetPositiveInt and RandomInt.

1719
01:08:55,670 --> 01:08:58,591
But pow, so power, also
a positive one too.

1720
01:08:58,591 --> 01:09:00,965
Let's just go through maybe
one or two of these together.

1721
01:09:00,965 --> 01:09:02,510

1722
01:09:02,510 --> 01:09:03,729
What do people want to see?

1723
01:09:03,729 --> 01:09:05,037

1724
01:09:05,037 --> 01:09:05,767
>> STUDENT: Atoi.

1725
01:09:05,767 --> 01:09:06,350
STUDENT: Yeah.

1726
01:09:06,350 --> 01:09:06,859
DAVIN: Atoi?

1727
01:09:06,859 --> 01:09:07,800
STUDENT: [INAUDIBLE].

1728
01:09:07,800 --> 01:09:09,682
DAVIN: OK, I'm going
to do it on the board.

1729
01:09:09,682 --> 01:09:11,765
Do you have a preference
if I do it here or there?

1730
01:09:11,765 --> 01:09:13,580

1731
01:09:13,580 --> 01:09:14,550
There, Gabe says there.

1732
01:09:14,550 --> 01:09:16,729

1733
01:09:16,729 --> 01:09:19,580
>> ROB: And this is general thoughts
on these coding questions.

1734
01:09:19,580 --> 01:09:21,705
Try to write something.

1735
01:09:21,705 --> 01:09:22,580
Don't leave it blank.

1736
01:09:22,580 --> 01:09:23,080
>> DAVIN: Yes.

1737
01:09:23,080 --> 01:09:25,520
ROB: If you can get the
return type correct,

1738
01:09:25,520 --> 01:09:27,090
or maybe we might give it to
you, but if you can, like,

1739
01:09:27,090 --> 01:09:30,256
write the general function signature,
If you can get the base cases correct,

1740
01:09:30,256 --> 01:09:32,244
or corner cases, or
remembering check for null,

1741
01:09:32,244 --> 01:09:34,160
as long as you have some
things, then maybe we

1742
01:09:34,160 --> 01:09:35,880
can give you a couple
points for the problem.

1743
01:09:35,880 --> 01:09:36,810
Don't just leave it blank.

1744
01:09:36,810 --> 01:09:38,560
>> DAVIN: Yes, and if you
are just completely

1745
01:09:38,560 --> 01:09:40,580
stumped at how to
actually turn into code.

1746
01:09:40,580 --> 01:09:43,140
If you write pseudocode,
that's pretty good too.

1747
01:09:43,140 --> 01:09:46,390
So it's like, it's a six point question,
and you write the correct pseudocode,

1748
01:09:46,390 --> 01:09:47,858
you'll get at least two points.

1749
01:09:47,858 --> 01:09:49,149
So don't just leave them blank.

1750
01:09:49,149 --> 01:09:50,279
Try to put something.

1751
01:09:50,279 --> 01:09:51,770
>> ROB: It needs to be the
correct pseudocode, though.

1752
01:09:51,770 --> 01:09:52,270
>> DAVIN: Yes.

1753
01:09:52,270 --> 01:09:55,381
ROB: So we are generally are less
lenient with bugs in pseudocode.

1754
01:09:55,381 --> 01:09:57,130
DAVIN: OK, so you guys
wanted to see atoi.

1755
01:09:57,130 --> 01:09:58,480

1756
01:09:58,480 --> 01:10:02,820
OK, so just really--
so what you want to do

1757
01:10:02,820 --> 01:10:04,969
is you're going to be
given some kind of number.

1758
01:10:04,969 --> 01:10:07,010
But this number is not
going to be an int, right?

1759
01:10:07,010 --> 01:10:08,574
What's it going to be?

1760
01:10:08,574 --> 01:10:09,480
>> STUDENT: [INAUDIBLE].

1761
01:10:09,480 --> 01:10:11,146
>> DAVIN: It's going to be a string, right?

1762
01:10:11,146 --> 01:10:13,160
So if you were given
a string-- let's say--

1763
01:10:13,160 --> 01:10:15,228
>> ROB: Should I pull up an editor?

1764
01:10:15,228 --> 01:10:16,200
I can pull up--

1765
01:10:16,200 --> 01:10:16,800
>> DAVIN: Oh, you want to do it on--

1766
01:10:16,800 --> 01:10:17,420
>> ROB: Would you prefer the board?

1767
01:10:17,420 --> 01:10:18,800
>> DAVIN: What do you want to do?

1768
01:10:18,800 --> 01:10:19,900
I mean, do you want to do it by hand?

1769
01:10:19,900 --> 01:10:21,460
Or do you want to do it by computer?

1770
01:10:21,460 --> 01:10:22,180
>> ROB: Do it by hand.

1771
01:10:22,180 --> 01:10:22,805
>> DAVIN: [LAUGHS]

1772
01:10:22,805 --> 01:10:23,950
ROB: Do it by hand.

1773
01:10:23,950 --> 01:10:25,469
>> DAVIN: OK, so it's going to be atoi.

1774
01:10:25,469 --> 01:10:27,760
So what's it-- I mean, we'll
probably give this to you.

1775
01:10:27,760 --> 01:10:29,106
But what's it going to return?

1776
01:10:29,106 --> 01:10:29,452
>> STUDENT: Int.

1777
01:10:29,452 --> 01:10:31,076
>> DAVIN: It's going to return int, right?

1778
01:10:31,076 --> 01:10:33,772
So-- I don't want to do it there.

1779
01:10:33,772 --> 01:10:34,510
I'll do it here.

1780
01:10:34,510 --> 01:10:36,596
>> ROB: You can pull it down
and then push up on it.

1781
01:10:36,596 --> 01:10:38,500

1782
01:10:38,500 --> 01:10:40,385
>> DAVIN: yeah.

1783
01:10:40,385 --> 01:10:43,880
[LAUGHS] Game change.

1784
01:10:43,880 --> 01:10:50,950
OK, so it's going to be int atoi,
and what's it going to take?

1785
01:10:50,950 --> 01:10:52,180

1786
01:10:52,180 --> 01:10:57,780
A char star, so just a
string, star s, like that.

1787
01:10:57,780 --> 01:10:59,240
>> ROB: Nice star, nice.

1788
01:10:59,240 --> 01:11:02,582

1789
01:11:02,582 --> 01:11:04,040
DAVIN: This might not be there, OK.

1790
01:11:04,040 --> 01:11:04,540
ROB: Yeah.

1791
01:11:04,540 --> 01:11:06,670
DAVIN: OK, so the first
thing you want to do-- I

1792
01:11:06,670 --> 01:11:08,490
don't know if anybody looked
at the practice solutions--

1793
01:11:08,490 --> 01:11:10,150
but what you're going
to want to do is you're

1794
01:11:10,150 --> 01:11:11,570
going to want to have
a loop, because you're

1795
01:11:11,570 --> 01:11:14,100
going to want to actually
step through this string.

1796
01:11:14,100 --> 01:11:18,880
So helpful-- so let's say
we're going to a for loop,

1797
01:11:18,880 --> 01:11:22,270
and we're going to step through
every element of the string.

1798
01:11:22,270 --> 01:11:23,470
How long is that?

1799
01:11:23,470 --> 01:11:26,464
How many times are we going
to iterate in that for loop?

1800
01:11:26,464 --> 01:11:27,130
STUDENT: Sterln?

1801
01:11:27,130 --> 01:11:27,963
DAVIN: Sterln, yeah.

1802
01:11:27,963 --> 01:11:29,350

1803
01:11:29,350 --> 01:11:41,294
So let's say int length equals sterln s.

1804
01:11:41,294 --> 01:11:44,240

1805
01:11:44,240 --> 01:11:48,740
And just curious, why is it always kind
of better to do this outside of loops?

1806
01:11:48,740 --> 01:11:52,277
Like, why is it better to call
this function outside of a loop?

1807
01:11:52,277 --> 01:11:53,360
Just a quick sanity check?

1808
01:11:53,360 --> 01:11:55,810

1809
01:11:55,810 --> 01:11:56,311
Yeah?

1810
01:11:56,311 --> 01:11:58,268
STUDENT: So you don't
have to keep checking it.

1811
01:11:58,268 --> 01:11:59,400
You can just [INAUDIBLE].

1812
01:11:59,400 --> 01:12:01,560
>> DAVIN: Exactly, so yeah,
exactly what she said.

1813
01:12:01,560 --> 01:12:03,101
So we don't have to keep checking it.

1814
01:12:03,101 --> 01:12:05,690
So for example, if I'm calling
this function inside a loop,

1815
01:12:05,690 --> 01:12:08,050
then I'm going to keep calling
this function multiple times.

1816
01:12:08,050 --> 01:12:10,080
And that's going to decrease
the efficiency of your program.

1817
01:12:10,080 --> 01:12:12,370
So it's always useful
to declare it outside.

1818
01:12:12,370 --> 01:12:14,370
>> ROB: That's said, on
any of these problems,

1819
01:12:14,370 --> 01:12:17,940
pretty much as long as you get a
working solution, you get full credit.

1820
01:12:17,940 --> 01:12:20,820
So don't worry if your design
is absolutely horrendous.

1821
01:12:20,820 --> 01:12:22,120

1822
01:12:22,120 --> 01:12:25,230
It might make us upset
reading your code.

1823
01:12:25,230 --> 01:12:28,160
But as long as it works,
you'll get the points.

1824
01:12:28,160 --> 01:12:29,302
>> DAVIN: Yes.

1825
01:12:29,302 --> 01:12:31,260
OK, so then I'm going to
declare some variable.

1826
01:12:31,260 --> 01:12:33,900
It's just going to call int sum.

1827
01:12:33,900 --> 01:12:37,031
And I'm going to set this
equal to zero, like that.

1828
01:12:37,031 --> 01:12:38,780
And that's just going
to be a placeholder.

1829
01:12:38,780 --> 01:12:40,960
So that's going to be
what I'm going to return.

1830
01:12:40,960 --> 01:12:43,730
So I'm going to eventually
return sum out of this program.

1831
01:12:43,730 --> 01:12:44,980
So I have these two variables.

1832
01:12:44,980 --> 01:12:45,563
I have length.

1833
01:12:45,563 --> 01:12:46,500
I have sum.

1834
01:12:46,500 --> 01:12:48,290
And now let's jump into our string.

1835
01:12:48,290 --> 01:12:49,510
>> So lets have our for loop.

1836
01:12:49,510 --> 01:13:06,520
So four int I equals 0 w , while
I is less than length I plus plus.

1837
01:13:06,520 --> 01:13:07,150
And now--

1838
01:13:07,150 --> 01:13:10,920

1839
01:13:10,920 --> 01:13:11,420
ROB: Nice.

1840
01:13:11,420 --> 01:13:14,030
DAVIN: OK, and now here
comes the meat of our code.

1841
01:13:14,030 --> 01:13:17,380
So you can actually do
this basically in one line.

1842
01:13:17,380 --> 01:13:20,702
So does anybody have an idea
of what we're going to do next?

1843
01:13:20,702 --> 01:13:23,680

1844
01:13:23,680 --> 01:13:25,380
OK, so that's OK.

1845
01:13:25,380 --> 01:13:35,860
So we're doing to say sum equals--
let me scoot this over-- sum

1846
01:13:35,860 --> 01:13:50,010
equals sum times 10 plus-- we're
going to take s I minus one

1847
01:13:50,010 --> 01:13:54,787
quote 0 one quote done, like that.

1848
01:13:54,787 --> 01:13:55,620
ROB: Very intuitive.

1849
01:13:55,620 --> 01:13:56,980

1850
01:13:56,980 --> 01:13:57,880
>> DAVIN: Crushed it.

1851
01:13:57,880 --> 01:14:01,438
OK, so someone-- I got it, I got it.

1852
01:14:01,438 --> 01:14:03,680

1853
01:14:03,680 --> 01:14:06,960
OK, so this is clearly going up.

1854
01:14:06,960 --> 01:14:08,320

1855
01:14:08,320 --> 01:14:09,450
What does this mean?

1856
01:14:09,450 --> 01:14:12,120
So does anybody know what this means?

1857
01:14:12,120 --> 01:14:13,826
Can everybody see this?

1858
01:14:13,826 --> 01:14:16,088
No, nobody can see this, OK.

1859
01:14:16,088 --> 01:14:17,390

1860
01:14:17,390 --> 01:14:18,340
I'm going to--

1861
01:14:18,340 --> 01:14:20,506
>> ROB: I'm going to write the
formula just right here.

1862
01:14:20,506 --> 01:14:23,140
DAVIN: OK, Rob's going to do it
on the computer, which is fun.

1863
01:14:23,140 --> 01:14:26,889

1864
01:14:26,889 --> 01:14:27,514
ROB: Oh my God.

1865
01:14:27,514 --> 01:14:34,340

1866
01:14:34,340 --> 01:14:35,010
Or I won't.

1867
01:14:35,010 --> 01:14:36,288

1868
01:14:36,288 --> 01:14:36,954
DAVIN: Stand by.

1869
01:14:36,954 --> 01:14:42,300

1870
01:14:42,300 --> 01:14:44,260
STUDENT: I have a question.

1871
01:14:44,260 --> 01:14:45,348
DAVIN: Yeah, sure.

1872
01:14:45,348 --> 01:14:46,223
STUDENT: [INAUDIBLE]?

1873
01:14:46,223 --> 01:14:52,529

1874
01:14:52,529 --> 01:14:54,570
DAVIN: OK, so it actually,
like, just in general,

1875
01:14:54,570 --> 01:14:56,710
if you were to put, like,
in this declaration int

1876
01:14:56,710 --> 01:14:59,770
I equals 0 comma length
equals sterln, that--

1877
01:14:59,770 --> 01:15:01,200
>> STUDENT: [INAUDIBLE].

1878
01:15:01,200 --> 01:15:03,585
>> DAVIN: That's fine, because that--

1879
01:15:03,585 --> 01:15:05,543
STUDENT: Why would you
even need to use length?

1880
01:15:05,543 --> 01:15:08,620
Why couldn't we just [INAUDIBLE] sterln
s, like the whole time [INAUDIBLE]?

1881
01:15:08,620 --> 01:15:09,460
>> DAVIN: You mean right here?

1882
01:15:09,460 --> 01:15:10,001
>> STUDENT: Yes.

1883
01:15:10,001 --> 01:15:12,630
DAVIN: Because every
time this for loop runs,

1884
01:15:12,630 --> 01:15:14,295
it's going to evaluate this condition.

1885
01:15:14,295 --> 01:15:14,920
STUDENT: Right.

1886
01:15:14,920 --> 01:15:16,836
DAVIN: And if you have
sterln there, then it's

1887
01:15:16,836 --> 01:15:19,510
going to have to actually call
that function every single time.

1888
01:15:19,510 --> 01:15:21,090
So instead of just
comparing it to an int,

1889
01:15:21,090 --> 01:15:23,548
you're going to be calling a
function and then comparing it

1890
01:15:23,548 --> 01:15:24,510
to the return value.

1891
01:15:24,510 --> 01:15:25,860
Yeah, so it's just, yeah.

1892
01:15:25,860 --> 01:15:28,860

1893
01:15:28,860 --> 01:15:30,770
>> Nice, OK, so now everybody can see it.

1894
01:15:30,770 --> 01:15:33,400
What does-- this is like, this is it.

1895
01:15:33,400 --> 01:15:34,580
This is the jam, right here.

1896
01:15:34,580 --> 01:15:37,030

1897
01:15:37,030 --> 01:15:37,930
What does that mean?

1898
01:15:37,930 --> 01:15:39,250

1899
01:15:39,250 --> 01:15:39,970
What am I doing?

1900
01:15:39,970 --> 01:15:41,890

1901
01:15:41,890 --> 01:15:42,880
Yeah, an idea?

1902
01:15:42,880 --> 01:15:43,482
Yeah?

1903
01:15:43,482 --> 01:15:45,692
>> STUDENT: Well, so when
you're entering an array,

1904
01:15:45,692 --> 01:15:47,525
you're going to be going
from left to right,

1905
01:15:47,525 --> 01:15:51,786
so you're going to be going in
decimal from down the [INAUDIBLE].

1906
01:15:51,786 --> 01:15:52,410
DAVIN: Exactly.

1907
01:15:52,410 --> 01:15:55,063
STUDENT: So each one
you have to multiply

1908
01:15:55,063 --> 01:15:59,490
what you saw as the value of the int by
the time you get to move that over one.

1909
01:15:59,490 --> 01:16:01,590
>> DAVIN: Perfect, perfect,
so for example, let's

1910
01:16:01,590 --> 01:16:05,376
say I gave you-- I'm
going to write over here.

1911
01:16:05,376 --> 01:16:06,480
No, I'm not.

1912
01:16:06,480 --> 01:16:08,640
I'm going to write over here.

1913
01:16:08,640 --> 01:16:12,080
Let's say I gave you 76, right?

1914
01:16:12,080 --> 01:16:13,380
Let's say I give you 76.

1915
01:16:13,380 --> 01:16:15,360
That's a string to begin with, OK?

1916
01:16:15,360 --> 01:16:16,840
>> So length is what?

1917
01:16:16,840 --> 01:16:18,060

1918
01:16:18,060 --> 01:16:19,060
2, right?

1919
01:16:19,060 --> 01:16:20,290
Sum is 0.

1920
01:16:20,290 --> 01:16:21,600
Then we jump in our for loop.

1921
01:16:21,600 --> 01:16:24,187
OK, the first iteration of
this, what's it going to be?

1922
01:16:24,187 --> 01:16:25,270
It's going to be sum is 0.

1923
01:16:25,270 --> 01:16:27,180
So sum times 10 0.

1924
01:16:27,180 --> 01:16:28,500
That's meaningless.

1925
01:16:28,500 --> 01:16:29,880
Then what does this do?

1926
01:16:29,880 --> 01:16:30,845

1927
01:16:30,845 --> 01:16:31,720
STUDENT: [INAUDIBLE].

1928
01:16:31,720 --> 01:16:33,110

1929
01:16:33,110 --> 01:16:37,430
>> DAVIN: It's going to turn that
character into an integer, right?

1930
01:16:37,430 --> 01:16:42,160
It's kind of like with your
problem set-- this light--

1931
01:16:42,160 --> 01:16:44,170
it's kind of like with
problem set to Visioneer.

1932
01:16:44,170 --> 01:16:45,980
You're dealing with ASCII values.

1933
01:16:45,980 --> 01:16:48,520
So if I give you, like, a
seven, but it's a character,

1934
01:16:48,520 --> 01:16:50,965
and you want to know,
OK, what digit is that?

1935
01:16:50,965 --> 01:16:53,540

1936
01:16:53,540 --> 01:16:54,910
Yeah, you could, yeah.

1937
01:16:54,910 --> 01:16:55,900
So what digit is that?

1938
01:16:55,900 --> 01:16:59,550
You could subtract 0 from it, but you
have to subtract 0, the character.

1939
01:16:59,550 --> 01:17:01,425
>> And where some people
get tripped up, they're

1940
01:17:01,425 --> 01:17:04,260
like, OK, well, do I have to know
the ASCII values for this quiz?

1941
01:17:04,260 --> 01:17:06,218
No, you definitely don't
need to know the ASCII

1942
01:17:06,218 --> 01:17:09,520
values of, like, lowercase
a, uppercase A, zero.

1943
01:17:09,520 --> 01:17:12,060
>> ROB: There is no reason to ever
put this on the cheat sheet.

1944
01:17:12,060 --> 01:17:14,226
>> DAVIN: Definitely do not
waste your space with this.

1945
01:17:14,226 --> 01:17:18,090
You can literally-- just instead
of saying 48, like right up

1946
01:17:18,090 --> 01:17:24,630
there, that is equivalent to
saying one, one apostrophe,

1947
01:17:24,630 --> 01:17:27,680
like that, exactly the same.

1948
01:17:27,680 --> 01:17:34,106
>> ROB: You could almost think
of it as if-- God, I need my,

1949
01:17:34,106 --> 01:17:37,490
oops-- you could almost think of it
as if we have something like that hash

1950
01:17:37,490 --> 01:17:39,755
define 0 as 48.

1951
01:17:39,755 --> 01:17:41,320

1952
01:17:41,320 --> 01:17:42,030
That won't work.

1953
01:17:42,030 --> 01:17:45,502
But think of it as single quote 0
single quote, and for all characters.

1954
01:17:45,502 --> 01:17:47,960
Think of it as a constant that
represents that ASCII value.

1955
01:17:47,960 --> 01:17:49,080
>> DAVIN: Yes.

1956
01:17:49,080 --> 01:17:52,820
OK, so the first time through, so
with 76-- so the first time through,

1957
01:17:52,820 --> 01:17:57,260
this is just the character
7 minus the character 0,

1958
01:17:57,260 --> 01:18:00,420
and those are seven
integers-- well, those

1959
01:18:00,420 --> 01:18:04,030
are seven spaces away from each
other on the ASCII chart or whatever.

1960
01:18:04,030 --> 01:18:06,770
So that's going to return an int of 7.

1961
01:18:06,770 --> 01:18:08,720
So now, sum equals 7.

1962
01:18:08,720 --> 01:18:10,830
>> OK, well, let's jump
into this for loop again.

1963
01:18:10,830 --> 01:18:13,010
OK, now it's sum times 10.

1964
01:18:13,010 --> 01:18:15,800
So you're effectively
moving the 7 to the left.

1965
01:18:15,800 --> 01:18:17,542
Does that make sense?

1966
01:18:17,542 --> 01:18:19,250
You're effectively
moving it to the left.

1967
01:18:19,250 --> 01:18:21,790
>> And then you add-- this
is going to be 6 minus 0.

1968
01:18:21,790 --> 01:18:22,650
That's 6.

1969
01:18:22,650 --> 01:18:24,752
So it's going to be 70 plus 6.

1970
01:18:24,752 --> 01:18:25,996
76, that's your number.

1971
01:18:25,996 --> 01:18:28,370
So regardless of what number
I gave you, it's slowly just

1972
01:18:28,370 --> 01:18:31,610
going to shift the larger values
to the left, 1 factor of 10

1973
01:18:31,610 --> 01:18:35,525
each time in the for loop,
and then add on as necessary.

1974
01:18:35,525 --> 01:18:37,350

1975
01:18:37,350 --> 01:18:37,865
>> In the back?

1976
01:18:37,865 --> 01:18:40,240
STUDENT: We don't have to do
any checking in the program?

1977
01:18:40,240 --> 01:18:41,580

1978
01:18:41,580 --> 01:18:44,302
>> ROB: So as far as checking
goes for the program,

1979
01:18:44,302 --> 01:18:46,510
we would tell you pretty
much what you need to check.

1980
01:18:46,510 --> 01:18:48,670
If we don't tell you
anything, then generally

1981
01:18:48,670 --> 01:18:50,320
assume you have to check most things.

1982
01:18:50,320 --> 01:18:54,772
Like you might, just to be safe, you
should probably check hey, is s null?

1983
01:18:54,772 --> 01:18:56,230
Then I have no idea what to return.

1984
01:18:56,230 --> 01:18:58,814
But we would tell you
this sort of thing.

1985
01:18:58,814 --> 01:18:59,480
0, I don't know.

1986
01:18:59,480 --> 01:19:02,786
>> DAVIN: And why would you want
to recheck if s equals null?

1987
01:19:02,786 --> 01:19:03,660
STUDENT: [INAUDIBLE].

1988
01:19:03,660 --> 01:19:04,880
DAVIN: Because of char star.

1989
01:19:04,880 --> 01:19:05,510
It's a pointer.

1990
01:19:05,510 --> 01:19:09,240
So a perfectly acceptable
declaration, I could say, OK,

1991
01:19:09,240 --> 01:19:11,917
s equals null, because it
could be a pointer to null.

1992
01:19:11,917 --> 01:19:14,250
So whenever you have pointers
in your path in like this,

1993
01:19:14,250 --> 01:19:15,420
you should probably check.

1994
01:19:15,420 --> 01:19:18,461
Because if you don't check that, and
then you then go into your for loop,

1995
01:19:18,461 --> 01:19:20,100
and you're doing-- scoot down.

1996
01:19:20,100 --> 01:19:21,980

1997
01:19:21,980 --> 01:19:22,920
Scoot down.

1998
01:19:22,920 --> 01:19:23,860
>> ROB: Sorry, that's it.

1999
01:19:23,860 --> 01:19:25,860
>> DAVIN: And so, like, if
it is null, and then you

2000
01:19:25,860 --> 01:19:28,267
do this, what error
are you going to get?

2001
01:19:28,267 --> 01:19:29,850
STUDENT: You're going get a set fault.

2002
01:19:29,850 --> 01:19:31,250
DAVIN: You're going to set
fault, right, because you're

2003
01:19:31,250 --> 01:19:32,616
trying to index into null.

2004
01:19:32,616 --> 01:19:35,240
So you're going to try to index
into memory that you don't own.

2005
01:19:35,240 --> 01:19:39,550
So this, if this is null, and
you do this, you'll cycle.

2006
01:19:39,550 --> 01:19:43,656
>> ROB: I also think on the exam in which
we asked this question, we tell you

2007
01:19:43,656 --> 01:19:45,655
that you can just assume
it's a positive number.

2008
01:19:45,655 --> 01:19:48,270
Because atoi is also expected
to handle negative numbers,

2009
01:19:48,270 --> 01:19:49,686
so you would have to special case.

2010
01:19:49,686 --> 01:19:53,080
Hey, is the first character
a dash, in which case, OK,

2011
01:19:53,080 --> 01:19:54,839
now it's a negative integer.

2012
01:19:54,839 --> 01:19:56,380
We'll tell you these sorts of things.

2013
01:19:56,380 --> 01:19:58,005
We'll tell you what you need to handle.

2014
01:19:58,005 --> 01:19:59,310
DAVIN: Yes.

2015
01:19:59,310 --> 01:20:02,530
So I'm sure some people might have--
if you started looking at old exams,

2016
01:20:02,530 --> 01:20:03,900
you've seen sterln.

2017
01:20:03,900 --> 01:20:05,120
That's a popular one.

2018
01:20:05,120 --> 01:20:09,790
And I think in sterln, you had to
do this check for null, the return

2019
01:20:09,790 --> 01:20:10,950
0 or something like that.

2020
01:20:10,950 --> 01:20:11,940
Like, you had to check for null.

2021
01:20:11,940 --> 01:20:14,230
And if you didn't, that
was point off on the quiz.

2022
01:20:14,230 --> 01:20:16,750

2023
01:20:16,750 --> 01:20:19,500
So anyway, does everybody
feel OK with atoi?

2024
01:20:19,500 --> 01:20:21,112

2025
01:20:21,112 --> 01:20:22,820
Does anybody want to
go over parts again?

2026
01:20:22,820 --> 01:20:23,815

2027
01:20:23,815 --> 01:20:25,565
ROB: Oh yeah, I think
we also tell you you

2028
01:20:25,565 --> 01:20:28,565
can assume that everything is-- that
they're actually entering a number,

2029
01:20:28,565 --> 01:20:32,821
that you don't have to worry about,
like, letters being in the string, so.

2030
01:20:32,821 --> 01:20:33,320
DAVIN: Yeah.

2031
01:20:33,320 --> 01:20:33,922
Yes?

2032
01:20:33,922 --> 01:20:35,713
STUDENT: Can you go
over one more time when

2033
01:20:35,713 --> 01:20:37,860
you use double quote and single quote?

2034
01:20:37,860 --> 01:20:41,290
>> DAVIN: Sure, so double quotes, very
simply, is double quotes are strings.

2035
01:20:41,290 --> 01:20:43,370
So if you double quote
anything, that's a string.

2036
01:20:43,370 --> 01:20:48,270
So, like, if I had this 0 over here,
and I did this, that's a string.

2037
01:20:48,270 --> 01:20:50,060
That's no longer a character.

2038
01:20:50,060 --> 01:20:54,816
So I can't find this value on my ASCII
chart, because it's a string, yeah.

2039
01:20:54,816 --> 01:20:57,770

2040
01:20:57,770 --> 01:20:59,480
>> OK, any other questions?

2041
01:20:59,480 --> 01:21:00,405
Yes?

2042
01:21:00,405 --> 01:21:02,345
>> STUDENT: So you've
already answered this,

2043
01:21:02,345 --> 01:21:05,255
but like, when we're actually
writing this on the quiz,

2044
01:21:05,255 --> 01:21:08,165
do you want us to write with
slashes zeroes [INAUDIBLE]?

2045
01:21:08,165 --> 01:21:11,041

2046
01:21:11,041 --> 01:21:11,540
DAVIN: No.

2047
01:21:11,540 --> 01:21:13,800
The question was should you
put a slash through the zeros

2048
01:21:13,800 --> 01:21:14,890
to indicate if they're zeros?

2049
01:21:14,890 --> 01:21:15,890
No, we'll figure it out.

2050
01:21:15,890 --> 01:21:16,940

2051
01:21:16,940 --> 01:21:19,530
Yeah, thanks, they're good.

2052
01:21:19,530 --> 01:21:20,860
OK, anything else?

2053
01:21:20,860 --> 01:21:25,060
Does anybody want to-- so I think
we've run a little bit over time.

2054
01:21:25,060 --> 01:21:27,305
Do you want to see another one, or?

2055
01:21:27,305 --> 01:21:28,096
STUDENT: RandomInt.

2056
01:21:28,096 --> 01:21:29,230

2057
01:21:29,230 --> 01:21:30,750
>> DAVIN: RandomInt, OK, exactly.

2058
01:21:30,750 --> 01:21:32,975
So let's do RandomInt.

2059
01:21:32,975 --> 01:21:34,395

2060
01:21:34,395 --> 01:21:35,270
I'll do it over here.

2061
01:21:35,270 --> 01:21:36,770

2062
01:21:36,770 --> 01:21:39,210
So RandomInt is actually much simpler.

2063
01:21:39,210 --> 01:21:43,578
I think atoi is probably the hardest one
that we've asked in the previous years.

2064
01:21:43,578 --> 01:21:44,453
STUDENT: [INAUDIBLE].

2065
01:21:44,453 --> 01:21:46,660

2066
01:21:46,660 --> 01:21:47,161
>> DAVIN: What?

2067
01:21:47,161 --> 01:21:49,493
ROB: I'm seeing if it's kind
of viewable from over here.

2068
01:21:49,493 --> 01:21:50,040
DAVIN: Is it?

2069
01:21:50,040 --> 01:21:52,500
ROB: I don't think it's going-- I think
it's going to run off to the right.

2070
01:21:52,500 --> 01:21:53,791
DAVIN: OK, so I'll do this one.

2071
01:21:53,791 --> 01:21:56,250
And then you just put it on the screen.

2072
01:21:56,250 --> 01:21:57,150
>> ROB: All right.

2073
01:21:57,150 --> 01:21:58,190
>> DAVIN: You want to be my scribe?

2074
01:21:58,190 --> 01:21:58,600
>> ROB: Yeah.

2075
01:21:58,600 --> 01:21:59,100
>> DAVIN: Nice.

2076
01:21:59,100 --> 01:22:01,210

2077
01:22:01,210 --> 01:22:02,727
OK, can I erase this?

2078
01:22:02,727 --> 01:22:04,188
>> STUDENT: Yeah.

2079
01:22:04,188 --> 01:22:05,162
>> DAVIN: That's so hard.

2080
01:22:05,162 --> 01:22:10,032

2081
01:22:10,032 --> 01:22:12,062
(SINGING) You're doing
what you're doing.

2082
01:22:12,062 --> 01:22:14,454
And doing what you don't.

2083
01:22:14,454 --> 01:22:14,954
All right.

2084
01:22:14,954 --> 01:22:19,790

2085
01:22:19,790 --> 01:22:22,930
>> OK, if I remember correctly, on
the quiz the RandomInt was like,

2086
01:22:22,930 --> 01:22:26,190
OK, I'm going to give you two
numbers, like an a and a b.

2087
01:22:26,190 --> 01:22:30,380
And I want you to give me a
RandomInt between those numbers.

2088
01:22:30,380 --> 01:22:33,440
So RandomInt is going
to take two numbers--

2089
01:22:33,440 --> 01:22:41,690
so RandomInt-- and it's
going to return an int.

2090
01:22:41,690 --> 01:22:42,930
>> So what's the return value?

2091
01:22:42,930 --> 01:22:44,151
I just told you.

2092
01:22:44,151 --> 01:22:44,650
Int, right?

2093
01:22:44,650 --> 01:22:46,400

2094
01:22:46,400 --> 01:22:49,260
Like this, and then it's
going to take two ints.

2095
01:22:49,260 --> 01:22:56,301
So it's going to take int
a and int b, like that.

2096
01:22:56,301 --> 01:22:58,217
So what RandomInt is
going to do is it's going

2097
01:22:58,217 --> 01:23:02,440
to return some random value
in between these two values.

2098
01:23:02,440 --> 01:23:05,140
So it's going to be greater
than a, less than b.

2099
01:23:05,140 --> 01:23:09,020
So I think you can probably assume that
a is the smaller of the two values.

2100
01:23:09,020 --> 01:23:12,210
So if we're dealing with
randomness, what function

2101
01:23:12,210 --> 01:23:14,825
have we seen that
gives us random things?

2102
01:23:14,825 --> 01:23:15,450
STUDENT: Drand.

2103
01:23:15,450 --> 01:23:16,506
DAVIN: Drand, exactly.

2104
01:23:16,506 --> 01:23:18,630
So you're going to probably
want to use your drand.

2105
01:23:18,630 --> 01:23:19,940

2106
01:23:19,940 --> 01:23:29,160
So you can say int random, and we'll
just say it equals 0 right now.

2107
01:23:29,160 --> 01:23:30,170

2108
01:23:30,170 --> 01:23:38,690
And they're we're going to say,
OK, random equals drand 48.

2109
01:23:38,690 --> 01:23:39,747

2110
01:23:39,747 --> 01:23:40,830
And what does this return?

2111
01:23:40,830 --> 01:23:43,742
What does this function give you?

2112
01:23:43,742 --> 01:23:45,610
>> STUDENT: Between 0 and 1.

2113
01:23:45,610 --> 01:23:47,870
>> DAVIN: Yeah, between 0 and 1.

2114
01:23:47,870 --> 01:23:48,890
So it's going to be--

2115
01:23:48,890 --> 01:23:51,070
>> ROB: And this is-- I think
we would tell you this.

2116
01:23:51,070 --> 01:23:52,670
Like, you can use drand 48.

2117
01:23:52,670 --> 01:23:54,350
You can verify this on the past exam.

2118
01:23:54,350 --> 01:23:56,720
But we'd probably say you
can use drand 48, which

2119
01:23:56,720 --> 01:23:58,790
returns a float between 0 and 1.

2120
01:23:58,790 --> 01:24:00,830
>> DAVIN: Yes, yes, I'm
pretty sure on the exam

2121
01:24:00,830 --> 01:24:03,860
it says you probably
want to use drand, yeah.

2122
01:24:03,860 --> 01:24:07,041
So it's going to return
some value between 0 and 1.

2123
01:24:07,041 --> 01:24:08,790
And then what are you
going to want to do?

2124
01:24:08,790 --> 01:24:16,360
Well, you want to multiply by--
wait, I think it's like this, sorry.

2125
01:24:16,360 --> 01:24:18,018
I'll just do this.

2126
01:24:18,018 --> 01:24:19,410
I don't know.

2127
01:24:19,410 --> 01:24:22,240
>> So b minus a.

2128
01:24:22,240 --> 01:24:23,310

2129
01:24:23,310 --> 01:24:24,490
So why b minus a?

2130
01:24:24,490 --> 01:24:26,110

2131
01:24:26,110 --> 01:24:30,490
So let's say drand gives you back
an int-- OK, I'll just do the rest,

2132
01:24:30,490 --> 01:24:33,380
so plus a.

2133
01:24:33,380 --> 01:24:36,130
So what does-- y is b minus a.

2134
01:24:36,130 --> 01:24:40,670
So let's say that drand gives you back
the maximum value it could possibly

2135
01:24:40,670 --> 01:24:41,410
give you.

2136
01:24:41,410 --> 01:24:42,409
What's that going to be?

2137
01:24:42,409 --> 01:24:43,010
STUDENT: 1.

2138
01:24:43,010 --> 01:24:44,430
>> DAVIN: 1, right?

2139
01:24:44,430 --> 01:24:47,880
So if this is 1, and you're
multiplying it by b minus a,

2140
01:24:47,880 --> 01:24:50,110
well, that's just the
difference between minus A.

2141
01:24:50,110 --> 01:24:52,870
And if you then add that
back onto a, that is what?

2142
01:24:52,870 --> 01:24:54,290

2143
01:24:54,290 --> 01:24:55,180
It's basically b.

2144
01:24:55,180 --> 01:24:56,435

2145
01:24:56,435 --> 01:24:57,310
Does that make sense?

2146
01:24:57,310 --> 01:24:57,851
>> STUDENT: Yes.

2147
01:24:57,851 --> 01:24:59,480

2148
01:24:59,480 --> 01:25:02,170
>> DAVIN: So if this is the maximum
value it could possibly be,

2149
01:25:02,170 --> 01:25:03,175
it's going to be 1.

2150
01:25:03,175 --> 01:25:04,122

2151
01:25:04,122 --> 01:25:06,330
And then this is just the
difference between the two.

2152
01:25:06,330 --> 01:25:11,410
Add on a, so this is
going to return random.

2153
01:25:11,410 --> 01:25:15,000

2154
01:25:15,000 --> 01:25:18,620
And in the corner case that
drand gives you back 1,

2155
01:25:18,620 --> 01:25:20,970
random will just be effectively be b.

2156
01:25:20,970 --> 01:25:22,700
But that's the maximum it can be.

2157
01:25:22,700 --> 01:25:27,420
So if it's going to be less than
that, so let's say that its like 0.9,

2158
01:25:27,420 --> 01:25:31,080
so then 0.9 times b minus
a is going to be less

2159
01:25:31,080 --> 01:25:33,230
than the difference between b minus a.

2160
01:25:33,230 --> 01:25:35,830
>> And then if you add that
on to a, then that value is

2161
01:25:35,830 --> 01:25:38,986
going to be greater than a, because
you're adding something onto it,

2162
01:25:38,986 --> 01:25:40,360
but it's going to be less than b.

2163
01:25:40,360 --> 01:25:41,430

2164
01:25:41,430 --> 01:25:44,420
So you're going to get a random
number, because you're calling drand.

2165
01:25:44,420 --> 01:25:48,000
And that rand, that random number is
going to be somewhere in between a

2166
01:25:48,000 --> 01:25:49,342
and b.

2167
01:25:49,342 --> 01:25:50,780
Does that make sense?

2168
01:25:50,780 --> 01:25:52,990
>> ROB: Just to put it in
concrete numbers, so

2169
01:25:52,990 --> 01:25:55,450
let's say we want to pick a
random number between 7 and 10.

2170
01:25:55,450 --> 01:25:56,960
So b minus a is our range.

2171
01:25:56,960 --> 01:26:00,150
So there is a range of three
numbers we want to choose from.

2172
01:26:00,150 --> 01:26:03,290
And then multiplying
that between 0 and 1 1,

2173
01:26:03,290 --> 01:26:07,430
if that then gives us some--
let's say that gives us 1.5.

2174
01:26:07,430 --> 01:26:10,670
>> Then 1.5, we want to go from 7 to 10.

2175
01:26:10,670 --> 01:26:14,470
So 1.5 plus 7 brings us
back into our 7 to 10 range.

2176
01:26:14,470 --> 01:26:17,580
And then we're storing it inside of
an integer, so it truncated down to 8.

2177
01:26:17,580 --> 01:26:18,790
And then we just return that.

2178
01:26:18,790 --> 01:26:21,310
So b minus a is our range.

2179
01:26:21,310 --> 01:26:25,770
a shifts it up into the numbers
that we want within that range.

2180
01:26:25,770 --> 01:26:30,540
So between 7 and 10, and then we
can return what we end up with.

2181
01:26:30,540 --> 01:26:32,684
>> DAVIN: Yeah, nice.

2182
01:26:32,684 --> 01:26:34,470
>> ROB: Thank you.

2183
01:26:34,470 --> 01:26:35,628
>> DAVIN: Yeah, what's up?

2184
01:26:35,628 --> 01:26:39,746
>> STUDENT: Do we run it to any kind of
ASCII errors when we're-- if drand is

2185
01:26:39,746 --> 01:26:40,996
returning a float [INAUDIBLE].

2186
01:26:40,996 --> 01:26:42,470

2187
01:26:42,470 --> 01:26:45,360
>> ROB: So just like Rob said,
because random isn't an int,

2188
01:26:45,360 --> 01:26:47,080
so drand will be a float.

2189
01:26:47,080 --> 01:26:48,470
So and then it multiplies out.

2190
01:26:48,470 --> 01:26:50,507
And you might get some
kind of float numbers.

2191
01:26:50,507 --> 01:26:51,840
And then it's going to truncate.

2192
01:26:51,840 --> 01:26:52,339
>> STUDENT: OK.

2193
01:26:52,339 --> 01:26:53,019
DAVIN: Yeah.

2194
01:26:53,019 --> 01:26:56,060
ROB: And if the compiler were to warn
you about, like, loss of precision,

2195
01:26:56,060 --> 01:26:58,986
just thrown an int in
there, and then it's good.

2196
01:26:58,986 --> 01:27:00,398

2197
01:27:00,398 --> 01:27:00,898
DAVIN: Yes?

2198
01:27:00,898 --> 01:27:02,332

2199
01:27:02,332 --> 01:27:04,722
>> STUDENT: Would it have the
same probability of getting,

2200
01:27:04,722 --> 01:27:06,156
like, b or a [INAUDIBLE]?

2201
01:27:06,156 --> 01:27:08,080

2202
01:27:08,080 --> 01:27:10,980
>> ROB: So is-- I'm actually
wondering-- is RandomInt supposed

2203
01:27:10,980 --> 01:27:14,362
to be a number from a to less than b?

2204
01:27:14,362 --> 01:27:16,820
Like, if it's between 7 and
10, what are the possibilities?

2205
01:27:16,820 --> 01:27:18,454
7, 8, and 9, or 7, 8, 9, 10?

2206
01:27:18,454 --> 01:27:19,120
DAVIN: I forget.

2207
01:27:19,120 --> 01:27:19,880
On the problem set--

2208
01:27:19,880 --> 01:27:20,570
>> ROB: I think it's 7, 8, 9.

2209
01:27:20,570 --> 01:27:22,785
>> DAVIN: It specifically says one's
inclusive and one's exclusive.

2210
01:27:22,785 --> 01:27:23,110
>> ROB: Yeah.

2211
01:27:23,110 --> 01:27:23,670
>> DAVIN: But I don't-- I'm not--

2212
01:27:23,670 --> 01:27:25,878
>> ROB: So I think these is
not included, in which case,

2213
01:27:25,878 --> 01:27:28,152
there's an equal
probability of 7, 8, and 9.

2214
01:27:28,152 --> 01:27:29,360
There's no probability of 10.

2215
01:27:29,360 --> 01:27:31,770

2216
01:27:31,770 --> 01:27:32,270
DAVIN: Yes?

2217
01:27:32,270 --> 01:27:33,395
STUDENT: I have a question.

2218
01:27:33,395 --> 01:27:38,090
We want to define a function
returns not one value, but an array.

2219
01:27:38,090 --> 01:27:41,020
Then what would be the
syntax after return?

2220
01:27:41,020 --> 01:27:44,604
>> DAVIN: OK, so then you
would-- after return?

2221
01:27:44,604 --> 01:27:47,020
So let's say you had declared
an array somewhere up there.

2222
01:27:47,020 --> 01:27:49,708
Then you would just return
the name of the array.

2223
01:27:49,708 --> 01:27:50,676
>> STUDENT: OK, thank you.

2224
01:27:50,676 --> 01:27:51,718
Then just return with a--

2225
01:27:51,718 --> 01:27:52,759
DAVIN: Oh wait, so sorry.

2226
01:27:52,759 --> 01:27:54,620
The question was how
do you return an array.

2227
01:27:54,620 --> 01:27:56,170
>> ROB: Though it couldn't
be an array declared

2228
01:27:56,170 --> 01:27:57,260
on the stack or anything like that.

2229
01:27:57,260 --> 01:27:59,510
It would have to be something
malloced, because malloc

2230
01:27:59,510 --> 01:28:01,610
is how you get around
automatic memory allocation.

2231
01:28:01,610 --> 01:28:02,109
>> DAVIN: Yes.

2232
01:28:02,109 --> 01:28:03,433

2233
01:28:03,433 --> 01:28:04,933
ROB: How you get around local scope.

2234
01:28:04,933 --> 01:28:09,670

2235
01:28:09,670 --> 01:28:11,550
>> DAVIN: But you would
just return its name--

2236
01:28:11,550 --> 01:28:17,890
>> STUDENT: [INAUDIBLE] it's not one
value, for example, two numbers, so

2237
01:28:17,890 --> 01:28:18,390
[INAUDIBLE].

2238
01:28:18,390 --> 01:28:19,590
>> DAVIN: You can't return multiple number.

2239
01:28:19,590 --> 01:28:20,850
You can't, like, return--

2240
01:28:20,850 --> 01:28:23,630
>> STUDENT: I talked about returning
an array or something like that.

2241
01:28:23,630 --> 01:28:26,050
>> DAVIN: Yeah, so the question is
can I return multiple values.

2242
01:28:26,050 --> 01:28:27,460
You can't return multiple values.

2243
01:28:27,460 --> 01:28:30,270
You can't, like, return a then
return b or something like that.

2244
01:28:30,270 --> 01:28:32,710
Because after you return, you
return out of the function.

2245
01:28:32,710 --> 01:28:35,790
And then the function is done, and
like Rob said, is on the stack.

2246
01:28:35,790 --> 01:28:38,260
>> So all that memory just gets
returned to the computer.

2247
01:28:38,260 --> 01:28:40,025
Everything gets forgotten, basically.

2248
01:28:40,025 --> 01:28:41,480

2249
01:28:41,480 --> 01:28:44,430
So if you want to return multiple
values, you have to return an array,

2250
01:28:44,430 --> 01:28:45,971
And the way you do that is mallocing.

2251
01:28:45,971 --> 01:28:48,780
And then you would return x like that.

2252
01:28:48,780 --> 01:28:50,280
Basically, you just return the name.

2253
01:28:50,280 --> 01:28:51,620
And when you return
something like this, you're

2254
01:28:51,620 --> 01:28:53,200
not actually returning the value.

2255
01:28:53,200 --> 01:28:55,430
>> So let's say you stored
the values in an array.

2256
01:28:55,430 --> 01:28:57,910
You're not actually
returning those values.

2257
01:28:57,910 --> 01:29:01,515
Like, if I returned an int, I'm
really returning copies of the values.

2258
01:29:01,515 --> 01:29:02,017

2259
01:29:02,017 --> 01:29:03,850
But if i were to return
something like this,

2260
01:29:03,850 --> 01:29:06,450
I'm returning a reference
to those values.

2261
01:29:06,450 --> 01:29:09,090
So I'm returning, basically, a
memory address to the values.

2262
01:29:09,090 --> 01:29:10,079
Does that make sense?

2263
01:29:10,079 --> 01:29:10,620
STUDENT: Yes.

2264
01:29:10,620 --> 01:29:11,120
DAVIN: Nice.

2265
01:29:11,120 --> 01:29:12,760

2266
01:29:12,760 --> 01:29:13,410
Yes?

2267
01:29:13,410 --> 01:29:15,430
>> STUDENT: When you're
using drand over here,

2268
01:29:15,430 --> 01:29:17,660
do you have to put srand before that?

2269
01:29:17,660 --> 01:29:20,320
>> DAVIN: No, no, I don't think so.

2270
01:29:20,320 --> 01:29:23,040
>> ROB: Yeah, so do you have
to say anything about srand?

2271
01:29:23,040 --> 01:29:26,900
The default of you never saying srand
at all is to just do srand of null.

2272
01:29:26,900 --> 01:29:29,350
So drand on its own will work.

2273
01:29:29,350 --> 01:29:33,759
And it will automatically seed with
the current time, is what it uses.

2274
01:29:33,759 --> 01:29:35,175

2275
01:29:35,175 --> 01:29:35,675
DAVIN: Yes?

2276
01:29:35,675 --> 01:29:40,950
STUDENT: Do you [INAUDIBLE]
with the numbers?

2277
01:29:40,950 --> 01:29:42,570
DAVIN: Yes, you can.

2278
01:29:42,570 --> 01:29:46,770
STUDENT: So you could
say, like, 4 times 2.

2279
01:29:46,770 --> 01:29:50,280
The thing is, you cannot assume
then an int is four bytes.

2280
01:29:50,280 --> 01:29:51,020
The only--

2281
01:29:51,020 --> 01:29:53,830
>> DAVIN: I mean, for the quiz you can.

2282
01:29:53,830 --> 01:29:54,830
[LAUGHS]

2283
01:29:54,830 --> 01:29:55,780
>> ROB: Mm, no.

2284
01:29:55,780 --> 01:29:56,780
DAVIN: Yes, yes you can.

2285
01:29:56,780 --> 01:30:00,197
If they ask you how big an int is,
you can't be, like, four or eight.

2286
01:30:00,197 --> 01:30:02,030
ROB: Oh, so if the
question is specifically,

2287
01:30:02,030 --> 01:30:04,857
like, if it is a coding problem,
you should say size of int.

2288
01:30:04,857 --> 01:30:06,690
If it is a table, or
it says how many bytes,

2289
01:30:06,690 --> 01:30:08,808
you shouldn't fill in size of ints.

2290
01:30:08,808 --> 01:30:11,278
>> STUDENTS: [LAUGHS]

2291
01:30:11,278 --> 01:30:18,210

2292
01:30:18,210 --> 01:30:20,580
>> DAVIN: Right, so why is
size of int important here?

2293
01:30:20,580 --> 01:30:23,085
So like, if we're going to 32-bit
processor or something like that,

2294
01:30:23,085 --> 01:30:24,300
then it's going to be four bytes.

2295
01:30:24,300 --> 01:30:26,342
But on some of the newer
stuff, it could be what?

2296
01:30:26,342 --> 01:30:27,383
It could be eight, right?

2297
01:30:27,383 --> 01:30:30,550
So this-- if you just hard code four,
then on some machines, it will work.

2298
01:30:30,550 --> 01:30:32,180
Some machines, it won't work.

2299
01:30:32,180 --> 01:30:35,270
But if on the quiz we're
like how big is an int?

2300
01:30:35,270 --> 01:30:35,770
Put four.

2301
01:30:35,770 --> 01:30:38,710

2302
01:30:38,710 --> 01:30:39,210
ROB: Right.

2303
01:30:39,210 --> 01:30:39,790
DAVIN: Yeah?

2304
01:30:39,790 --> 01:30:43,192
STUDENT: So because we're declaring
[INAUDIBLE] inside a function,

2305
01:30:43,192 --> 01:30:45,622
should we put 3 inside that function?

2306
01:30:45,622 --> 01:30:46,907
Or can we use it outside?

2307
01:30:46,907 --> 01:30:48,740
DAVIN: You can use it
outside that function.

2308
01:30:48,740 --> 01:30:49,890
So he's asking for free.

2309
01:30:49,890 --> 01:30:51,700
>> STUDENT: Lose track
of where [INAUDIBLE].

2310
01:30:51,700 --> 01:30:54,720
>> ROB: Oh, the free does not happen--
that's part of the magic of malloc

2311
01:30:54,720 --> 01:30:57,220
is that you're not
restricted to local scope.

2312
01:30:57,220 --> 01:31:00,700
You have full control over
how long your variables live.

2313
01:31:00,700 --> 01:31:05,380
So we call malloc here, it might
be a completely separate function.

2314
01:31:05,380 --> 01:31:08,670
It might be 10 hours later
that we finally call free.

2315
01:31:08,670 --> 01:31:11,764
>> DAVIN: So for example, like, a couple
weeks from now when you finally

2316
01:31:11,764 --> 01:31:13,680
do your dictionary speller
psets, you're going

2317
01:31:13,680 --> 01:31:16,410
to have some function that
creates tons of nodes.

2318
01:31:16,410 --> 01:31:18,630
So you're mallocing tons
of nodes in this function.

2319
01:31:18,630 --> 01:31:20,670
And then later in a
separate function, you're

2320
01:31:20,670 --> 01:31:22,440
going to want to free all those nodes.

2321
01:31:22,440 --> 01:31:25,740
So you can literally just pass to
free a pointer, so a memory address

2322
01:31:25,740 --> 01:31:26,684
to what you malloced.

2323
01:31:26,684 --> 01:31:27,600
And that will be fine.

2324
01:31:27,600 --> 01:31:29,725
You don't have to free,
like, in the same function.

2325
01:31:29,725 --> 01:31:30,449
Yes?

2326
01:31:30,449 --> 01:31:36,197
>> STUDENT: So a malloc
variable [INAUDIBLE] outside?

2327
01:31:36,197 --> 01:31:37,384
Is that what you're saying?

2328
01:31:37,384 --> 01:31:38,300
DAVIN: Wait, say that?

2329
01:31:38,300 --> 01:31:38,800
Sorry.

2330
01:31:38,800 --> 01:31:42,300
>> STUDENT: If a malloc variable
can be free anywhere in the code,

2331
01:31:42,300 --> 01:31:44,800
then can they be accessed
anywhere in the code?

2332
01:31:44,800 --> 01:31:45,800
Can you keep them local?

2333
01:31:45,800 --> 01:31:47,880
>> DAVIN: Oh, she asked,
like, the variable, like--

2334
01:31:47,880 --> 01:31:51,300

2335
01:31:51,300 --> 01:31:55,510
>> ROB: So you still need to
have some sort of reference

2336
01:31:55,510 --> 01:31:57,220
to the malloc's block of memory.

2337
01:31:57,220 --> 01:31:58,540
So here, we're returning x.

2338
01:31:58,540 --> 01:31:59,040
STUDENT: Oh.

2339
01:31:59,040 --> 01:32:01,920
ROB: If we didn't return x
here, and this were just void,

2340
01:32:01,920 --> 01:32:04,550
then we would have no access to
the pointer that was malloced ,

2341
01:32:04,550 --> 01:32:05,920
and it's leaked memory.

2342
01:32:05,920 --> 01:32:06,690
>> STUDENT: OK.

2343
01:32:06,690 --> 01:32:10,010
>> DAVIN: So like, let's say you
have this, like, right here.

2344
01:32:10,010 --> 01:32:10,510
ROB: No.

2345
01:32:10,510 --> 01:32:13,430
DAVIN: In my main function, I can't
just call this x and be, like, OK,

2346
01:32:13,430 --> 01:32:14,645
in this function, I did this.

2347
01:32:14,645 --> 01:32:14,960
>> ROB: Right.

2348
01:32:14,960 --> 01:32:17,790
>> DAVIN: So I'm going to call x in,
like, main or something like that.

2349
01:32:17,790 --> 01:32:18,540
You can't do that.

2350
01:32:18,540 --> 01:32:19,600
You're going to return something.

2351
01:32:19,600 --> 01:32:21,000
But what are you going to return?

2352
01:32:21,000 --> 01:32:22,130
You're going to return a memory address.

2353
01:32:22,130 --> 01:32:25,130
And because you return a memory
address, that can be accessed elsewhere.

2354
01:32:25,130 --> 01:32:27,262

2355
01:32:27,262 --> 01:32:28,255
Any more questions?

2356
01:32:28,255 --> 01:32:28,755
Yes?

2357
01:32:28,755 --> 01:32:31,213
>> STUDENT: Is the function above
being check for [INAUDIBLE]?

2358
01:32:31,213 --> 01:32:33,270

2359
01:32:33,270 --> 01:32:35,005
>> DAVIN: Why do I not need to do that?

2360
01:32:35,005 --> 01:32:35,880
STUDENT: [INAUDIBLE].

2361
01:32:35,880 --> 01:32:37,755
DAVIN: Because you're
not mallocing anything.

2362
01:32:37,755 --> 01:32:39,640
So it's not-- yeah, it's
not like a string s.

2363
01:32:39,640 --> 01:32:41,160
It's a pointer somewhere.

2364
01:32:41,160 --> 01:32:42,951
These are just values.

2365
01:32:42,951 --> 01:32:43,450
STUDENT: OK.

2366
01:32:43,450 --> 01:32:43,949
DAVIN: Yeah.

2367
01:32:43,949 --> 01:32:47,600

2368
01:32:47,600 --> 01:32:48,470
Anything else?

2369
01:32:48,470 --> 01:32:48,970
ROB: Yep?

2370
01:32:48,970 --> 01:32:50,386
STUDENT: But when you [INAUDIBLE]?

2371
01:32:50,386 --> 01:32:55,050

2372
01:32:55,050 --> 01:32:58,690
>> ROB: So in order to free the
memory, we would say here.

2373
01:32:58,690 --> 01:33:01,350
So x is our pointer to
the block of memory.

2374
01:33:01,350 --> 01:33:02,845
We free that pointer.

2375
01:33:02,845 --> 01:33:04,470
And we wouldn't necessarily do it here.

2376
01:33:04,470 --> 01:33:05,390
We can do it anywhere.

2377
01:33:05,390 --> 01:33:10,400
But you only call free on
something that malloc returns.

2378
01:33:10,400 --> 01:33:12,940
So malloc, here, returned
what is being stored in x.

2379
01:33:12,940 --> 01:33:14,802
So we can call free on x.

2380
01:33:14,802 --> 01:33:18,730

2381
01:33:18,730 --> 01:33:20,556
Any last questions?

2382
01:33:20,556 --> 01:33:21,701
>> DAVIN: Any last questions?

2383
01:33:21,701 --> 01:33:22,200
Yeah?

2384
01:33:22,200 --> 01:33:25,152
>> STUDENT: Sorry, can you re-explain
why you would free in there?

2385
01:33:25,152 --> 01:33:26,630
Why [INAUDIBLE]?

2386
01:33:26,630 --> 01:33:27,774
>> DAVIN: For here?

2387
01:33:27,774 --> 01:33:29,109
>> STUDENT: Yeah, like right after.

2388
01:33:29,109 --> 01:33:30,900
DAVIN: You probably
don't want a free here.

2389
01:33:30,900 --> 01:33:31,630
ROB: You probably wouldn't.

2390
01:33:31,630 --> 01:33:33,060
DAVIN: Yeah, that this would do nothing.

2391
01:33:33,060 --> 01:33:35,220
This would, like, create
memory, do stuff to it,

2392
01:33:35,220 --> 01:33:37,390
and then immediately
forget about it, yeah.

2393
01:33:37,390 --> 01:33:39,850
>> ROB: But we might do, like,
in here for some reason.

2394
01:33:39,850 --> 01:33:43,902
We might say int star
y equals return array.

2395
01:33:43,902 --> 01:33:47,900
Do some stuff with y,
maybe print the contents.

2396
01:33:47,900 --> 01:33:49,350
And then, finally, we're done.

2397
01:33:49,350 --> 01:33:50,626
We can free y.

2398
01:33:50,626 --> 01:33:51,501
STUDENT: [INAUDIBLE].

2399
01:33:51,501 --> 01:33:57,839

2400
01:33:57,839 --> 01:33:59,005
DAVIN: Should I scroll down?

2401
01:33:59,005 --> 01:34:00,445
Thanks.

2402
01:34:00,445 --> 01:34:00,945
ROB: Nice.

2403
01:34:00,945 --> 01:34:02,400

2404
01:34:02,400 --> 01:34:03,646
>> DAVIN: OK, that's it.

2405
01:34:03,646 --> 01:34:04,520
ROB: All right, good.

2406
01:34:04,520 --> 01:34:05,070
Good luck.

2407
01:34:05,070 --> 01:34:06,800
>> DAVIN: If you have questions, email us.

2408
01:34:06,800 --> 01:34:08,670
Good luck.

2409
01:34:08,670 --> 01:34:10,283
