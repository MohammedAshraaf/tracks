1
00:00:00,000 --> 00:00:11,046

2
00:00:11,046 --> 00:00:12,170
ALLISON BUCHHOLTZ-AU: Hey, everyone.

3
00:00:12,170 --> 00:00:13,560
Welcome to section.

4
00:00:13,560 --> 00:00:17,320
Today is just going to be all quiz
review for your quiz on Wednesday.

5
00:00:17,320 --> 00:00:20,060
I hope everyone remembers that
they have a quiz on Wednesday.

6
00:00:20,060 --> 00:00:22,560
And if you didn't, well,
now you've been reminded.

7
00:00:22,560 --> 00:00:26,486
So Wednesday make sure you show up
for class or other accommodations as

8
00:00:26,486 --> 00:00:26,985
necessary.

9
00:00:26,985 --> 00:00:27,845

10
00:00:27,845 --> 00:00:29,220
You guys are going to be awesome.

11
00:00:29,220 --> 00:00:30,440
It's going to be great.

12
00:00:30,440 --> 00:00:34,910
And I'm going to do everything I can
to help prepare you today for your quiz

13
00:00:34,910 --> 00:00:35,470
now.

14
00:00:35,470 --> 00:00:39,960
And also in case you don't know,
there is a course wide review session

15
00:00:39,960 --> 00:00:45,840
today at 7 o'clock in
Northwest labs room B103.

16
00:00:45,840 --> 00:00:49,950
You can see me again for an encore as
I will lead part of that review session

17
00:00:49,950 --> 00:00:50,510
also.

18
00:00:50,510 --> 00:00:53,218
So if you can't get enough of me
now, you can come again tonight.

19
00:00:53,218 --> 00:00:54,130

20
00:00:54,130 --> 00:00:56,060
>> All right, so first things first.

21
00:00:56,060 --> 00:00:59,630
Just some quiz tips before we
actually dive in to reviews.

22
00:00:59,630 --> 00:01:04,160
So as with any exam, practice
will definitely help you out.

23
00:01:04,160 --> 00:01:09,260
There are exams from the past
six or seven years on there,

24
00:01:09,260 --> 00:01:12,480
so that's a lot of practice
material for you guys to have.

25
00:01:12,480 --> 00:01:15,340
And in fact, today is really just
going to be going over any topics

26
00:01:15,340 --> 00:01:18,900
that you guys have questions on as well
as working through practice problems

27
00:01:18,900 --> 00:01:20,360
from quiz zero.

28
00:01:20,360 --> 00:01:22,690
So I'll throw up quiz zero
from last year on here,

29
00:01:22,690 --> 00:01:26,410
and we can work through any problems
that you guys would like to.

30
00:01:26,410 --> 00:01:27,370
>> So practicing.

31
00:01:27,370 --> 00:01:29,310
You're going to start doing that today.

32
00:01:29,310 --> 00:01:30,230
Code on paper.

33
00:01:30,230 --> 00:01:32,970
So yeah, if everyone
could actually get out

34
00:01:32,970 --> 00:01:35,810
paper, that'll be great,
because you're not

35
00:01:35,810 --> 00:01:41,470
going to have your computer on the
exam and writing out code by hand

36
00:01:41,470 --> 00:01:44,190
is often much more difficult
than you might expect.

37
00:01:44,190 --> 00:01:46,680
You're used to just
seeing it and typing it,

38
00:01:46,680 --> 00:01:49,630
and you have your compiler to
help you out when you have errors,

39
00:01:49,630 --> 00:01:52,190
but you don't get that on the exam.

40
00:01:52,190 --> 00:01:55,140
So it's really important to actually
be able to write out the code,

41
00:01:55,140 --> 00:01:58,360
and that muscle memory of doing
it by hand will really help you.

42
00:01:58,360 --> 00:01:59,720

43
00:01:59,720 --> 00:02:01,690
>> So we're getting a little close.

44
00:02:01,690 --> 00:02:02,340
It's Monday.

45
00:02:02,340 --> 00:02:03,930
Your exam is on Wednesday.

46
00:02:03,930 --> 00:02:06,030
But if you have time,
definitely take one

47
00:02:06,030 --> 00:02:10,199
of the exams from last year or the
year before under the time constraint

48
00:02:10,199 --> 00:02:11,660
of an hour and a half.

49
00:02:11,660 --> 00:02:13,730
Just knock out an hour
and a half of time,

50
00:02:13,730 --> 00:02:17,480
and sit yourself down, and
just work through the problems

51
00:02:17,480 --> 00:02:19,962
as if you were actually
taking it, because one

52
00:02:19,962 --> 00:02:23,295
of the biggest things that we hear about
the quizzes is that they are very long.

53
00:02:23,295 --> 00:02:24,900

54
00:02:24,900 --> 00:02:26,660
It is a lot of material.

55
00:02:26,660 --> 00:02:30,850
There are a lot of questions,
and most people may not finish.

56
00:02:30,850 --> 00:02:34,660
I know that I totally did not finish
my quizzes when I took the class.

57
00:02:34,660 --> 00:02:37,180
>> On that note, as a less
comfortable section,

58
00:02:37,180 --> 00:02:40,570
understand that this course is meant
to cater for people of all levels.

59
00:02:40,570 --> 00:02:43,640
The whole reason we have you split
less comfortable, somewhere between,

60
00:02:43,640 --> 00:02:47,660
and more comfortable is to
kind of make it more fair.

61
00:02:47,660 --> 00:02:51,699
And if you are less comfortable, it's
not necessary per se to get everything.

62
00:02:51,699 --> 00:02:53,990
Like if you were getting
everything, you would probably

63
00:02:53,990 --> 00:02:55,448
be in the more comfortable section.

64
00:02:55,448 --> 00:03:00,160
So obviously don't beat yourselves up
too hard if you can't finish the exam.

65
00:03:00,160 --> 00:03:01,920
Take it from me, I didn't do it.

66
00:03:01,920 --> 00:03:03,070
I'm still a concentrator.

67
00:03:03,070 --> 00:03:04,630
I'm still helping teach the course.

68
00:03:04,630 --> 00:03:06,170
You'll be fine.

69
00:03:06,170 --> 00:03:06,670
All right.

70
00:03:06,670 --> 00:03:08,740
And lastly, get some sleep.

71
00:03:08,740 --> 00:03:11,020
Obviously with any exam
we always say this.

72
00:03:11,020 --> 00:03:13,610
Cramming the night before
and not getting any sleep

73
00:03:13,610 --> 00:03:16,390
does not-- maybe if that
works for you, go for it.

74
00:03:16,390 --> 00:03:18,790
But for the vast majority of
people, getting some sleep,

75
00:03:18,790 --> 00:03:22,390
letting your brain rest and recover
before coming in for the exam

76
00:03:22,390 --> 00:03:23,480
will really help you.

77
00:03:23,480 --> 00:03:26,120
Also there will almost
surely be candy at the exam,

78
00:03:26,120 --> 00:03:28,019
so you have to look forward to.

79
00:03:28,019 --> 00:03:29,310
You guys are going to do great.

80
00:03:29,310 --> 00:03:30,226
It's going to be fine.

81
00:03:30,226 --> 00:03:31,570

82
00:03:31,570 --> 00:03:36,190
And now in the next hour and a half I
will try and prep you as best as I can.

83
00:03:36,190 --> 00:03:41,260
>> So I have slides from basically
all sections up to now.

84
00:03:41,260 --> 00:03:45,874
I'm not going to go through
all of them because that is not

85
00:03:45,874 --> 00:03:49,040
feasible in an hour and a half as well
as working through practice problems.

86
00:03:49,040 --> 00:03:51,410
So instead I have a list of topics.

87
00:03:51,410 --> 00:03:55,160
These are all the things
that we could quiz you on.

88
00:03:55,160 --> 00:03:56,950

89
00:03:56,950 --> 00:03:58,770
If there's anything
that really jumps out

90
00:03:58,770 --> 00:04:02,140
that you want to go over, that you
want me to go over conceptually,

91
00:04:02,140 --> 00:04:04,320
I can try and give
you an overview there.

92
00:04:04,320 --> 00:04:07,690
Or if you want to jump right in to
doing practice problems together,

93
00:04:07,690 --> 00:04:08,420
we can do that.

94
00:04:08,420 --> 00:04:09,330
It's up to you guys.

95
00:04:09,330 --> 00:04:10,770
There aren't that many of you.

96
00:04:10,770 --> 00:04:13,180
So it's whatever you guys like to do.

97
00:04:13,180 --> 00:04:15,667
I want to be the most
helpful toward you guys.

98
00:04:15,667 --> 00:04:16,827

99
00:04:16,827 --> 00:04:17,910
So I'll let you just look.

100
00:04:17,910 --> 00:04:27,880

101
00:04:27,880 --> 00:04:30,500
>> AUDIENCE: One thing is
the chart that we keep

102
00:04:30,500 --> 00:04:33,290
saying about the stack and the heap.

103
00:04:33,290 --> 00:04:34,600

104
00:04:34,600 --> 00:04:37,434
Just the whole idea behind
that and what that means.

105
00:04:37,434 --> 00:04:38,350
ALLISON BUCHHOLTZ-AU: Yeah, OK.

106
00:04:38,350 --> 00:04:40,290

107
00:04:40,290 --> 00:04:43,216
This is all the way at the
end, so let me scroll through.

108
00:04:43,216 --> 00:04:45,490
>> AUDIENCE: We don't have to
do it now, but whatever.

109
00:04:45,490 --> 00:04:47,070

110
00:04:47,070 --> 00:04:49,770
>> ALLISON BUCHHOLTZ-AU: Was there
anything-- this one.

111
00:04:49,770 --> 00:04:51,570

112
00:04:51,570 --> 00:04:53,555
Is this kind of fuzzy for people?

113
00:04:53,555 --> 00:04:54,390

114
00:04:54,390 --> 00:04:55,640
AUDIENCE: Yeah, I second that.

115
00:04:55,640 --> 00:04:57,718
And can we also do buffer overflow?

116
00:04:57,718 --> 00:04:58,926
ALLISON BUCHHOLTZ-AU: Buffer overflow?

117
00:04:58,926 --> 00:04:59,820
OK.

118
00:04:59,820 --> 00:05:03,460
So buffer overflow is pretty
easy just to talk about.

119
00:05:03,460 --> 00:05:08,217
It's basically buffers you think about
some array memory that you have, right?

120
00:05:08,217 --> 00:05:10,050
We typically talk about
buffer overflow when

121
00:05:10,050 --> 00:05:15,160
you're not checking how much
the user is putting in, right?

122
00:05:15,160 --> 00:05:18,540
And the idea being
with buffer overflow is

123
00:05:18,540 --> 00:05:21,535
they are putting in far
too much data for the space

124
00:05:21,535 --> 00:05:23,780
that you've allotted for them, right?

125
00:05:23,780 --> 00:05:28,310
>> So if you say, give
me some message, we're

126
00:05:28,310 --> 00:05:31,860
assuming that they're going to give
us a reasonable length message.

127
00:05:31,860 --> 00:05:33,910
Maybe a couple lines, whatnot.

128
00:05:33,910 --> 00:05:35,150
So we don't check.

129
00:05:35,150 --> 00:05:38,160
Instead they feed us in an
entire book that's a message,

130
00:05:38,160 --> 00:05:42,450
and it overflows the amount of
space that we've allocated for this.

131
00:05:42,450 --> 00:05:48,140
And what happens is it might overwrite
places that it's not supposed.

132
00:05:48,140 --> 00:05:52,890
>> So I know Professor Malan said
something about buffer overflow attacks.

133
00:05:52,890 --> 00:05:59,050
So that's where the user will input
some massive amount of data in the hopes

134
00:05:59,050 --> 00:06:02,840
that he overwrites past
the end of your buffer

135
00:06:02,840 --> 00:06:06,479
and replaces something-- I wonder
I we have those slides in here.

136
00:06:06,479 --> 00:06:08,270
I don't think we have
those slides in here.

137
00:06:08,270 --> 00:06:09,960

138
00:06:09,960 --> 00:06:14,460
But basically he overwrites
some portion of memory

139
00:06:14,460 --> 00:06:17,780
that allows him access
to parts of your computer

140
00:06:17,780 --> 00:06:19,530
that you wouldn't
normally have access to.

141
00:06:19,530 --> 00:06:20,750

142
00:06:20,750 --> 00:06:23,155
>> Biggest thing with
buffer overflow is just

143
00:06:23,155 --> 00:06:26,420
to understand that it
happens when you aren't

144
00:06:26,420 --> 00:06:29,210
checking how much your
user is putting in.

145
00:06:29,210 --> 00:06:32,770
When you aren't kind of
safeguarding against that.

146
00:06:32,770 --> 00:06:36,820
And at its simplest
thing, it's just your user

147
00:06:36,820 --> 00:06:39,130
inputting a massive amount
of data in an attempt

148
00:06:39,130 --> 00:06:45,090
to overwrite some security
portion of your memory.

149
00:06:45,090 --> 00:06:46,310
That's all it is.

150
00:06:46,310 --> 00:06:49,810
>> So this here, stack and heap.

151
00:06:49,810 --> 00:06:53,090
Basically all this is is just
a representation of memory

152
00:06:53,090 --> 00:06:54,449
and where things are stored.

153
00:06:54,449 --> 00:06:56,240
That's really kind of
all you need to know.

154
00:06:56,240 --> 00:06:58,520
The biggest things that
you need to know are

155
00:06:58,520 --> 00:07:01,910
that-- let me see if
there's a better-- here.

156
00:07:01,910 --> 00:07:05,380
So this is the stack here.

157
00:07:05,380 --> 00:07:08,410
>> So stack has to do with
all of your functions

158
00:07:08,410 --> 00:07:10,140
that you're calling at any given time.

159
00:07:10,140 --> 00:07:15,060
And what's important to remember
going off of last week with malloc

160
00:07:15,060 --> 00:07:21,080
is that you don't really have
necessary control over it.

161
00:07:21,080 --> 00:07:24,780
It all depends on when certain
functions are executing.

162
00:07:24,780 --> 00:07:28,170
And when they are executing, they
have what are called stack frames

163
00:07:28,170 --> 00:07:29,290
that go up here.

164
00:07:29,290 --> 00:07:32,520
>> So it all kind of happens
without any real input from you.

165
00:07:32,520 --> 00:07:33,630

166
00:07:33,630 --> 00:07:35,510
You write your program,
and you let it run,

167
00:07:35,510 --> 00:07:38,470
and the stack kind of takes
care of itself as it needs to.

168
00:07:38,470 --> 00:07:42,940
So if in main you're calling
cube, that will be passed up here.

169
00:07:42,940 --> 00:07:44,110
It'll create a frame.

170
00:07:44,110 --> 00:07:48,330
But there's nothing you explicitly do
to create that stack frame other than

171
00:07:48,330 --> 00:07:51,430
write the function to begin with, OK?

172
00:07:51,430 --> 00:07:56,500
>> What is kind of under your
control is the heap with malloc.

173
00:07:56,500 --> 00:08:01,950
So whenever you malloc something,
you are taking memory from the heap.

174
00:08:01,950 --> 00:08:05,110
And that is memory that you
have, for lack of a better word,

175
00:08:05,110 --> 00:08:10,300
explicit control over,
because remember with malloc

176
00:08:10,300 --> 00:08:12,530
it's basically there
until you say otherwise.

177
00:08:12,530 --> 00:08:14,890
For those of you who
watched section last week,

178
00:08:14,890 --> 00:08:17,670
it's there until you tell it to go away.

179
00:08:17,670 --> 00:08:20,850
It will be there unless
otherwise told not.

180
00:08:20,850 --> 00:08:24,750
So the heap is just something
you can think of as memory

181
00:08:24,750 --> 00:08:26,150
that you have control over.

182
00:08:26,150 --> 00:08:29,010
And those are just the
two different big things.

183
00:08:29,010 --> 00:08:31,320

184
00:08:31,320 --> 00:08:38,330
>> Other than that, you shouldn't have
to worry too much about stack and heap

185
00:08:38,330 --> 00:08:42,159
questions or typically more just
if you have local parameters

186
00:08:42,159 --> 00:08:45,385
or a function would it be
on the stack or the heap.

187
00:08:45,385 --> 00:08:47,260
Obviously in this case
it would be the stack.

188
00:08:47,260 --> 00:08:49,630
If you're mallocing something,
where is that coming from?

189
00:08:49,630 --> 00:08:50,129
The heap.

190
00:08:50,129 --> 00:08:51,147

191
00:08:51,147 --> 00:08:54,230
If you look at practice quizzes, those
are generally the type of questions

192
00:08:54,230 --> 00:08:55,460
that they have.

193
00:08:55,460 --> 00:08:57,340
>> You don't have to worry
too much about it.

194
00:08:57,340 --> 00:09:00,980
You get into more explicitly
about stack and heap

195
00:09:00,980 --> 00:09:03,460
later on or in other CS classes.

196
00:09:03,460 --> 00:09:06,220
So just having kind of a
general idea of what this is

197
00:09:06,220 --> 00:09:09,100
will be good, which I
just kind of went over.

198
00:09:09,100 --> 00:09:10,650

199
00:09:10,650 --> 00:09:12,090
Any other topics?

200
00:09:12,090 --> 00:09:12,590
Yes?

201
00:09:12,590 --> 00:09:14,923
>> AUDIENCE: Can you go over
pointers again really quickly?

202
00:09:14,923 --> 00:09:15,870
ALLISON BUCHHOLTZ-AU: Pointers?

203
00:09:15,870 --> 00:09:18,470
Do you want conceptual
overview of pointers

204
00:09:18,470 --> 00:09:19,994
or do you practice with pointers?

205
00:09:19,994 --> 00:09:21,410
AUDIENCE: Kind of like the syntax.

206
00:09:21,410 --> 00:09:22,360
ALLISON BUCHHOLTZ-AU: The syntax?

207
00:09:22,360 --> 00:09:22,860
Yeah.

208
00:09:22,860 --> 00:09:32,090

209
00:09:32,090 --> 00:09:33,090
OK, we're getting there.

210
00:09:33,090 --> 00:09:38,300

211
00:09:38,300 --> 00:09:42,040
Yeah, so this is just kind of something
when you have a recursive function,

212
00:09:42,040 --> 00:09:45,954
every time that recursive function is
called, it just adds other stack frame.

213
00:09:45,954 --> 00:09:47,870
Pretty much an example
of how you don't really

214
00:09:47,870 --> 00:09:50,330
have control over the
frames on your stack.

215
00:09:50,330 --> 00:09:54,010

216
00:09:54,010 --> 00:09:54,585
>> OK, pointers.

217
00:09:54,585 --> 00:09:57,120

218
00:09:57,120 --> 00:09:59,235
All right, so creating pointers.

219
00:09:59,235 --> 00:10:00,300

220
00:10:00,300 --> 00:10:02,420
Remember, it's just type star.

221
00:10:02,420 --> 00:10:07,140
So whatever type of data that
you're going to be pointing to.

222
00:10:07,140 --> 00:10:08,720

223
00:10:08,720 --> 00:10:11,440
So this would be a pointer to an int.

224
00:10:11,440 --> 00:10:13,140
This would be a pointer to a char.

225
00:10:13,140 --> 00:10:14,740
This would be a pointer to a float.

226
00:10:14,740 --> 00:10:17,980
So it's basically whatever
you want it to be pointing to,

227
00:10:17,980 --> 00:10:22,300
star is how you declare the pointer, OK?

228
00:10:22,300 --> 00:10:26,200
>> But then obviously gets a little
tricky when you have pointer

229
00:10:26,200 --> 00:10:27,370
or you have star whatever.

230
00:10:27,370 --> 00:10:31,260
So the big difference is
when you're declaring--

231
00:10:31,260 --> 00:10:45,590
so we have some-- so
this takes some int star.

232
00:10:45,590 --> 00:10:49,650
So this is some pointer
calls x to an int, right?

233
00:10:49,650 --> 00:10:54,600
So remember what this does
is this calls the system x.

234
00:10:54,600 --> 00:10:56,970
And this is going to
have some address, right?

235
00:10:56,970 --> 00:11:00,515
So let's just say this is our address.

236
00:11:00,515 --> 00:11:01,590

237
00:11:01,590 --> 00:11:03,570
Pointers hold addresses.

238
00:11:03,570 --> 00:11:08,660
So what this says is that at this
location, we are storing an int.

239
00:11:08,660 --> 00:11:10,770

240
00:11:10,770 --> 00:11:15,770
>> So another way we can think of
this is that this is some int.

241
00:11:15,770 --> 00:11:17,010

242
00:11:17,010 --> 00:11:20,350
We haven't really assigned it to
anything yet, but it's just an int.

243
00:11:20,350 --> 00:11:31,540
So we can do is if we do star x
equals 5, this becomes a 5, OK?

244
00:11:31,540 --> 00:11:38,350
This says go to whatever x is
pointing at, so go to this address

245
00:11:38,350 --> 00:11:40,210
and make it equal to 5.

246
00:11:40,210 --> 00:11:44,390
So we assign 5 to this address, right?

247
00:11:44,390 --> 00:11:52,540
>> And then if you do this,
this gives us the address of.

248
00:11:52,540 --> 00:11:54,730
This is the address of operator.

249
00:11:54,730 --> 00:11:57,700
So what is the address of x?

250
00:11:57,700 --> 00:11:58,809
We don't know.

251
00:11:58,809 --> 00:12:00,225
We haven't assigned it an address.

252
00:12:00,225 --> 00:12:03,000

253
00:12:03,000 --> 00:12:09,105
We could say it's some-- now we gave
it an address, so the address is 4.

254
00:12:09,105 --> 00:12:10,690

255
00:12:10,690 --> 00:12:16,980
And actually if we go through something
like this, kind of what we did.

256
00:12:16,980 --> 00:12:25,800
So working through here-- I find
it helps if you draw out pointers.

257
00:12:25,800 --> 00:12:28,270
If you're on your exam, I
highly recommend drawing boxes.

258
00:12:28,270 --> 00:12:29,490

259
00:12:29,490 --> 00:12:33,310
>> So this first one, int x equals 5.

260
00:12:33,310 --> 00:12:37,370
This just means we have some
place in memory that is 5, right?

261
00:12:37,370 --> 00:12:38,540

262
00:12:38,540 --> 00:12:44,760
And our table here tells us
that it's at address 0x04.

263
00:12:44,760 --> 00:12:48,770

264
00:12:48,770 --> 00:12:50,280
And then we create some pointer.

265
00:12:50,280 --> 00:12:51,820

266
00:12:51,820 --> 00:12:55,310
So let's break this down one at a time.

267
00:12:55,310 --> 00:12:59,820
So this creates some
box to an int, right?

268
00:12:59,820 --> 00:13:01,970
It's going to hold
some address of an it.

269
00:13:01,970 --> 00:13:03,470
So this is some pointer.

270
00:13:03,470 --> 00:13:04,940

271
00:13:04,940 --> 00:13:06,510
And this chalk is really small.

272
00:13:06,510 --> 00:13:07,472

273
00:13:07,472 --> 00:13:08,680
So we have some pointer here.

274
00:13:08,680 --> 00:13:10,060

275
00:13:10,060 --> 00:13:13,530
And our table tells us
that is address is 0x08.

276
00:13:13,530 --> 00:13:15,190

277
00:13:15,190 --> 00:13:16,200
Cool.

278
00:13:16,200 --> 00:13:23,240
And we are assigning
it to the address of x.

279
00:13:23,240 --> 00:13:26,330
>> Remember, pointers hold addresses, OK?

280
00:13:26,330 --> 00:13:32,050
So if we want to hold x, we have
to use the address operator, which

281
00:13:32,050 --> 00:13:36,520
is the ampersand, to get the address
of x, which in this case, 0x04.

282
00:13:36,520 --> 00:13:39,130

283
00:13:39,130 --> 00:13:44,430
And then if we have
some int copy, this just

284
00:13:44,430 --> 00:13:48,060
creates some other box that
holds an int called copy.

285
00:13:48,060 --> 00:13:49,410

286
00:13:49,410 --> 00:13:55,330
And if we assign it to this--
so this is referencing it.

287
00:13:55,330 --> 00:14:00,090
So it says go to whatever
address pointer holds.

288
00:14:00,090 --> 00:14:05,330
Pointer holds this address,
so we'd go over here,

289
00:14:05,330 --> 00:14:07,130
and we say, OK, what's in it?

290
00:14:07,130 --> 00:14:08,610
It's 5.

291
00:14:08,610 --> 00:14:09,815
So copy becomes 5.

292
00:14:09,815 --> 00:14:11,800

293
00:14:11,800 --> 00:14:12,540
Make sense?

294
00:14:12,540 --> 00:14:15,540

295
00:14:15,540 --> 00:14:25,020
>> What if I tried to assign
this to just pointer.

296
00:14:25,020 --> 00:14:26,476

297
00:14:26,476 --> 00:14:27,850
What does pointer actually equal?

298
00:14:27,850 --> 00:14:31,126

299
00:14:31,126 --> 00:14:34,315
It would just be whatever
pointer contains, right?

300
00:14:34,315 --> 00:14:36,400

301
00:14:36,400 --> 00:14:37,580
And then what if I did this?

302
00:14:37,580 --> 00:14:38,922

303
00:14:38,922 --> 00:14:39,880
What would copy be now?

304
00:14:39,880 --> 00:14:41,365

305
00:14:41,365 --> 00:14:42,275
>> AUDIENCE: 0x08.

306
00:14:42,275 --> 00:14:44,150
ALLISON BUCHHOLTZ-AU: Yep, the
address of our pointer.

307
00:14:44,150 --> 00:14:46,832

308
00:14:46,832 --> 00:14:48,790
Any part of that that
needs to be re-explained?

309
00:14:48,790 --> 00:14:50,170

310
00:14:50,170 --> 00:14:50,670
Cool.

311
00:14:50,670 --> 00:14:53,350

312
00:14:53,350 --> 00:14:57,740
There is definitely a very
fun problem on quiz one

313
00:14:57,740 --> 00:15:00,100
that we can over that
gives you more practice.

314
00:15:00,100 --> 00:15:00,937

315
00:15:00,937 --> 00:15:03,270
The guys from last week can
tell you it wasn't that bad.

316
00:15:03,270 --> 00:15:06,000
We got through an entire
chart, and everyone did great.

317
00:15:06,000 --> 00:15:10,830
>> OK, so that's overview
of syntax of pointers.

318
00:15:10,830 --> 00:15:15,070
Biggest thing is understanding how
to create them, do referencing,

319
00:15:15,070 --> 00:15:18,190
and address of, OK?

320
00:15:18,190 --> 00:15:18,690
Cool.

321
00:15:18,690 --> 00:15:20,775
Any other topics before
we dive into practice.

322
00:15:20,775 --> 00:15:24,280

323
00:15:24,280 --> 00:15:28,011
Also if we're going through
the practice problems

324
00:15:28,011 --> 00:15:30,760
and there's something you want a
refresher on, we can do that too.

325
00:15:30,760 --> 00:15:31,300
Do you have something?

326
00:15:31,300 --> 00:15:32,758
>> AUDIENCE: Structs and linked lists.

327
00:15:32,758 --> 00:15:35,130
ALLISON BUCHHOLTZ-AU: Structs
and linked lists, OK.

328
00:15:35,130 --> 00:15:37,100
So structs.

329
00:15:37,100 --> 00:15:38,990
We actually are going
over this tonight too.

330
00:15:38,990 --> 00:15:40,130

331
00:15:40,130 --> 00:15:41,890
OK, so structs.

332
00:15:41,890 --> 00:15:47,490
Structs are basically
just a way for you to hold

333
00:15:47,490 --> 00:15:50,430
multiple values of different types.

334
00:15:50,430 --> 00:15:55,150
So with an array we are
constricted to one data type.

335
00:15:55,150 --> 00:16:00,965
Our array either has to just be numbers,
or just be chars, or just be floats.

336
00:16:00,965 --> 00:16:02,240

337
00:16:02,240 --> 00:16:05,470
>> But maybe you need to
contain more than that.

338
00:16:05,470 --> 00:16:09,130
Maybe you need to hold-- if
you're talking about a student,

339
00:16:09,130 --> 00:16:13,660
you're going to have their house, their
ID number, their age, where they live,

340
00:16:13,660 --> 00:16:14,240
right?

341
00:16:14,240 --> 00:16:16,460
And all of those are
different sorts of types.

342
00:16:16,460 --> 00:16:18,680
So you can't store
those all in an array.

343
00:16:18,680 --> 00:16:21,750
>> So what you can do is you
can create a struct, which

344
00:16:21,750 --> 00:16:26,240
you can think of as your
own personal data type.

345
00:16:26,240 --> 00:16:29,130
So instead of just having ints
and instead of just having floats,

346
00:16:29,130 --> 00:16:33,210
you can have a type student that
has all of these fields in it.

347
00:16:33,210 --> 00:16:39,740
So the way we initialize
our structs is-- actually

348
00:16:39,740 --> 00:16:44,921
since my writing is terrible, we
are going to transition to typing.

349
00:16:44,921 --> 00:16:45,420
Woo.

350
00:16:45,420 --> 00:16:48,800

351
00:16:48,800 --> 00:16:53,150
>> OK, so if we want to create a struct--
I'm just going to it down here.

352
00:16:53,150 --> 00:16:57,730
Disregard the in main whatever
which we will use later.

353
00:16:57,730 --> 00:17:02,330
So the way you want to do
it is with typedef struct.

354
00:17:02,330 --> 00:17:10,530

355
00:17:10,530 --> 00:17:13,349
And let's just call this student
because that's what I was using.

356
00:17:13,349 --> 00:17:17,801
OK, so typedef means you're
defining a new type, OK?

357
00:17:17,801 --> 00:17:20,140

358
00:17:20,140 --> 00:17:24,355
There are nuances into when you do
just a struct versus a typedef struct.

359
00:17:24,355 --> 00:17:26,313
For all intents and
purposes, you guys are just

360
00:17:26,313 --> 00:17:29,490
going to assume they're
approximately the same and just

361
00:17:29,490 --> 00:17:30,820
use typedef struct for now.

362
00:17:30,820 --> 00:17:35,180
It'll become way more apparent in your
next P set what those differences are,

363
00:17:35,180 --> 00:17:37,960
but I don't think you need to
worry about that right now.

364
00:17:37,960 --> 00:17:40,360
I would much rather you
know how to create one,

365
00:17:40,360 --> 00:17:41,880
access it, and assign [? value. ?]

366
00:17:41,880 --> 00:17:47,820
>> A new type of struct, and
we are calling it student.

367
00:17:47,820 --> 00:17:52,640
So after we're done creating this,
for all intents and purposes,

368
00:17:52,640 --> 00:17:55,070
you will have a type called student.

369
00:17:55,070 --> 00:17:59,610
And you can think of it just as a type
like an int, or a float, or a char.

370
00:17:59,610 --> 00:18:01,820
It's just another type, OK?

371
00:18:01,820 --> 00:18:04,530
>> So in this one, what do we have?

372
00:18:04,530 --> 00:18:05,420
We have maybe a name.

373
00:18:05,420 --> 00:18:08,275
So maybe we want a string name.

374
00:18:08,275 --> 00:18:09,610

375
00:18:09,610 --> 00:18:14,065
And we have maybe an int that's an ID.

376
00:18:14,065 --> 00:18:16,360

377
00:18:16,360 --> 00:18:19,085
And we have another in
that's phone number.

378
00:18:19,085 --> 00:18:21,990

379
00:18:21,990 --> 00:18:26,200
And we have some-- let's see.

380
00:18:26,200 --> 00:18:27,200
What else might we have?

381
00:18:27,200 --> 00:18:29,385
We'll have some string at his house.

382
00:18:29,385 --> 00:18:32,340

383
00:18:32,340 --> 00:18:34,510
All things that a student has.

384
00:18:34,510 --> 00:18:36,960
>> So this creates a struct now.

385
00:18:36,960 --> 00:18:41,450
So how might we create a student?

386
00:18:41,450 --> 00:18:46,960
If we have some variable that is
going to talk about Walker here,

387
00:18:46,960 --> 00:18:51,245
so we have-- we're just
going to call this walker.

388
00:18:51,245 --> 00:18:52,520
He needs a type.

389
00:18:52,520 --> 00:18:53,770
What's your type?

390
00:18:53,770 --> 00:18:54,520
AUDIENCE: Student.

391
00:18:54,520 --> 00:18:55,395
ALLISON BUCHHOLTZ-AU: Student.

392
00:18:55,395 --> 00:18:57,130

393
00:18:57,130 --> 00:19:04,800
So this just creates an object you can
think of that has all these things.

394
00:19:04,800 --> 00:19:07,880
You just created a walker student.

395
00:19:07,880 --> 00:19:10,910
So now we need to be able
to assign all these, right?

396
00:19:10,910 --> 00:19:13,500
So does anyone remember how
we access within a struct?

397
00:19:13,500 --> 00:19:14,762

398
00:19:14,762 --> 00:19:15,470
AUDIENCE: Period.

399
00:19:15,470 --> 00:19:16,730
ALLISON BUCHHOLTZ-AU: Period Exactly.

400
00:19:16,730 --> 00:19:23,795
So if we wanted to assign
him a name, we could do that.

401
00:19:23,795 --> 00:19:24,820

402
00:19:24,820 --> 00:19:28,680
Obviously this would
be-- this part here would

403
00:19:28,680 --> 00:19:31,831
be within main, so
actually let me do this.

404
00:19:31,831 --> 00:19:40,980

405
00:19:40,980 --> 00:19:44,250
Declare this above main so
that we can use it within main.

406
00:19:44,250 --> 00:19:52,250

407
00:19:52,250 --> 00:20:00,980
So now I want it to do ID,
and we'll just do some there,

408
00:20:00,980 --> 00:20:02,970
and then we'll assign a house.

409
00:20:02,970 --> 00:20:07,990

410
00:20:07,990 --> 00:20:09,000
Bam.

411
00:20:09,000 --> 00:20:09,650
Cool.

412
00:20:09,650 --> 00:20:19,870
>> So now should we ever need to access
anything later on-- maybe we--

413
00:20:19,870 --> 00:20:25,920
if we ever need to access anything,
let's just do an int copy ID.

414
00:20:25,920 --> 00:20:27,400

415
00:20:27,400 --> 00:20:30,530
And I want to copy
Walker's ID into this.

416
00:20:30,530 --> 00:20:31,370
How might I do it?

417
00:20:31,370 --> 00:20:33,670

418
00:20:33,670 --> 00:20:37,790
You need to access within the walker
struct to [? go to that ?] [? E ?].

419
00:20:37,790 --> 00:20:41,280
And the same way that we
assigned it up here, how

420
00:20:41,280 --> 00:20:45,573
might we access it when we want to
give that value to something else?

421
00:20:45,573 --> 00:20:46,406
AUDIENCE: Walker.id.

422
00:20:46,406 --> 00:20:47,252

423
00:20:47,252 --> 00:20:48,376
ALLISON BUCHHOLTZ-AU: Yeah, exactly.

424
00:20:48,376 --> 00:20:51,884

425
00:20:51,884 --> 00:20:54,175
So that's pretty much all
you need to know for structs.

426
00:20:54,175 --> 00:20:55,750

427
00:20:55,750 --> 00:20:58,560
You just need to think of
them as another variable.

428
00:20:58,560 --> 00:21:01,710
Basically a create your
own variable type, OK?

429
00:21:01,710 --> 00:21:04,440

430
00:21:04,440 --> 00:21:07,970
You use it to declare
variables in any way.

431
00:21:07,970 --> 00:21:10,290
Here walker is still a variable.

432
00:21:10,290 --> 00:21:14,230
It just has a type student now instead
of a type int, or a type string,

433
00:21:14,230 --> 00:21:15,070
or a type char.

434
00:21:15,070 --> 00:21:17,014

435
00:21:17,014 --> 00:21:19,930
If there was an easy way to talk
about structs, it is literally just a

436
00:21:19,930 --> 00:21:24,430
create your own data type
that allows you to group

437
00:21:24,430 --> 00:21:28,320
all these different
kind of data together.

438
00:21:28,320 --> 00:21:29,754

439
00:21:29,754 --> 00:21:31,595
Does that makes sense?

440
00:21:31,595 --> 00:21:33,920

441
00:21:33,920 --> 00:21:34,420
OK.

442
00:21:34,420 --> 00:21:35,920

443
00:21:35,920 --> 00:21:37,530
That and accessing with dots.

444
00:21:37,530 --> 00:21:38,790

445
00:21:38,790 --> 00:21:39,960
Pretty much all you need.

446
00:21:39,960 --> 00:21:41,150

447
00:21:41,150 --> 00:21:46,600
>> OK, where did my PowerPoint go?

448
00:21:46,600 --> 00:21:47,580
Here it is.

449
00:21:47,580 --> 00:21:49,050

450
00:21:49,050 --> 00:21:50,520
Well this is weird.

451
00:21:50,520 --> 00:21:53,950

452
00:21:53,950 --> 00:21:55,420
Aha.

453
00:21:55,420 --> 00:21:56,766
OK, cool.

454
00:21:56,766 --> 00:21:58,876

455
00:21:58,876 --> 00:22:01,000
Any other things or do we
want to head to practice?

456
00:22:01,000 --> 00:22:02,210

457
00:22:02,210 --> 00:22:02,710
Practice?

458
00:22:02,710 --> 00:22:03,501
OK.

459
00:22:03,501 --> 00:22:04,000
Awesome.

460
00:22:04,000 --> 00:22:05,642

461
00:22:05,642 --> 00:22:06,600
I'm going to exit this.

462
00:22:06,600 --> 00:22:08,490
If at any point during
practice questions,

463
00:22:08,490 --> 00:22:12,630
I'm happy to revamp
and go through things.

464
00:22:12,630 --> 00:22:15,240
So I have quiz zero up here.

465
00:22:15,240 --> 00:22:18,370
If you guys want to pull
it up on your computer,

466
00:22:18,370 --> 00:22:20,670
just like take five
minutes to browse through.

467
00:22:20,670 --> 00:22:23,540
Maybe choose some top
questions you want to go over.

468
00:22:23,540 --> 00:22:27,390
If you guys can't decide, we'll just
slowly start working through them,

469
00:22:27,390 --> 00:22:31,590
but I'm sure there are going to be some
questions that you are particularly

470
00:22:31,590 --> 00:22:34,890
eager to talk about and have
me work through with you all.

471
00:22:34,890 --> 00:22:36,580
So just go ahead and take five minutes.

472
00:22:36,580 --> 00:22:37,780
Scroll through.

473
00:22:37,780 --> 00:22:40,620
And this is the quiz from 2013.

474
00:22:40,620 --> 00:22:41,841
>> AUDIENCE: Zero?

475
00:22:41,841 --> 00:22:43,630
>> ALLISON BUCHHOLTZ-AU: Yeah, quiz zero.

476
00:22:43,630 --> 00:22:45,647
We're not doing quiz one stuff.

477
00:22:45,647 --> 00:22:46,980
We'll do that in a couple weeks.

478
00:22:46,980 --> 00:22:52,941

479
00:22:52,941 --> 00:22:55,190
Also for those of you who
came in late, we have candy,

480
00:22:55,190 --> 00:23:00,580
so do you guys want candy?

481
00:23:00,580 --> 00:23:01,530
>> AUDIENCE: Sure.

482
00:23:01,530 --> 00:23:03,321
>> ALLISON BUCHHOLTZ-AU: I'm just
going to pass around.

483
00:23:03,321 --> 00:23:09,774

484
00:23:09,774 --> 00:23:11,940
Hey, if you guys get here
early, you get more candy.

485
00:23:11,940 --> 00:23:12,500
That's fine.

486
00:23:12,500 --> 00:23:13,550
Ben, do you want candy?

487
00:23:13,550 --> 00:23:19,350

488
00:23:19,350 --> 00:23:20,556
You want some of these?

489
00:23:20,556 --> 00:23:24,122

490
00:23:24,122 --> 00:23:26,080
There's also Snickers if
anyone wants Snickers.

491
00:23:26,080 --> 00:23:27,640

492
00:23:27,640 --> 00:23:29,360
I'll leave them here and here.

493
00:23:29,360 --> 00:23:30,946
Feel free.

494
00:23:30,946 --> 00:23:32,485
Do you want anymore?

495
00:23:32,485 --> 00:23:33,235
AUDIENCE: All set.

496
00:23:33,235 --> 00:23:33,540
Thank you.

497
00:23:33,540 --> 00:23:36,248
>> ALLISON BUCHHOLTZ-AU: And I had a nice
little pile there at the beginning.

498
00:23:36,248 --> 00:23:49,080

499
00:23:49,080 --> 00:23:51,980
You guys get to take the quiz and
I get to have a quiz grading party.

500
00:23:51,980 --> 00:23:54,496

501
00:23:54,496 --> 00:23:55,360
It's chaos.

502
00:23:55,360 --> 00:23:56,460

503
00:23:56,460 --> 00:23:57,385
900 exams.

504
00:23:57,385 --> 00:23:58,650
It's going to be so much fun.

505
00:23:58,650 --> 00:24:00,441

506
00:24:00,441 --> 00:24:02,036
Going to be great.

507
00:24:02,036 --> 00:24:04,430
I'm pretty sure that's one
of the biggest staff bonding

508
00:24:04,430 --> 00:24:05,380
nights of the year.

509
00:24:05,380 --> 00:24:15,660

510
00:24:15,660 --> 00:24:19,175
Has anyone done quiz zero from
last year yet out of curiosity?

511
00:24:19,175 --> 00:24:20,335
>> AUDIENCE: Parts of it.

512
00:24:20,335 --> 00:24:21,543
>> ALLISON BUCHHOLTZ-AU: Parts of it, OK.

513
00:24:21,543 --> 00:24:24,272

514
00:24:24,272 --> 00:24:26,482
Did you have questions on any of them?

515
00:24:26,482 --> 00:24:28,190
AUDIENCE: I already
went to office hours.

516
00:24:28,190 --> 00:24:28,898
Thank you though.

517
00:24:28,898 --> 00:24:30,187

518
00:24:30,187 --> 00:24:32,520
ALLISON BUCHHOLTZ-AU: Well, hopefully
it's still kind of helpful.

519
00:24:32,520 --> 00:24:42,990

520
00:24:42,990 --> 00:24:45,634
When did you go to
office hours for that?

521
00:24:45,634 --> 00:24:47,300
AUDIENCE: My TF had them this afternoon.

522
00:24:47,300 --> 00:24:47,966
ALLISON BUCHHOLTZ-AU: Oh.

523
00:24:47,966 --> 00:24:48,977
Who's your TF?

524
00:24:48,977 --> 00:24:49,854

525
00:24:49,854 --> 00:24:51,020
AUDIENCE: Fred [? Wujaya ?].

526
00:24:51,020 --> 00:24:52,622

527
00:24:52,622 --> 00:24:54,080
ALLISON BUCHHOLTZ-AU: There are so many TFs.

528
00:24:54,080 --> 00:24:55,350

529
00:24:55,350 --> 00:24:55,850
So many.

530
00:24:55,850 --> 00:25:16,530

531
00:25:16,530 --> 00:25:17,340
All right.

532
00:25:17,340 --> 00:25:45,310

533
00:25:45,310 --> 00:25:48,950
Anyone have any to start that I can
jot down that we want to work on?

534
00:25:48,950 --> 00:25:53,770

535
00:25:53,770 --> 00:25:55,685
I assume the pointers
one with the table.

536
00:25:55,685 --> 00:25:56,890

537
00:25:56,890 --> 00:25:57,610
Go for it.

538
00:25:57,610 --> 00:25:59,180
>> AUDIENCE: Maybe the switch one.

539
00:25:59,180 --> 00:26:02,362

540
00:26:02,362 --> 00:26:03,445
ALLISON BUCHHOLTZ-AU: So number 12?

541
00:26:03,445 --> 00:26:06,750

542
00:26:06,750 --> 00:26:10,770
I assume number 8 and 9 are probably
ones people want to go over.

543
00:26:10,770 --> 00:26:12,116
>> AUDIENCE: And 10 and 11.

544
00:26:12,116 --> 00:26:21,860

545
00:26:21,860 --> 00:26:25,806
>> ALLISON BUCHHOLTZ-AU: And you guys know
you get one page of notes, right?

546
00:26:25,806 --> 00:26:28,450
>> AUDIENCE: Yeah, so what are
we allowed to put on that.

547
00:26:28,450 --> 00:26:30,658
>> ALLISON BUCHHOLTZ-AU: You're allowed
to put anything you want.

548
00:26:30,658 --> 00:26:31,887

549
00:26:31,887 --> 00:26:32,720
And it can be typed.

550
00:26:32,720 --> 00:26:35,270
As far as I remember, ours were typed.

551
00:26:35,270 --> 00:26:37,022
>> AUDIENCE: You can do
back and both sides?

552
00:26:37,022 --> 00:26:38,780
>> ALLISON BUCHHOLTZ-AU: Yeah, both sides.

553
00:26:38,780 --> 00:26:42,940
So something like the heap and
[? back end ?] heap, your running

554
00:26:42,940 --> 00:26:43,780
times.

555
00:26:43,780 --> 00:26:44,840
Useful.

556
00:26:44,840 --> 00:26:47,990
Maybe little things about
pointers to remind you.

557
00:26:47,990 --> 00:26:49,205
Syntax for things.

558
00:26:49,205 --> 00:26:51,600

559
00:26:51,600 --> 00:26:54,830
Having just like a skeleton
program can be super useful.

560
00:26:54,830 --> 00:27:00,719
I know that I always forgot exactly what
I was supposed to write for int main,

561
00:27:00,719 --> 00:27:03,010
because I always just copy
paste from my previous P set

562
00:27:03,010 --> 00:27:06,232
or it's already there, so
I never really wrote it,

563
00:27:06,232 --> 00:27:07,690
so having that can be super useful.

564
00:27:07,690 --> 00:27:09,280

565
00:27:09,280 --> 00:27:14,320
>> OK, so why don't we
start with number 8 then?

566
00:27:14,320 --> 00:27:21,730

567
00:27:21,730 --> 00:27:22,810
All right.

568
00:27:22,810 --> 00:27:23,310
OK.

569
00:27:23,310 --> 00:27:25,060

570
00:27:25,060 --> 00:27:26,310
So consider the program below.

571
00:27:26,310 --> 00:27:28,110

572
00:27:28,110 --> 00:27:30,700
So obviously when we see
pointers, it's probably

573
00:27:30,700 --> 00:27:32,200
a good idea to start drawing, right?

574
00:27:32,200 --> 00:27:34,552

575
00:27:34,552 --> 00:27:36,760
I want to know where all my
big pieces of chalk went.

576
00:27:36,760 --> 00:27:37,870
This is kind of annoying.

577
00:27:37,870 --> 00:27:40,210

578
00:27:40,210 --> 00:27:45,820
>> So we have here some swap function
that's going to take in two pointers.

579
00:27:45,820 --> 00:27:48,630
So in this case, they
should actually be switching

580
00:27:48,630 --> 00:27:53,400
things versus our original swap
function that only took in copies.

581
00:27:53,400 --> 00:27:57,030
So what it's going to do
is-- let's start with main,

582
00:27:57,030 --> 00:27:58,450
because that's where 1 is.

583
00:27:58,450 --> 00:28:04,296
>> So we have some int x 1.

584
00:28:04,296 --> 00:28:11,860
We have some y that's equal to 2.

585
00:28:11,860 --> 00:28:14,390
And then we have some swap
that's going to take those.

586
00:28:14,390 --> 00:28:17,320
And let's see what do we have here.

587
00:28:17,320 --> 00:28:19,542

588
00:28:19,542 --> 00:28:22,709
And in our table-- oh boy.

589
00:28:22,709 --> 00:28:23,792
How am I going to do this?

590
00:28:23,792 --> 00:28:25,900
I'm going to draw my table over here.

591
00:28:25,900 --> 00:28:49,490

592
00:28:49,490 --> 00:28:50,552
Barely making it there.

593
00:28:50,552 --> 00:28:51,260
Barely making it.

594
00:28:51,260 --> 00:28:52,470

595
00:28:52,470 --> 00:28:57,960
1, 2, 3, 4, 5, 6, 7.

596
00:28:57,960 --> 00:29:11,220

597
00:29:11,220 --> 00:29:15,706
And they give us that 1 is 1, and 1 2.

598
00:29:15,706 --> 00:29:16,206
Cool.

599
00:29:16,206 --> 00:29:17,674

600
00:29:17,674 --> 00:29:18,174
Awesome.

601
00:29:18,174 --> 00:29:19,650

602
00:29:19,650 --> 00:29:20,464
So 3.

603
00:29:20,464 --> 00:29:21,380
And there's [? a 1. ?]

604
00:29:21,380 --> 00:29:24,500

605
00:29:24,500 --> 00:29:25,250
>> All right.

606
00:29:25,250 --> 00:29:35,202
And then address of x is 0x123.

607
00:29:35,202 --> 00:29:41,260
And y is Ox127.

608
00:29:41,260 --> 00:29:41,760
Cool.

609
00:29:41,760 --> 00:29:42,940

610
00:29:42,940 --> 00:29:43,595
All right.

611
00:29:43,595 --> 00:29:46,710
I want you guys work on this
for just like-- work on it

612
00:29:46,710 --> 00:29:48,385
with the people around you.

613
00:29:48,385 --> 00:29:50,340
I wish I had said that
while I was setting up.

614
00:29:50,340 --> 00:29:50,840
Work on it.

615
00:29:50,840 --> 00:29:53,270
Try and work on it by
yourselves for a couple minutes,

616
00:29:53,270 --> 00:29:54,930
and then I will work on it with you.

617
00:29:54,930 --> 00:29:57,034

618
00:29:57,034 --> 00:30:00,117
Because the only way you're really
going to learn is by doing it yourself.

619
00:30:00,117 --> 00:31:29,580

620
00:31:29,580 --> 00:31:30,110
No worries.

621
00:31:30,110 --> 00:31:30,610
Good luck.

622
00:31:30,610 --> 00:32:17,390

623
00:32:17,390 --> 00:32:20,030
>> OK, why don't we slowly
start working through this.

624
00:32:20,030 --> 00:32:23,695
So everyone gets after line one, x is 1.

625
00:32:23,695 --> 00:32:26,860
After line two, x and
y are 1 and 2, right?

626
00:32:26,860 --> 00:32:27,400
Cool.

627
00:32:27,400 --> 00:32:30,310
So line three is where things
get interesting of course.

628
00:32:30,310 --> 00:32:34,970
>> So what we've done here
is we have now swapped.

629
00:32:34,970 --> 00:32:42,360
We say that x and y have those points,
or they have the address of x and y,

630
00:32:42,360 --> 00:32:43,390
right?

631
00:32:43,390 --> 00:32:48,451
So in this case, three,
what is the value of a?

632
00:32:48,451 --> 00:32:52,379

633
00:32:52,379 --> 00:32:59,806
a had been passed in, has been given
the value of the address of x, right?

634
00:32:59,806 --> 00:33:02,542

635
00:33:02,542 --> 00:33:03,454
>> AUDIENCE: 1?

636
00:33:03,454 --> 00:33:05,200
>> ALLISON BUCHHOLTZ-AU: So we add it to the x?

637
00:33:05,200 --> 00:33:06,420
What's x's address?

638
00:33:06,420 --> 00:33:07,212
>> AUDIENCE: 0x123.

639
00:33:07,212 --> 00:33:08,087
>> ALLISON BUCHHOLTZ-AU: Exactly.

640
00:33:08,087 --> 00:33:13,960

641
00:33:13,960 --> 00:33:16,790
But what is a actually pointing to?

642
00:33:16,790 --> 00:33:20,790
If we were to dereference a,
what value would it give us.

643
00:33:20,790 --> 00:33:21,290
AUDIENCE: 1.

644
00:33:21,290 --> 00:33:23,164
ALLISON BUCHHOLTZ-AU: It would
give us 1, because what

645
00:33:23,164 --> 00:33:27,810
we're saying is go to this
address, tell us what the value is.

646
00:33:27,810 --> 00:33:28,890
So what would be b?

647
00:33:28,890 --> 00:33:30,500

648
00:33:30,500 --> 00:33:31,445
>> AUDIENCE: 0x127.

649
00:33:31,445 --> 00:33:32,320
ALLISON BUCHHOLTZ-AU: Exactly.

650
00:33:32,320 --> 00:33:33,610

651
00:33:33,610 --> 00:33:35,410
So it's the address of y.

652
00:33:35,410 --> 00:33:36,580

653
00:33:36,580 --> 00:33:39,811
And then what [? dereference? ?]

654
00:33:39,811 --> 00:33:40,310
AUDIENCE: 2.

655
00:33:40,310 --> 00:33:42,172

656
00:33:42,172 --> 00:33:43,380
ALLISON BUCHHOLTZ-AU: OK, so now four.

657
00:33:43,380 --> 00:33:44,390

658
00:33:44,390 --> 00:33:51,300
We said a is equal-- well now we've
done int temp is equal to star of a.

659
00:33:51,300 --> 00:33:53,580
So what changes?

660
00:33:53,580 --> 00:33:55,680
There's only one thing
that changes here.

661
00:33:55,680 --> 00:33:56,180
What is it?

662
00:33:56,180 --> 00:33:57,892

663
00:33:57,892 --> 00:33:58,624
>> AUDIENCE: Temp.

664
00:33:58,624 --> 00:33:59,540
ALLISON BUCHHOLTZ-AU: The temp.

665
00:33:59,540 --> 00:34:06,120
So we can rewrite all of these.

666
00:34:06,120 --> 00:34:07,790

667
00:34:07,790 --> 00:34:10,690
A good strategy for these
is just figuring out

668
00:34:10,690 --> 00:34:14,050
what changes, because most often
there's only one thing that's

669
00:34:14,050 --> 00:34:16,300
going to change at any given point, OK?

670
00:34:16,300 --> 00:34:17,960

671
00:34:17,960 --> 00:34:20,100
So we've assigned temp.

672
00:34:20,100 --> 00:34:26,929
>> Now our next point, five, we
have made star a equal to star b.

673
00:34:26,929 --> 00:34:28,880
So what changes now?

674
00:34:28,880 --> 00:34:29,760
>> AUDIENCE: Star a.

675
00:34:29,760 --> 00:34:32,081
>> ALLISON BUCHHOLTZ-AU: Star a, so
everything else stays the same.

676
00:34:32,081 --> 00:34:38,610

677
00:34:38,610 --> 00:34:39,900
And what does star a equal?

678
00:34:39,900 --> 00:34:40,659
>> AUDIENCE: 2.

679
00:34:40,659 --> 00:34:41,283
ALLISON BUCHHOLTZ-AU: 2.

680
00:34:41,283 --> 00:34:42,460

681
00:34:42,460 --> 00:34:42,960
Lovely.

682
00:34:42,960 --> 00:34:45,360

683
00:34:45,360 --> 00:34:46,239
Awesome.

684
00:34:46,239 --> 00:34:51,190
OK, and then now we have
start b is equal to temp.

685
00:34:51,190 --> 00:34:53,907
So the only thing changing is star b.

686
00:34:53,907 --> 00:34:55,344
Everything else stays the same.

687
00:34:55,344 --> 00:35:01,100

688
00:35:01,100 --> 00:35:02,610
And what is star b equal to now?

689
00:35:02,610 --> 00:35:04,840

690
00:35:04,840 --> 00:35:06,190
And you've completed the table.

691
00:35:06,190 --> 00:35:11,620

692
00:35:11,620 --> 00:35:18,460
Because now at the end, if we say x
and y, we know that at this point--

693
00:35:18,460 --> 00:35:23,060
we know that when we
changed star a to 2,

694
00:35:23,060 --> 00:35:29,620
what that did is it said OK, at
address 0x123 here, change it.

695
00:35:29,620 --> 00:35:31,780

696
00:35:31,780 --> 00:35:33,290
Now this was 2.

697
00:35:33,290 --> 00:35:34,460

698
00:35:34,460 --> 00:35:40,600
And then at this point,
we said OK, go to star b.

699
00:35:40,600 --> 00:35:45,305
So go to the address at
0x127 and make it a 1.

700
00:35:45,305 --> 00:35:49,670

701
00:35:49,670 --> 00:35:53,110
So now at the very end when
we actually return for main,

702
00:35:53,110 --> 00:35:56,445
we actually have that x is
equal to 2 and y is equal to 1.

703
00:35:56,445 --> 00:35:58,500

704
00:35:58,500 --> 00:35:59,500
Everyone good with that?

705
00:35:59,500 --> 00:36:00,720

706
00:36:00,720 --> 00:36:02,320
OK, cool.

707
00:36:02,320 --> 00:36:04,030
Number 9.

708
00:36:04,030 --> 00:36:05,950
You guys work on this.

709
00:36:05,950 --> 00:36:09,016
I'm going to set up a board
so we can draw through it.

710
00:36:09,016 --> 00:36:09,910
It'll be a blast.

711
00:36:09,910 --> 00:36:13,760

712
00:36:13,760 --> 00:36:16,320
The big tables can be
really scary, I know.

713
00:36:16,320 --> 00:36:19,910
But if you just take them one row at
a time, they get a lot less scary.

714
00:36:19,910 --> 00:38:12,025

715
00:38:12,025 --> 00:38:12,860
All right.

716
00:38:12,860 --> 00:38:16,230

717
00:38:16,230 --> 00:38:21,190
>> So you know that this will have
gone through main first, right?

718
00:38:21,190 --> 00:38:24,140
Initializes x and y and
then tries to swap them.

719
00:38:24,140 --> 00:38:28,560
So even swap is above, real way it
goes is that we're going through main,

720
00:38:28,560 --> 00:38:31,040
and then it's calling
up to swap, all right?

721
00:38:31,040 --> 00:38:32,810
So everyone knows that.

722
00:38:32,810 --> 00:38:34,960
>> So which one do you
guys want to start with?

723
00:38:34,960 --> 00:38:37,240
Is anyone really sure
about one of these?

724
00:38:37,240 --> 00:38:38,307

725
00:38:38,307 --> 00:38:39,265
Or even partially sure?

726
00:38:39,265 --> 00:38:44,170

727
00:38:44,170 --> 00:38:48,120
Why don't we start with x?

728
00:38:48,120 --> 00:38:49,060
What do we think x is?

729
00:38:49,060 --> 00:38:49,735
>> AUDIENCE: 1.

730
00:38:49,735 --> 00:38:50,360
ALLISON BUCHHOLTZ-AU: 1.

731
00:38:50,360 --> 00:38:54,500

732
00:38:54,500 --> 00:38:56,340
So then why is 2.

733
00:38:56,340 --> 00:38:58,880

734
00:38:58,880 --> 00:39:01,380
And that's because the
big distinction here

735
00:39:01,380 --> 00:39:04,890
is that we are only
passing copies in, right?

736
00:39:04,890 --> 00:39:06,520
We're not passing by reference.

737
00:39:06,520 --> 00:39:08,850
So even at the end of
this program x and y

738
00:39:08,850 --> 00:39:14,170
have stayed the same, because they
are just copies in the swap function.

739
00:39:14,170 --> 00:39:16,320
They don't actually change, right?

740
00:39:16,320 --> 00:39:17,570

741
00:39:17,570 --> 00:39:19,290
>> So what about a, b, and temp?

742
00:39:19,290 --> 00:39:21,540

743
00:39:21,540 --> 00:39:22,890
>> AUDIENCE: a is b.

744
00:39:22,890 --> 00:39:23,940
>> ALLISON BUCHHOLTZ-AU: a is b.

745
00:39:23,940 --> 00:39:28,569
So in this case, a was
x, which is 1, right?

746
00:39:28,569 --> 00:39:29,860
So here, let's walk through it.

747
00:39:29,860 --> 00:39:33,940
So at the beginning, a and
b are 1 and 2 and undefined.

748
00:39:33,940 --> 00:39:35,000

749
00:39:35,000 --> 00:39:40,850
So originally temp gets
assigned to a, so temp is 1.

750
00:39:40,850 --> 00:39:46,150
a is equal to b, So we get
2, and b is equal to temp.

751
00:39:46,150 --> 00:39:47,284
Now we get 1.

752
00:39:47,284 --> 00:39:49,454

753
00:39:49,454 --> 00:39:55,860
>> AUDIENCE: In the previous one it
swapped ampersand x and ampersand y.

754
00:39:55,860 --> 00:39:57,390
What exactly does that mean?

755
00:39:57,390 --> 00:39:59,890
ALLISON BUCHHOLTZ-AU: So that means that
you're passing by reference.

756
00:39:59,890 --> 00:40:03,830
So that means you're actually
passing in the addresses of where

757
00:40:03,830 --> 00:40:04,814
x and y are stored.

758
00:40:04,814 --> 00:40:06,730
AUDIENCE: But you're not
swapping the address.

759
00:40:06,730 --> 00:40:07,860
ALLISON BUCHHOLTZ-AU: You're not
swapping the addresses.

760
00:40:07,860 --> 00:40:10,015
You're swapping what's within them.

761
00:40:10,015 --> 00:40:11,510

762
00:40:11,510 --> 00:40:14,460
Like what's at that address,
and that's why it works.

763
00:40:14,460 --> 00:40:20,750
Versus in this program here what
you're doing is you're creating copies.

764
00:40:20,750 --> 00:40:27,440
So you have x and y that exist
as their own variables out here.

765
00:40:27,440 --> 00:40:31,530

766
00:40:31,530 --> 00:40:34,140
But then when you pass
them into swap, it's

767
00:40:34,140 --> 00:40:38,090
as if you're creating
this whole other set.

768
00:40:38,090 --> 00:40:41,272
So you're never actually
touching x and y.

769
00:40:41,272 --> 00:40:46,890
>> AUDIENCE: If ampersand x is what is at
the address of x, what would star x be?

770
00:40:46,890 --> 00:40:53,290
>> ALLISON BUCHHOLTZ-AU: Ampersand x is what's at
the address of x, then star-- well,

771
00:40:53,290 --> 00:40:54,950
in this case, x is not a pointer.

772
00:40:54,950 --> 00:40:56,332

773
00:40:56,332 --> 00:40:57,040
AUDIENCE: Oh, OK.

774
00:40:57,040 --> 00:40:58,998
So you only do this
because it's not a pointer.

775
00:40:58,998 --> 00:40:59,890
ALLISON BUCHHOLTZ-AU: Right.

776
00:40:59,890 --> 00:41:03,046
You can only do star of
something that's a pointer.

777
00:41:03,046 --> 00:41:05,920
Maybe you could do it to things that
aren't, but the compile that you

778
00:41:05,920 --> 00:41:07,350
do that crazy things would happen.

779
00:41:07,350 --> 00:41:09,570
And I'm not exactly
sure what would happen.

780
00:41:09,570 --> 00:41:11,880
You can always take the
address of something,

781
00:41:11,880 --> 00:41:14,255
but you can't dereference
something that's not a pointer.

782
00:41:14,255 --> 00:41:14,805

783
00:41:14,805 --> 00:41:17,860
If that makes sense, that's
a good distinction to have.

784
00:41:17,860 --> 00:41:19,870

785
00:41:19,870 --> 00:41:21,340
>> So not too bad, right?

786
00:41:21,340 --> 00:41:23,650
The tables are hopefully
getting slightly less scary.

787
00:41:23,650 --> 00:41:25,450

788
00:41:25,450 --> 00:41:26,690
All right.

789
00:41:26,690 --> 00:41:28,370
Ah, the fun ones.

790
00:41:28,370 --> 00:41:31,265
So now, writing your own code.

791
00:41:31,265 --> 00:41:33,640

792
00:41:33,640 --> 00:41:37,950
So I'm going to let you guys work
on this for about four minutes,

793
00:41:37,950 --> 00:41:41,480
and then we can talk
about ways to approach it.

794
00:41:41,480 --> 00:41:45,080

795
00:41:45,080 --> 00:41:47,110
Feel free to talk to people around you.

796
00:41:47,110 --> 00:41:48,114

797
00:41:48,114 --> 00:41:49,155
Also this is interesting.

798
00:41:49,155 --> 00:41:51,460
It's like an all girls
section right now.

799
00:41:51,460 --> 00:41:52,190
Pretty exciting.

800
00:41:52,190 --> 00:41:53,310

801
00:41:53,310 --> 00:41:54,502
Except for Chang.

802
00:41:54,502 --> 00:41:56,190
But Chang is not really part of section.

803
00:41:56,190 --> 00:42:17,282

804
00:42:17,282 --> 00:42:17,985
Awesome.

805
00:42:17,985 --> 00:42:18,485
Perfect.

806
00:42:18,485 --> 00:42:38,059

807
00:42:38,059 --> 00:42:39,475
So I will give you a couple hints.

808
00:42:39,475 --> 00:42:43,450

809
00:42:43,450 --> 00:42:46,890
In the case where you have
more than one character, where

810
00:42:46,890 --> 00:42:49,990
you have something else
like 123 or 1000 something,

811
00:42:49,990 --> 00:42:53,790
you need to be able to loop
through and convert each of those.

812
00:42:53,790 --> 00:42:55,340

813
00:42:55,340 --> 00:42:58,699
So there's a couple
ways you could do that,

814
00:42:58,699 --> 00:43:01,740
but you're definitely going to have
a for loop somewhere in there to loop

815
00:43:01,740 --> 00:43:05,150
through them, which is
kind of like the giveaway

816
00:43:05,150 --> 00:43:09,540
with even if you call strlen,
which is kind of like oh

817
00:43:09,540 --> 00:43:12,418
maybe you want to use the length
of the string in some way.

818
00:43:12,418 --> 00:45:17,300

819
00:45:17,300 --> 00:45:17,829
>> All right.

820
00:45:17,829 --> 00:45:20,870
So what do you guys think might be
one of the first things we want to do?

821
00:45:20,870 --> 00:45:23,149

822
00:45:23,149 --> 00:45:25,690
There's a couple cases in here
we need to account for, right?

823
00:45:25,690 --> 00:45:27,360
Either we have something that's null.

824
00:45:27,360 --> 00:45:28,685

825
00:45:28,685 --> 00:45:30,383
What do we have?

826
00:45:30,383 --> 00:45:30,882
Cases.

827
00:45:30,882 --> 00:45:32,760

828
00:45:32,760 --> 00:45:33,260
Null.

829
00:45:33,260 --> 00:45:34,400

830
00:45:34,400 --> 00:45:42,414
We have the case that it has
something other than 09, right?

831
00:45:42,414 --> 00:45:43,580
So let's say it has letters.

832
00:45:43,580 --> 00:45:44,900

833
00:45:44,900 --> 00:45:46,510
Or we have the case that's valid.

834
00:45:46,510 --> 00:45:48,450

835
00:45:48,450 --> 00:45:50,130
Three cases to think of.

836
00:45:50,130 --> 00:45:53,527
So which one do you think might be
the easiest one to take care of first?

837
00:45:53,527 --> 00:45:54,152
AUDIENCE: Null.

838
00:45:54,152 --> 00:45:55,527
ALLISON BUCHHOLTZ-AU: The case is null.

839
00:45:55,527 --> 00:45:56,610
So what would we do there?

840
00:45:56,610 --> 00:45:57,954

841
00:45:57,954 --> 00:45:58,870
AUDIENCE: [INAUDIBLE].

842
00:45:58,870 --> 00:46:02,434

843
00:46:02,434 --> 00:46:03,184
ALLISON BUCHHOLTZ-AU: Yeah.

844
00:46:03,184 --> 00:46:05,140

845
00:46:05,140 --> 00:46:06,550
And what do I want to do?

846
00:46:06,550 --> 00:46:07,341
>> AUDIENCE: Return 0.

847
00:46:07,341 --> 00:46:07,935

848
00:46:07,935 --> 00:46:09,110
>> ALLISON BUCHHOLTZ-AU: Exactly.

849
00:46:09,110 --> 00:46:09,860
Awesome.

850
00:46:09,860 --> 00:46:10,640
OK.

851
00:46:10,640 --> 00:46:15,270
So now case that it has letters
and the case that it's valid.

852
00:46:15,270 --> 00:46:19,140
We can actually take care
of this within one loop, OK?

853
00:46:19,140 --> 00:46:22,710
So one way to do it-- what might be
a simple way to check if it's valid.

854
00:46:22,710 --> 00:46:25,150

855
00:46:25,150 --> 00:46:29,144
We would have to go through
each letter and do what?

856
00:46:29,144 --> 00:46:34,336

857
00:46:34,336 --> 00:46:35,640
>> AUDIENCE: Check if it's in--

858
00:46:35,640 --> 00:46:39,570
>> ALLISON BUCHHOLTZ-AU: Right, you can check
if it's between 0 and 9, right?

859
00:46:39,570 --> 00:46:40,880

860
00:46:40,880 --> 00:46:42,700
And then in the case
that it's valid, we're

861
00:46:42,700 --> 00:46:46,550
going to end up iterating through
our string anyways, right?

862
00:46:46,550 --> 00:46:48,690
So why don't we try and
combine them into one.

863
00:46:48,690 --> 00:46:51,260
We're going to iterate
through out string, and as we

864
00:46:51,260 --> 00:46:56,400
do that, we're going to first
do a check to see if that letter

865
00:46:56,400 --> 00:46:58,110
or if that character is valid.

866
00:46:58,110 --> 00:47:02,150
If it is, we're going to perform the
operation that we need to convert it.

867
00:47:02,150 --> 00:47:05,050
Otherwise it'll return 0, right?

868
00:47:05,050 --> 00:47:09,160
>> So before we do that, we
probably want some variable

869
00:47:09,160 --> 00:47:12,820
that we can return at the end
that's going to be our actual value.

870
00:47:12,820 --> 00:47:17,005
So we're going to initialize
some value to be 0.

871
00:47:17,005 --> 00:47:18,390
And that's just how we start.

872
00:47:18,390 --> 00:47:22,452

873
00:47:22,452 --> 00:47:23,785
So I'm going to get rid of this.

874
00:47:23,785 --> 00:47:26,750

875
00:47:26,750 --> 00:47:30,489
So how are we going to
iterate through this string.

876
00:47:30,489 --> 00:47:31,280
AUDIENCE: For loop.

877
00:47:31,280 --> 00:47:32,280
ALLISON BUCHHOLTZ-AU: A for loop.

878
00:47:32,280 --> 00:47:33,160
So what's our for?

879
00:47:33,160 --> 00:47:34,710

880
00:47:34,710 --> 00:47:35,909
>> AUDIENCE: i is 0.

881
00:47:35,909 --> 00:47:36,700
ALLISON BUCHHOLTZ-AU: Mm-hm.

882
00:47:36,700 --> 00:47:38,620

883
00:47:38,620 --> 00:47:41,180
And what are we iterating until?

884
00:47:41,180 --> 00:47:42,450
>> AUDIENCE: str length of s.

885
00:47:42,450 --> 00:47:47,920

886
00:47:47,920 --> 00:47:50,900
>> ALLISON BUCHHOLTZ-AU: OK, now remember
there's a better way. [INAUDIBLE].

887
00:47:50,900 --> 00:47:52,935
>> AUDIENCE: Yeah, we can do n equals.

888
00:47:52,935 --> 00:47:53,810
ALLISON BUCHHOLTZ-AU: Exactly.

889
00:47:53,810 --> 00:47:55,010

890
00:47:55,010 --> 00:47:56,190
>> AUDIENCE: i is less than n.

891
00:47:56,190 --> 00:47:57,559

892
00:47:57,559 --> 00:47:59,475
ALLISON BUCHHOLTZ-AU: And why
would we want to do that?

893
00:47:59,475 --> 00:48:00,815

894
00:48:00,815 --> 00:48:01,940
Do you remember the reason?

895
00:48:01,940 --> 00:48:04,180

896
00:48:04,180 --> 00:48:05,680
AUDIENCE: We have to recalculate it.

897
00:48:05,680 --> 00:48:08,735
ALLISON BUCHHOLTZ-AU: Becasue this way you
only have to calculate strlen once.

898
00:48:08,735 --> 00:48:09,750

899
00:48:09,750 --> 00:48:14,400
If you do i is less than strlen
s, that's means it recalculates

900
00:48:14,400 --> 00:48:17,050
the length every time
you run the for loop,

901
00:48:17,050 --> 00:48:20,800
which isn't a huge cost
of energy, but it's

902
00:48:20,800 --> 00:48:24,280
better practice to try and
do things like that once.

903
00:48:24,280 --> 00:48:27,610
Unless maybe you have a crazy string
that's changing at every iteration.

904
00:48:27,610 --> 00:48:30,371
But if it's staying the same, save it.

905
00:48:30,371 --> 00:48:30,870
All right.

906
00:48:30,870 --> 00:48:33,430
And then i plus plus.

907
00:48:33,430 --> 00:48:34,040
Awesome.

908
00:48:34,040 --> 00:48:35,789
We are on our way.

909
00:48:35,789 --> 00:48:36,830
AUDIENCE: Really quickly.

910
00:48:36,830 --> 00:48:39,600
First, so let's say we just
did i less than strlen of s,

911
00:48:39,600 --> 00:48:42,175
are they grading us on design
at all or just correctness?

912
00:48:42,175 --> 00:48:43,640

913
00:48:43,640 --> 00:48:44,610
They're not.

914
00:48:44,610 --> 00:48:47,920
We are grading on correctness
for quizzes as far as I know.

915
00:48:47,920 --> 00:48:52,670
I cannot make a full on
guarantee, but for the most part,

916
00:48:52,670 --> 00:48:57,060
vast majority is correctness, because
you're under a lot of time constraint.

917
00:48:57,060 --> 00:48:59,704
Design typically means
you have time to think

918
00:48:59,704 --> 00:49:01,245
about the elegance of your situation.

919
00:49:01,245 --> 00:49:03,710

920
00:49:03,710 --> 00:49:05,770
>> OK, so we're iterating through.

921
00:49:05,770 --> 00:49:10,640
So we need to either check to
see if this character is valid

922
00:49:10,640 --> 00:49:14,550
or if we can perform our
normal [? a to i ?] function.

923
00:49:14,550 --> 00:49:16,600
We can worry about what
that is in a second.

924
00:49:16,600 --> 00:49:19,340
So why don't we take--
if anyone can think

925
00:49:19,340 --> 00:49:21,930
about a way to check to
see if this is valid.

926
00:49:21,930 --> 00:49:23,346

927
00:49:23,346 --> 00:49:25,740
We know it's going to be
some if condition, right?

928
00:49:25,740 --> 00:49:26,830

929
00:49:26,830 --> 00:49:32,300
And remember this is
in ASCII, so how might

930
00:49:32,300 --> 00:49:37,359
we see if it's not 0,1,
2, 3, 4, 5, 6, 7, 8, or 9.

931
00:49:37,359 --> 00:49:38,150
AUDIENCE: If alpha.

932
00:49:38,150 --> 00:49:39,800

933
00:49:39,800 --> 00:49:44,100
>> ALLISON BUCHHOLTZ-AU: So if alpha would
only let us know if it's a letter.

934
00:49:44,100 --> 00:49:47,810
And if they give us a symbol, it's
still not quite going to check.

935
00:49:47,810 --> 00:49:54,270
So if you pull up your ASCII
table, we know that 0 through 9

936
00:49:54,270 --> 00:49:55,340
are in one segment.

937
00:49:55,340 --> 00:49:57,560

938
00:49:57,560 --> 00:50:00,540
Tell me the numbers that they
correspond to if possible.

939
00:50:00,540 --> 00:50:08,136

940
00:50:08,136 --> 00:50:08,677
AUDIENCE: 40.

941
00:50:08,677 --> 00:50:11,440

942
00:50:11,440 --> 00:50:13,714
>> ALLISON BUCHHOLTZ-AU: So the range is like 40--

943
00:50:13,714 --> 00:50:14,380
AUDIENCE: Maybe.

944
00:50:14,380 --> 00:50:16,110

945
00:50:16,110 --> 00:50:16,765
48 to 57.

946
00:50:16,765 --> 00:50:17,430
I'm not sure.

947
00:50:17,430 --> 00:50:18,510
>> ALLISON BUCHHOLTZ-AU: 40 to 57?

948
00:50:18,510 --> 00:50:19,426
>> AUDIENCE: 48, I think.

949
00:50:19,426 --> 00:50:20,730
ALLISON BUCHHOLTZ-AU: 48 to 57.

950
00:50:20,730 --> 00:50:26,070
So we know that those ASCII
symbols-- if the ASCII value is not

951
00:50:26,070 --> 00:50:29,940
between 48 and 57,
it's not valid, right?

952
00:50:29,940 --> 00:50:32,050
So could we use that to
our advantage possibly?

953
00:50:32,050 --> 00:50:33,770

954
00:50:33,770 --> 00:50:38,082
How are we going to get
this letter, first off?

955
00:50:38,082 --> 00:50:40,910
How are we accessing
this this character?

956
00:50:40,910 --> 00:50:42,010
>> AUDIENCE: s bracket i.

957
00:50:42,010 --> 00:50:42,801
>> ALLISON BUCHHOLTZ-AU: Mm-hm.

958
00:50:42,801 --> 00:50:43,790

959
00:50:43,790 --> 00:50:46,285
Because we can think of
strings as arrays, remember.

960
00:50:46,285 --> 00:50:47,470

961
00:50:47,470 --> 00:50:48,740
So what do we want to say?

962
00:50:48,740 --> 00:50:55,920
We want to say if this
is-- I'll give you a hint.

963
00:50:55,920 --> 00:50:56,920
It's a less than.

964
00:50:56,920 --> 00:50:58,711
What to you think it
needs to be less than?

965
00:50:58,711 --> 00:50:59,074

966
00:50:59,074 --> 00:50:59,615
AUDIENCE: 57?

967
00:50:59,615 --> 00:51:01,550

968
00:51:01,550 --> 00:51:02,900
>> ALLISON BUCHHOLTZ-AU: 47, right?

969
00:51:02,900 --> 00:51:08,920
But it also represents that as you a 0
in single [? spokes ?], because that's

970
00:51:08,920 --> 00:51:09,689
the character 0.

971
00:51:09,689 --> 00:51:10,605
You could also put 47.

972
00:51:10,605 --> 00:51:11,660

973
00:51:11,660 --> 00:51:14,350
Having the ASCII table, as
you see, is just something

974
00:51:14,350 --> 00:51:18,580
you should have on your quiz sheet.

975
00:51:18,580 --> 00:51:25,830
>> So if this is the case, if it's a
less than 0-- not necessarily and.

976
00:51:25,830 --> 00:51:30,890
It's only either going to be
less than or greater than 9.

977
00:51:30,890 --> 00:51:33,055
So can you fill out this last for me?

978
00:51:33,055 --> 00:51:36,440
So or s of i is what, Rhea?

979
00:51:36,440 --> 00:51:39,810

980
00:51:39,810 --> 00:51:41,536
>> AUDIENCE: Greater than 9.

981
00:51:41,536 --> 00:51:42,970

982
00:51:42,970 --> 00:51:44,221
>> ALLISON BUCHHOLTZ-AU: There.

983
00:51:44,221 --> 00:51:47,280
Does that make sense to
everyone, how we got there?

984
00:51:47,280 --> 00:51:51,340
These problems, they're like once you
see the solutions, it's like oh, OK.

985
00:51:51,340 --> 00:51:52,312

986
00:51:52,312 --> 00:51:53,937
And this is why practice will help you.

987
00:51:53,937 --> 00:51:55,070

988
00:51:55,070 --> 00:51:57,400
OK, so we return 0.

989
00:51:57,400 --> 00:51:57,900
Lovely.

990
00:51:57,900 --> 00:51:59,000

991
00:51:59,000 --> 00:51:59,670
All right.

992
00:51:59,670 --> 00:52:00,780

993
00:52:00,780 --> 00:52:02,365
Otherwise what do we want to do?

994
00:52:02,365 --> 00:52:04,640
This is the interesting part
where it's a little more

995
00:52:04,640 --> 00:52:07,550
like math versus CS in my opinion.

996
00:52:07,550 --> 00:52:09,479

997
00:52:09,479 --> 00:52:11,520
Does anyone have an idea
of how we might do this?

998
00:52:11,520 --> 00:52:15,822

999
00:52:15,822 --> 00:52:18,155
So the important thing to
realize is the first character

1000
00:52:18,155 --> 00:52:21,510
we're taking is going to be
the highest order digit, right?

1001
00:52:21,510 --> 00:52:25,975
So if we're looking at converting
123, the first time we iterate

1002
00:52:25,975 --> 00:52:30,800
is going to be 1, but we need
that to be 100 by the end, right?

1003
00:52:30,800 --> 00:52:34,450
So one thing you can do is that
with every subsequent digit

1004
00:52:34,450 --> 00:52:39,670
you take, you multiply your value by 10,
so that by the time you reach the end,

1005
00:52:39,670 --> 00:52:42,960
everything has been
shifted upwards, right?

1006
00:52:42,960 --> 00:52:46,490
>> So the first time you run
it, you have 1 as your value.

1007
00:52:46,490 --> 00:52:50,370
Second time you run it, you
multiply your value by 10.

1008
00:52:50,370 --> 00:52:55,180
It will update it so that it's now
10, and you add on your next value.

1009
00:52:55,180 --> 00:52:57,830
And then you multiply that by
10 and add on your next value.

1010
00:52:57,830 --> 00:53:01,880
And this is why they say this
is much more like testing

1011
00:53:01,880 --> 00:53:06,920
a math algorithm versus
CS, but I digress.

1012
00:53:06,920 --> 00:53:08,080
I don't write the quizzes.

1013
00:53:08,080 --> 00:53:13,520
>> So one thing we can do is we
say value times equals 10.

1014
00:53:13,520 --> 00:53:16,630
So this is going to shift
your digit once every time.

1015
00:53:16,630 --> 00:53:18,770

1016
00:53:18,770 --> 00:53:20,915
And then we just want to add.

1017
00:53:20,915 --> 00:53:22,070

1018
00:53:22,070 --> 00:53:24,290
We want to add in what
we just got, right?

1019
00:53:24,290 --> 00:53:25,350

1020
00:53:25,350 --> 00:53:31,649
So how do we actually convert our
ASCII character into the number

1021
00:53:31,649 --> 00:53:32,440
that it represents?

1022
00:53:32,440 --> 00:53:37,680

1023
00:53:37,680 --> 00:53:40,800
>> So we know that 0 is equal to 47, right?

1024
00:53:40,800 --> 00:53:44,260
So if 0 is 47, what
would we have to do to it

1025
00:53:44,260 --> 00:53:47,376
to actually make it be an int of 0?

1026
00:53:47,376 --> 00:53:48,384
>> AUDIENCE: It's 48.

1027
00:53:48,384 --> 00:53:49,050
ALLISON BUCHHOLTZ-AU: 48?

1028
00:53:49,050 --> 00:53:49,550
Sorry.

1029
00:53:49,550 --> 00:53:53,500

1030
00:53:53,500 --> 00:53:55,100
We would subtract 48, right?

1031
00:53:55,100 --> 00:53:58,580

1032
00:53:58,580 --> 00:53:59,550
Remember ASCII math?

1033
00:53:59,550 --> 00:54:01,565
We can treat them just
like normal numbers.

1034
00:54:01,565 --> 00:54:02,570

1035
00:54:02,570 --> 00:54:05,900
If you treat them like numbers,
they become numbers effectively.

1036
00:54:05,900 --> 00:54:10,410
So if we have s of i, which let's
say in this case is equal to 0.

1037
00:54:10,410 --> 00:54:14,420
So s of i in this case
would be the ASCII--

1038
00:54:14,420 --> 00:54:16,675
the ASCII int for it would be 47.

1039
00:54:16,675 --> 00:54:17,750

1040
00:54:17,750 --> 00:54:19,875
So we could subtract-- or 48.

1041
00:54:19,875 --> 00:54:20,930

1042
00:54:20,930 --> 00:54:22,440
You could do that, is one way.

1043
00:54:22,440 --> 00:54:25,125
Does anyone know a better
way we could do 48?

1044
00:54:25,125 --> 00:54:27,220

1045
00:54:27,220 --> 00:54:31,608
We just said 0 is-- go into
the ASCII you could do quote 0.

1046
00:54:31,608 --> 00:54:39,740

1047
00:54:39,740 --> 00:54:43,160
So does it kind of make
sense how this works?

1048
00:54:43,160 --> 00:54:50,080
>> AUDIENCE: At this point, is the value 0
because even if you multiply it by 10,

1049
00:54:50,080 --> 00:54:53,340
you're starting out with zero,
so should it be switched?

1050
00:54:53,340 --> 00:54:59,360
>> ALLISON BUCHHOLTZ-AU: So in this case, you
want to multiply it before you add,

1051
00:54:59,360 --> 00:55:06,650
because in this case, yes, it would
still be-- my pointer is missing.

1052
00:55:06,650 --> 00:55:09,980
The value in this case, the first
time we run it will be zero.

1053
00:55:09,980 --> 00:55:12,320
So you're just adding
on that first digit.

1054
00:55:12,320 --> 00:55:15,930
What's important is the next time
you iterate, you want to shift it up

1055
00:55:15,930 --> 00:55:18,722
before you add your next digit on.

1056
00:55:18,722 --> 00:55:21,223
Does that clarify for you?

1057
00:55:21,223 --> 00:55:21,723
OK.

1058
00:55:21,723 --> 00:55:23,050

1059
00:55:23,050 --> 00:55:25,900
>> Sometimes you're going to
get weird more mathy things.

1060
00:55:25,900 --> 00:55:28,020

1061
00:55:28,020 --> 00:55:30,750
If you had most of
this, you're still going

1062
00:55:30,750 --> 00:55:32,610
to get-- you're going to do pretty well.

1063
00:55:32,610 --> 00:55:35,150
Partial credit is a very
big thing on CS50 quizzes.

1064
00:55:35,150 --> 00:55:36,270
So write what you know.

1065
00:55:36,270 --> 00:55:39,640
If you got everything
except for here, you're

1066
00:55:39,640 --> 00:55:41,390
still going to do
really well the problem.

1067
00:55:41,390 --> 00:55:43,750
Because you're showing,
OK, I almost know.

1068
00:55:43,750 --> 00:55:45,570
I know that I need to iterate through.

1069
00:55:45,570 --> 00:55:47,260
I know what I need to check for.

1070
00:55:47,260 --> 00:55:50,584
I just don't quite
get how to convert it.

1071
00:55:50,584 --> 00:55:51,500
You're going to be OK.

1072
00:55:51,500 --> 00:55:52,850
Yes, you're going to
lose a couple points,

1073
00:55:52,850 --> 00:55:55,641
but you're still going to get a
good number of points for something

1074
00:55:55,641 --> 00:55:57,990
like that if you're
missing these two lines.

1075
00:55:57,990 --> 00:56:00,660
I would be like OK, this person
knows what they're doing.

1076
00:56:00,660 --> 00:56:02,070
Math is hard.

1077
00:56:02,070 --> 00:56:04,930
So I would say you'd be fine.

1078
00:56:04,930 --> 00:56:09,474
>> OK, so you guys ready to
try strlen with pointers now

1079
00:56:09,474 --> 00:56:10,890
that you guys are pointer masters?

1080
00:56:10,890 --> 00:56:12,400

1081
00:56:12,400 --> 00:56:15,106
So I'll let you guys work
on that for a little bit.

1082
00:56:15,106 --> 00:56:17,131

1083
00:56:17,131 --> 00:56:19,090
If anyone needs a refresher.

1084
00:56:19,090 --> 00:56:23,120

1085
00:56:23,120 --> 00:56:28,060
So you want to use pointer
arithmetic, and then if s is null,

1086
00:56:28,060 --> 00:56:29,624
your implementation should return 0.

1087
00:56:29,624 --> 00:56:37,045

1088
00:56:37,045 --> 00:56:39,670
Things like this that make you
really happy to just call strlen

1089
00:56:39,670 --> 00:56:40,586
at the end of the day.

1090
00:56:40,586 --> 00:57:24,874

1091
00:57:24,874 --> 00:57:27,624
I think this one might be a little
easier than the last one, which

1092
00:57:27,624 --> 00:57:28,123
is good.

1093
00:57:28,123 --> 00:58:51,789

1094
00:58:51,789 --> 00:58:55,690
I'll give you guys another minute,
and then we'll work through it.

1095
00:58:55,690 --> 00:58:56,896

1096
00:58:56,896 --> 00:58:58,320
And then we get to go to switches.

1097
00:58:58,320 --> 00:59:32,480

1098
00:59:32,480 --> 00:59:34,660
>> OK, ready guys?

1099
00:59:34,660 --> 00:59:35,790

1100
00:59:35,790 --> 00:59:37,420
Maybe a little bit.

1101
00:59:37,420 --> 00:59:40,210
So I've given you your
two options, right?

1102
00:59:40,210 --> 00:59:45,810
Either check for null and return 0 if
it is, or actually compute the length.

1103
00:59:45,810 --> 00:59:48,220
So who wants to write check for null?

1104
00:59:48,220 --> 00:59:50,100

1105
00:59:50,100 --> 00:59:51,790
Go for it.

1106
00:59:51,790 --> 00:59:56,460
>> AUDIENCE: If parentheses s
equals equals null return 0.

1107
00:59:56,460 --> 00:59:57,342

1108
00:59:57,342 --> 00:59:58,175
ALLISON BUCHHOLTZ-AU: Lovely.

1109
00:59:58,175 --> 00:59:59,350

1110
00:59:59,350 --> 01:00:02,320
I love when half your problem
is just checking for null.

1111
01:00:02,320 --> 01:00:04,820
I know with you guys last
week I was like check for null

1112
01:00:04,820 --> 01:00:06,630
literally every time.

1113
01:00:06,630 --> 01:00:07,510
OK, so--

1114
01:00:07,510 --> 01:00:08,716

1115
01:00:08,716 --> 01:00:12,750
>> AUDIENCE: If return 0 is only one line,
do we still need the curly bracket?

1116
01:00:12,750 --> 01:00:15,860
>> ALLISON BUCHHOLTZ-AU: You don't technically
need them as long you're consistent.

1117
01:00:15,860 --> 01:00:19,240
It's good practice just
to get in the habit

1118
01:00:19,240 --> 01:00:21,650
of using curly braces,
but technically no.

1119
01:00:21,650 --> 01:00:23,320
You don't need them for one line.

1120
01:00:23,320 --> 01:00:26,030
We just tend to recommend it
for people starting to program.

1121
01:00:26,030 --> 01:00:27,740

1122
01:00:27,740 --> 01:00:30,450
>> So now what might we want to do here?

1123
01:00:30,450 --> 01:00:32,222
So now we know that our string is valid.

1124
01:00:32,222 --> 01:00:33,680
We want to keep compute the length.

1125
01:00:33,680 --> 01:00:35,620
What's probably the first
thing we want to do?

1126
01:00:35,620 --> 01:00:38,770

1127
01:00:38,770 --> 01:00:41,276
>> AUDIENCE: Create an
int that's the length.

1128
01:00:41,276 --> 01:00:42,150
ALLISON BUCHHOLTZ-AU: Exactly.

1129
01:00:42,150 --> 01:00:43,450
AUDIENCE: And we want to set it to?

1130
01:00:43,450 --> 01:00:44,210
ALLISON BUCHHOLTZ-AU: 0.

1131
01:00:44,210 --> 01:00:44,710
Perfect.

1132
01:00:44,710 --> 01:00:46,050

1133
01:00:46,050 --> 01:00:47,290
All right.

1134
01:00:47,290 --> 01:00:48,750
Now what do want to do?

1135
01:00:48,750 --> 01:00:50,000
This is really the bulk of it.

1136
01:00:50,000 --> 01:00:50,890
Go for it.

1137
01:00:50,890 --> 01:00:54,370
>> AUDIENCE: So you probably do a for loop.

1138
01:00:54,370 --> 01:01:03,150
And then since when you call s you're
getting the address of the first thing,

1139
01:01:03,150 --> 01:01:05,660
you would start with i equals 0.

1140
01:01:05,660 --> 01:01:07,980

1141
01:01:07,980 --> 01:01:15,755
And then as long as x
plus i isn't back slash 0.

1142
01:01:15,755 --> 01:01:17,130
ALLISON BUCHHOLTZ-AU: The null terminator.

1143
01:01:17,130 --> 01:01:18,380
AUDIENCE: The null terminator.

1144
01:01:18,380 --> 01:01:18,890

1145
01:01:18,890 --> 01:01:21,088
Then you add one to length.

1146
01:01:21,088 --> 01:01:22,372
>> ALLISON BUCHHOLTZ-AU: Yeah.

1147
01:01:22,372 --> 01:01:25,940
OK, so lets turn that
into very concrete code.

1148
01:01:25,940 --> 01:01:27,537
But that is the perfect idea.

1149
01:01:27,537 --> 01:01:28,870
That's exactly what we're doing.

1150
01:01:28,870 --> 01:01:31,910
We're going to be iterating
through with the pointer.

1151
01:01:31,910 --> 01:01:34,590
So what we want to do
is instead of an int

1152
01:01:34,590 --> 01:01:36,660
here, because we're
not referring to an it.

1153
01:01:36,660 --> 01:01:42,390
We're referring to the start of a
string, that start being some address,

1154
01:01:42,390 --> 01:01:43,300
right?

1155
01:01:43,300 --> 01:01:44,600
>> So we want a pointer.

1156
01:01:44,600 --> 01:01:47,610

1157
01:01:47,610 --> 01:01:52,310
So we're going to have some char star,
because it corresponds to our s, right?

1158
01:01:52,310 --> 01:01:57,270
So this is some point we're initializing
to the start of the string, OK?

1159
01:01:57,270 --> 01:01:58,949
So let's just call it i.

1160
01:01:58,949 --> 01:02:01,740
If it's the start of the string,
what's it going to be assigned to?

1161
01:02:01,740 --> 01:02:03,690

1162
01:02:03,690 --> 01:02:04,530
Not 0.

1163
01:02:04,530 --> 01:02:06,238
We want it to be the
start of our string.

1164
01:02:06,238 --> 01:02:07,170

1165
01:02:07,170 --> 01:02:09,960
What represents the start of
our string that was given to us?

1166
01:02:09,960 --> 01:02:10,800
>> AUDIENCE: Just s.

1167
01:02:10,800 --> 01:02:11,425
>> ALLISON BUCHHOLTZ-AU: s.

1168
01:02:11,425 --> 01:02:13,070

1169
01:02:13,070 --> 01:02:17,890
So this creates some new pointer that
represents the start of our string, OK?

1170
01:02:17,890 --> 01:02:19,430

1171
01:02:19,430 --> 01:02:22,777
Another way to think of it
is like here's our array.

1172
01:02:22,777 --> 01:02:26,690
That's our string, s.

1173
01:02:26,690 --> 01:02:28,650

1174
01:02:28,650 --> 01:02:32,400
So let's say this is the
first spot, and this is 0x4.

1175
01:02:32,400 --> 01:02:34,400

1176
01:02:34,400 --> 01:02:34,900
04.

1177
01:02:34,900 --> 01:02:36,330

1178
01:02:36,330 --> 01:02:38,535
This is our s, which holds that address.

1179
01:02:38,535 --> 01:02:39,810

1180
01:02:39,810 --> 01:02:45,960
And we just created another one called
i that just refers to the same thing.

1181
01:02:45,960 --> 01:02:49,437
So they're both just pointing
to the start of our string.

1182
01:02:49,437 --> 01:02:51,020
This is just a graphic representation.

1183
01:02:51,020 --> 01:02:53,830

1184
01:02:53,830 --> 01:02:57,100
>> So now what we want to
do is we want to iterate

1185
01:02:57,100 --> 01:03:02,040
our condition for iterating
through our string.

1186
01:03:02,040 --> 01:03:02,920
Now shopping.

1187
01:03:02,920 --> 01:03:04,150
Got to shop, guys.

1188
01:03:04,150 --> 01:03:06,290

1189
01:03:06,290 --> 01:03:12,390
Is we want to keep updating until
we reach the null terminator, right?

1190
01:03:12,390 --> 01:03:14,930
So what might that look like?

1191
01:03:14,930 --> 01:03:17,760

1192
01:03:17,760 --> 01:03:21,880
Do we want i, or do we want
star i is the question?

1193
01:03:21,880 --> 01:03:26,160

1194
01:03:26,160 --> 01:03:29,255
Is the null terminator an address
or something located at an address?

1195
01:03:29,255 --> 01:03:31,420

1196
01:03:31,420 --> 01:03:33,660
Located at an address, right?

1197
01:03:33,660 --> 01:03:38,420
>> So we need dereference whatever is
here, because this is just some address.

1198
01:03:38,420 --> 01:03:44,350
To actually get to the start
we need to dereference this

1199
01:03:44,350 --> 01:03:46,770
so that we actually get
what's in this first place.

1200
01:03:46,770 --> 01:03:48,690

1201
01:03:48,690 --> 01:03:52,910
So if we do star i, what
don't we want it to equal?

1202
01:03:52,910 --> 01:03:53,885

1203
01:03:53,885 --> 01:03:54,760
AUDIENCE: Back slash?

1204
01:03:54,760 --> 01:03:57,760

1205
01:03:57,760 --> 01:03:59,260
>> ALLISON BUCHHOLTZ-AU: There.

1206
01:03:59,260 --> 01:04:01,430
Does that make sense to everyone?

1207
01:04:01,430 --> 01:04:05,620
We need to go into our string and
make sure that it's not the end.

1208
01:04:05,620 --> 01:04:07,200

1209
01:04:07,200 --> 01:04:08,990
And then we can just update like this.

1210
01:04:08,990 --> 01:04:09,680
Normal updating.

1211
01:04:09,680 --> 01:04:11,910

1212
01:04:11,910 --> 01:04:15,070
So as long as these are
met, what do we need to do?

1213
01:04:15,070 --> 01:04:17,700

1214
01:04:17,700 --> 01:04:18,852
>> AUDIENCE: Length plus plus.

1215
01:04:18,852 --> 01:04:20,656

1216
01:04:20,656 --> 01:04:21,560
>> ALLISON BUCHHOLTZ-AU: Mm-hm.

1217
01:04:21,560 --> 01:04:25,540
And then after the for loop
terminates, what do we want to return?

1218
01:04:25,540 --> 01:04:27,082

1219
01:04:27,082 --> 01:04:27,790
AUDIENCE: Length?

1220
01:04:27,790 --> 01:04:28,623
ALLISON BUCHHOLTZ-AU: Length.

1221
01:04:28,623 --> 01:04:29,910

1222
01:04:29,910 --> 01:04:30,760
There you go.

1223
01:04:30,760 --> 01:04:33,790

1224
01:04:33,790 --> 01:04:37,810
Obviously the meat of this one
is understanding this for loop.

1225
01:04:37,810 --> 01:04:39,280

1226
01:04:39,280 --> 01:04:41,090
Does everyone get how that worked?

1227
01:04:41,090 --> 01:04:42,460

1228
01:04:42,460 --> 01:04:44,170
I'm happy to go over it again.

1229
01:04:44,170 --> 01:04:48,400
>> AUDIENCE: The second
part, so the star i there,

1230
01:04:48,400 --> 01:04:51,834
that's the address of the first--

1231
01:04:51,834 --> 01:04:53,250
ALLISON BUCHHOLTZ-AU: It's not the address.

1232
01:04:53,250 --> 01:04:54,142
It's what's at.

1233
01:04:54,142 --> 01:04:55,600
AUDIENCE: That's actually in there.

1234
01:04:55,600 --> 01:04:57,475
ALLISON BUCHHOLTZ-AU: That's
what's actually in there.

1235
01:04:57,475 --> 01:05:01,280
So this is saying-- let
me make this better.

1236
01:05:01,280 --> 01:05:07,940
So this is 0x04, and I'm just going
to say I'm going to make this my name.

1237
01:05:07,940 --> 01:05:14,531

1238
01:05:14,531 --> 01:05:15,030
OK.

1239
01:05:15,030 --> 01:05:17,456

1240
01:05:17,456 --> 01:05:19,080
Yes, I know I have quiz review tonight.

1241
01:05:19,080 --> 01:05:20,620

1242
01:05:20,620 --> 01:05:21,540
Lots of quiz review.

1243
01:05:21,540 --> 01:05:23,500

1244
01:05:23,500 --> 01:05:26,620
So let's say this string
is my name, Allison.

1245
01:05:26,620 --> 01:05:28,600
Little messy, but it's there.

1246
01:05:28,600 --> 01:05:33,640
And s represents the location
of where the string starts,

1247
01:05:33,640 --> 01:05:41,950
so I'm going to make this
real-- this is the address of a,

1248
01:05:41,950 --> 01:05:45,000
where the string starts, right?

1249
01:05:45,000 --> 01:05:48,560
>> So what we do here is we want to
use pointers to iterate through.

1250
01:05:48,560 --> 01:05:49,920

1251
01:05:49,920 --> 01:05:56,870
So we create some pointer, i, that also
is equal to the start of the string.

1252
01:05:56,870 --> 01:05:57,880

1253
01:05:57,880 --> 01:06:03,820
And at each point, we want to
continue going through the array

1254
01:06:03,820 --> 01:06:07,570
here until we hit the null terminator.

1255
01:06:07,570 --> 01:06:12,320
So we always want to check what's
at each of these addresses.

1256
01:06:12,320 --> 01:06:15,730
>> So we dereference i, so that
the first time we do it we

1257
01:06:15,730 --> 01:06:17,810
say, OK, what's at address 0x04?

1258
01:06:17,810 --> 01:06:19,060

1259
01:06:19,060 --> 01:06:19,720
It's an a.

1260
01:06:19,720 --> 01:06:20,660
OK, we're good.

1261
01:06:20,660 --> 01:06:21,770
Increment length.

1262
01:06:21,770 --> 01:06:22,790
Move on to the next one.

1263
01:06:22,790 --> 01:06:32,410
So i-- remember pointers increase by the
size of whatever they're pointing to.

1264
01:06:32,410 --> 01:06:35,320
So in this case, since it's
a char, it'll update by one.

1265
01:06:35,320 --> 01:06:38,755
So now we're going to look at 5,
which means it's going over here.

1266
01:06:38,755 --> 01:06:39,860

1267
01:06:39,860 --> 01:06:43,440
So it says OK, go to 0x05.

1268
01:06:43,440 --> 01:06:44,270
What's in there?

1269
01:06:44,270 --> 01:06:44,930
It's an l.

1270
01:06:44,930 --> 01:06:47,870
And it'll keep doing that
until it hits this one.

1271
01:06:47,870 --> 01:06:50,990
And it says OK, what's in
whatever address this is?

1272
01:06:50,990 --> 01:06:53,060
The null terminator, OK.

1273
01:06:53,060 --> 01:06:53,870
Exit.

1274
01:06:53,870 --> 01:06:55,240
And just return length.

1275
01:06:55,240 --> 01:06:56,370

1276
01:06:56,370 --> 01:06:59,800
Because you need what's actually at
that address, not the address itself.

1277
01:06:59,800 --> 01:07:03,110

1278
01:07:03,110 --> 01:07:05,790
>> There are very few places where
you actually need the address.

1279
01:07:05,790 --> 01:07:08,720
Most of the time when
you're using the and it's

1280
01:07:08,720 --> 01:07:12,424
when you are first
assigning a pointer or when

1281
01:07:12,424 --> 01:07:14,090
you're passing it into another function.

1282
01:07:14,090 --> 01:07:16,350

1283
01:07:16,350 --> 01:07:21,330
OK, everyone good there?

1284
01:07:21,330 --> 01:07:21,830
Kind of?

1285
01:07:21,830 --> 01:07:23,810

1286
01:07:23,810 --> 01:07:25,040
OK.

1287
01:07:25,040 --> 01:07:28,210
>> So it looks like we've
got about 12 minutes left,

1288
01:07:28,210 --> 01:07:31,340
so we'll go on to
maybe our last problem,

1289
01:07:31,340 --> 01:07:34,230
and then there's any
concepts that have come up

1290
01:07:34,230 --> 01:07:36,830
in the meantime we can
quickly go over that.

1291
01:07:36,830 --> 01:07:42,310
>> So switching gears is the last
problem here, switch statements.

1292
01:07:42,310 --> 01:07:44,970

1293
01:07:44,970 --> 01:07:49,450
So your job is to rewrite this
so that it behaves the same

1294
01:07:49,450 --> 01:07:50,580
but doesn't use switches.

1295
01:07:50,580 --> 01:07:53,684

1296
01:07:53,684 --> 01:07:54,666
Chalky hands.

1297
01:07:54,666 --> 01:08:11,630

1298
01:08:11,630 --> 01:08:13,420
So any questions about this off the bat?

1299
01:08:13,420 --> 01:08:15,420

1300
01:08:15,420 --> 01:08:15,920
None?

1301
01:08:15,920 --> 01:08:16,420
OK.

1302
01:08:16,420 --> 01:08:17,920

1303
01:08:17,920 --> 01:08:22,170
Does everyone understand that if the
case doesn't have anything after it,

1304
01:08:22,170 --> 01:08:25,029
it means that it should
follow the next step?

1305
01:08:25,029 --> 01:08:28,200
So case 1 and 2 in this case
do the exact same thing.

1306
01:08:28,200 --> 01:08:31,153

1307
01:08:31,153 --> 01:08:32,444
Sometimes a point of confusion.

1308
01:08:32,444 --> 01:09:32,700

1309
01:09:32,700 --> 01:09:33,488
>> All right.

1310
01:09:33,488 --> 01:09:34,404
Anyone have any ideas?

1311
01:09:34,404 --> 01:09:36,364

1312
01:09:36,364 --> 01:09:36,864
Yeah?

1313
01:09:36,864 --> 01:09:40,120
>> AUDIENCE: So you can
just do if statements.

1314
01:09:40,120 --> 01:09:41,140
>> ALLISON BUCHHOLTZ-AU: Mm-hm.

1315
01:09:41,140 --> 01:09:42,880
So what's our first one?

1316
01:09:42,880 --> 01:09:48,120
>> AUDIENCE: If n equals equals 1,
and the 2 lines for or n equals

1317
01:09:48,120 --> 01:09:51,059
equals 2, then print small.

1318
01:09:51,059 --> 01:09:57,760

1319
01:09:57,760 --> 01:09:59,520
And then can you do else if?

1320
01:09:59,520 --> 01:10:02,160
Or can you just do an if?

1321
01:10:02,160 --> 01:10:03,650
>> ALLISON BUCHHOLTZ-AU: You can do else if?

1322
01:10:03,650 --> 01:10:05,274
>> AUDIENCE: Would it matter if you do if?

1323
01:10:05,274 --> 01:10:06,320
ALLISON BUCHHOLTZ-AU: So it does.

1324
01:10:06,320 --> 01:10:10,160
Does anyone-- so, you
will get the same output

1325
01:10:10,160 --> 01:10:13,930
if you use just ifs versus
if you use else ifs.

1326
01:10:13,930 --> 01:10:17,090
Can you guys think of the reason
why you might want to use an else

1327
01:10:17,090 --> 01:10:18,680
if versus a lot of ifs?

1328
01:10:18,680 --> 01:10:20,260

1329
01:10:20,260 --> 01:10:21,510
Has to with efficiency.

1330
01:10:21,510 --> 01:10:22,225
Yeah?

1331
01:10:22,225 --> 01:10:24,783
>> AUDIENCE: It would check
all the ifs every time.

1332
01:10:24,783 --> 01:10:26,076

1333
01:10:26,076 --> 01:10:28,110
>> ALLISON BUCHHOLTZ-AU: So even if
it hit this first one,

1334
01:10:28,110 --> 01:10:29,880
it would go on check every other one.

1335
01:10:29,880 --> 01:10:36,690
So you want to use if else ifs in cases
where only one of them will ever apply.

1336
01:10:36,690 --> 01:10:39,380
So mutual exclusion is
what we tend to say.

1337
01:10:39,380 --> 01:10:41,410

1338
01:10:41,410 --> 01:10:46,550
If you have a bunch of ifs, it means
that maybe more than one of them

1339
01:10:46,550 --> 01:10:49,630
matters, and maybe more than
one of them can be true.

1340
01:10:49,630 --> 01:10:51,910
And you want both of them
to execute if they're true.

1341
01:10:51,910 --> 01:10:57,180
If you only want one of them to work
in these mutually exclusive cases,

1342
01:10:57,180 --> 01:11:00,790
you want to use else if, because
it all has to do with efficiency.

1343
01:11:00,790 --> 01:11:05,350
Your code is just better designed
if it adheres to this practice.

1344
01:11:05,350 --> 01:11:07,330
So in this case we'll have an else if.

1345
01:11:07,330 --> 01:11:09,080
And this would be?

1346
01:11:09,080 --> 01:11:11,890
>> AUDIENCE: n equals equals 3.

1347
01:11:11,890 --> 01:11:12,765
ALLISON BUCHHOLTZ-AU: Perfect.

1348
01:11:12,765 --> 01:11:19,420

1349
01:11:19,420 --> 01:11:20,445
Print medium.

1350
01:11:20,445 --> 01:11:25,190

1351
01:11:25,190 --> 01:11:29,930
And then in our last
case, what do we have?

1352
01:11:29,930 --> 01:11:31,495
Else or else if?

1353
01:11:31,495 --> 01:11:32,120
AUDIENCE: Else.

1354
01:11:32,120 --> 01:11:33,450

1355
01:11:33,450 --> 01:11:37,900
>> ALLISON BUCHHOLTZ-AU: Do we want-- You want
else if because we have concrete cases.

1356
01:11:37,900 --> 01:11:39,270
It's not kind of a catch all.

1357
01:11:39,270 --> 01:11:44,247
If you had a default in a switch--
remember in switches you can have case,

1358
01:11:44,247 --> 01:11:45,330
and then you have default.

1359
01:11:45,330 --> 01:11:48,760
If you had a default, that's kind
of your else statement there.

1360
01:11:48,760 --> 01:11:52,180
But if it has only cases,
that means you need

1361
01:11:52,180 --> 01:11:54,315
to check to see if it's each of those.

1362
01:11:54,315 --> 01:11:57,755
So in this case, it would the 4 or 5.

1363
01:11:57,755 --> 01:12:00,480

1364
01:12:00,480 --> 01:12:01,450
We want a print off.

1365
01:12:01,450 --> 01:12:02,990

1366
01:12:02,990 --> 01:12:03,630
It's large.

1367
01:12:03,630 --> 01:12:06,640

1368
01:12:06,640 --> 01:12:07,509
And there you go.

1369
01:12:07,509 --> 01:12:08,800
And that would be your program.

1370
01:12:08,800 --> 01:12:11,890

1371
01:12:11,890 --> 01:12:17,050
>> So in this case if we
had a default something,

1372
01:12:17,050 --> 01:12:20,470
we would have an else in
whatever it wanted us to do.

1373
01:12:20,470 --> 01:12:23,365
So that is a good distinction
to know, to understand.

1374
01:12:23,365 --> 01:12:25,368

1375
01:12:25,368 --> 01:12:27,790
Does that help with switches for you?

1376
01:12:27,790 --> 01:12:28,800
Perfect.

1377
01:12:28,800 --> 01:12:29,390
All right.

1378
01:12:29,390 --> 01:12:31,320

1379
01:12:31,320 --> 01:12:33,340
>> We have about eight minutes left.

1380
01:12:33,340 --> 01:12:37,090
Do you guys have any
other high level concepts?

1381
01:12:37,090 --> 01:12:38,720
Questions in general?

1382
01:12:38,720 --> 01:12:39,220
Yes?

1383
01:12:39,220 --> 01:12:42,860
>> AUDIENCE: I had a
question about one of them

1384
01:12:42,860 --> 01:12:46,257
that was about the random
number generator on quiz zero.

1385
01:12:46,257 --> 01:12:47,340
ALLISON BUCHHOLTZ-AU: Oh, that one.

1386
01:12:47,340 --> 01:12:51,460
That one is another one where
it is more math than-- yes.

1387
01:12:51,460 --> 01:12:53,800

1388
01:12:53,800 --> 01:12:59,452
The solution to that-- even I when
I see it, I'm like what is this.

1389
01:12:59,452 --> 01:13:00,590
>> AUDIENCE: It was number 7.

1390
01:13:00,590 --> 01:13:02,720

1391
01:13:02,720 --> 01:13:05,310
>> ALLISON BUCHHOLTZ-AU: It's strange in my opinion.

1392
01:13:05,310 --> 01:13:07,260

1393
01:13:07,260 --> 01:13:11,630
So basically you want
to use drand48, which

1394
01:13:11,630 --> 01:13:15,420
will give you some
number between 0 and 1.

1395
01:13:15,420 --> 01:13:21,200
And you want to use it so
that you somehow get a--

1396
01:13:21,200 --> 01:13:26,690
and it's much more of a math problem
to me than I think a CS problem.

1397
01:13:26,690 --> 01:13:29,040

1398
01:13:29,040 --> 01:13:37,845
>> The way that you do it-- and
sometimes it will just be like that.

1399
01:13:37,845 --> 01:13:39,340

1400
01:13:39,340 --> 01:13:41,090
Again, these are the
cases where it's kind

1401
01:13:41,090 --> 01:13:46,310
of like write what you
can and partial credit.

1402
01:13:46,310 --> 01:13:47,800

1403
01:13:47,800 --> 01:13:51,510
So if we want a return,
we know that we're

1404
01:13:51,510 --> 01:13:54,182
going to be using drand48
in some way, right?

1405
01:13:54,182 --> 01:13:55,640
So why don't we just jot that down.

1406
01:13:55,640 --> 01:13:58,286

1407
01:13:58,286 --> 01:13:59,410
We're using it in some way.

1408
01:13:59,410 --> 01:14:00,780

1409
01:14:00,780 --> 01:14:04,190
The way that they have
you guys use it is

1410
01:14:04,190 --> 01:14:08,175
like this, which I will try and explain.

1411
01:14:08,175 --> 01:14:10,200

1412
01:14:10,200 --> 01:14:15,340
>> So basically what happens here
is because it's between 0 and 1,

1413
01:14:15,340 --> 01:14:19,300
what you're doing is you're multiplying
by-- this is very much a math question.

1414
01:14:19,300 --> 01:14:22,010
Just full disclaimer, this is
completely a math question.

1415
01:14:22,010 --> 01:14:23,990
What you're doing is
because of 0 and 1 and you

1416
01:14:23,990 --> 01:14:26,460
want it to be within
this range, you actually

1417
01:14:26,460 --> 01:14:29,360
figure out how large
the range is, and then

1418
01:14:29,360 --> 01:14:32,710
you basically scale it up,
which is what this is doing.

1419
01:14:32,710 --> 01:14:39,050
>> b minus a gives you that range, the
difference between those numbers.

1420
01:14:39,050 --> 01:14:44,040
You can multiply between 0
and 1, and then adding a just

1421
01:14:44,040 --> 01:14:48,870
means that your scaling it up
so that it's between a and b,

1422
01:14:48,870 --> 01:14:52,377
which I didn't really like this problem.

1423
01:14:52,377 --> 01:14:58,380

1424
01:14:58,380 --> 01:15:01,790
As I said, this quiz
is meant to encompass

1425
01:15:01,790 --> 01:15:04,110
people who are less comfortable,
somewhere in between,

1426
01:15:04,110 --> 01:15:05,070
and more comfortable.

1427
01:15:05,070 --> 01:15:07,550
So if they made it so
that it was something

1428
01:15:07,550 --> 01:15:10,050
that everyone at the less
comfortable place would get,

1429
01:15:10,050 --> 01:15:12,259
we would have far too many
people scoring perfects,

1430
01:15:12,259 --> 01:15:13,925
and the more comfortable would be bored.

1431
01:15:13,925 --> 01:15:14,980

1432
01:15:14,980 --> 01:15:18,970
>> So they always have these
kind of brain teaser questions

1433
01:15:18,970 --> 01:15:22,695
that are meant to be a little harder
that take some creative thinking.

1434
01:15:22,695 --> 01:15:25,030

1435
01:15:25,030 --> 01:15:27,790
When you see them,
don't get too stumped.

1436
01:15:27,790 --> 01:15:31,720
I would definitely say flip
through your quiz first.

1437
01:15:31,720 --> 01:15:35,020
Tackle the problems
that you know you can,

1438
01:15:35,020 --> 01:15:38,480
because there's no use getting stuck
on a problem when there are three

1439
01:15:38,480 --> 01:15:42,090
or four or five on the page
after that you can easily do.

1440
01:15:42,090 --> 01:15:45,331

1441
01:15:45,331 --> 01:15:48,520
>> AUDIENCE: Why exactly do you
multiply it by the range?

1442
01:15:48,520 --> 01:15:54,935
>> ALLISON BUCHHOLTZ-AU: You multiply the range that
you know-- it's like how much after a

1443
01:15:54,935 --> 01:15:55,485
do you want?

1444
01:15:55,485 --> 01:15:57,840

1445
01:15:57,840 --> 01:16:02,130
So you can think of, because it
returns a number between 0 and 1,

1446
01:16:02,130 --> 01:16:03,890
you can think of it as a percentage.

1447
01:16:03,890 --> 01:16:12,195
So it's basically saying if we have
our number line here, a is here,

1448
01:16:12,195 --> 01:16:13,840
and b is here.

1449
01:16:13,840 --> 01:16:19,170
You're like how much past a is it?

1450
01:16:19,170 --> 01:16:20,010
Is all we're doing.

1451
01:16:20,010 --> 01:16:24,920
So you're just asking for the
percentage of this range, which

1452
01:16:24,920 --> 01:16:26,170
is what it's giving you.

1453
01:16:26,170 --> 01:16:30,915
And then you basically just
scale it up by adding a.

1454
01:16:30,915 --> 01:16:32,302
It's a math brain teaser.

1455
01:16:32,302 --> 01:16:35,400

1456
01:16:35,400 --> 01:16:39,060
>> If there was any last minute advice, I
would say flip through the questions,

1457
01:16:39,060 --> 01:16:41,660
figure out which ones you
know that like, oh I got this.

1458
01:16:41,660 --> 01:16:43,196

1459
01:16:43,196 --> 01:16:45,820
Almost surely they're going to
be questions that you won't know

1460
01:16:45,820 --> 01:16:49,580
or that you're going to have time
for, so hit your strengths, OK?

1461
01:16:49,580 --> 01:16:50,990
You guys are going to great.

1462
01:16:50,990 --> 01:16:52,740
There are a lot of
questions for a reason,

1463
01:16:52,740 --> 01:16:57,140
so that you have time to
kind of have the opportunity

1464
01:16:57,140 --> 01:16:59,330
to demonstrate what
you're really good at.

1465
01:16:59,330 --> 01:17:02,370
So it's OK if you're
not good at everything.

1466
01:17:02,370 --> 01:17:03,371
Play to your strengths.

1467
01:17:03,371 --> 01:17:03,870
Yes?

1468
01:17:03,870 --> 01:17:06,536
>> AUDIENCE: So is this going to
return something that's truncated?

1469
01:17:06,536 --> 01:17:10,810

1470
01:17:10,810 --> 01:17:15,015
Yes, it will, because drand
returns between 0 and 1.

1471
01:17:15,015 --> 01:17:17,459

1472
01:17:17,459 --> 01:17:19,250
It'll return an int,
because it'll truncate

1473
01:17:19,250 --> 01:17:22,933
when we add a or multiply by it.

1474
01:17:22,933 --> 01:17:27,670

1475
01:17:27,670 --> 01:17:28,442
Cool.

1476
01:17:28,442 --> 01:17:29,525
Any last minute questions?

1477
01:17:29,525 --> 01:17:31,310

1478
01:17:31,310 --> 01:17:32,615
>> You guys are going to do great.

1479
01:17:32,615 --> 01:17:34,440
You're Going to be fabulous.

1480
01:17:34,440 --> 01:17:37,100
And even if not, there will
be candy here next week.

1481
01:17:37,100 --> 01:17:39,040

1482
01:17:39,040 --> 01:17:40,020
And I'll love you.

1483
01:17:40,020 --> 01:17:41,270
I'll love you guys regardless.

1484
01:17:41,270 --> 01:17:42,550

1485
01:17:42,550 --> 01:17:43,930
All right, everyone, good luck.

1486
01:17:43,930 --> 01:17:44,680
Have a great time.

1487
01:17:44,680 --> 01:17:45,620

1488
01:17:45,620 --> 01:17:46,620
You're going to be fine.

1489
01:17:46,620 --> 01:17:47,370
And you know what?

1490
01:17:47,370 --> 01:17:50,310
In two days it's going
to be over, whereas I

1491
01:17:50,310 --> 01:17:53,675
have two midterms on Thursday, so
at least you guys will be done.

1492
01:17:53,675 --> 01:17:56,550
All right, I'll see you guys next week.

1493
01:17:56,550 --> 01:17:58,208
