1
00:00:00,000 --> 00:00:11,270

2
00:00:11,270 --> 00:00:14,340
>> DANIEL ARMENDARIZ: Hello, everyone,
welcome to iOS app development

3
00:00:14,340 --> 00:00:15,020
with swift.

4
00:00:15,020 --> 00:00:15,870
I'm Dan Armendariz.

5
00:00:15,870 --> 00:00:18,920
I'm precepter of computer
science here at the School

6
00:00:18,920 --> 00:00:21,200
of Engineering and Applied Sciences.

7
00:00:21,200 --> 00:00:24,310
And swift is actually kind
of a really neat language.

8
00:00:24,310 --> 00:00:27,190
And I have some plans for today.

9
00:00:27,190 --> 00:00:31,430
So over the next hour or so we're going
to look at iOS app development itself

10
00:00:31,430 --> 00:00:36,640
using Xcode and actually creating some
very basic, very simple applications.

11
00:00:36,640 --> 00:00:40,070
And looking at the way that you
actually take those applications,

12
00:00:40,070 --> 00:00:42,887
and build them, and actually
put them on an iOS device.

13
00:00:42,887 --> 00:00:44,970
Some of the things that
we're not going to look at

14
00:00:44,970 --> 00:00:47,540
will include things like
actually taking an application

15
00:00:47,540 --> 00:00:48,940
and putting it on the app store.

16
00:00:48,940 --> 00:00:52,930
There's a lot of tutorials online that
will help you with that aspect of it.

17
00:00:52,930 --> 00:00:56,230
But also because as
part of CS50, you get

18
00:00:56,230 --> 00:00:59,780
to join the Apple development
team, CS50's app development team.

19
00:00:59,780 --> 00:01:02,790
If you haven't done that yet and
you are affiliated with CS50,

20
00:01:02,790 --> 00:01:04,810
I do recommend that you
do that because that

21
00:01:04,810 --> 00:01:08,820
is how you're able to create
some programs in Xcode,

22
00:01:08,820 --> 00:01:11,890
build them, and actually put
them on some of your iOS devices

23
00:01:11,890 --> 00:01:14,087
if you actually have
a physical iOS device.

24
00:01:14,087 --> 00:01:16,670
If you don't have a physical iOS
device that's more than fine.

25
00:01:16,670 --> 00:01:19,810
You can actually develop for iOS.

26
00:01:19,810 --> 00:01:22,390
And Xcode has a
simulator that allows you

27
00:01:22,390 --> 00:01:26,570
to see your application in
action on your computer.

28
00:01:26,570 --> 00:01:30,440
But it sort of is a neat thing
to actually play and interact

29
00:01:30,440 --> 00:01:34,235
with your application
on an actual device.

30
00:01:34,235 --> 00:01:37,360
So there's a couple of requirements to
actually do all of this development.

31
00:01:37,360 --> 00:01:39,151
One of them is that
you have to have a Mac.

32
00:01:39,151 --> 00:01:44,770
It has to be running 10.9.4 or later
in order to do development with swift.

33
00:01:44,770 --> 00:01:47,770
>> You can use an earlier
version to develop

34
00:01:47,770 --> 00:01:50,810
with Objective C for iOS and Mac.

35
00:01:50,810 --> 00:01:53,990
But I recommend, and a lot of the
examples that we'll see today,

36
00:01:53,990 --> 00:01:55,700
use 10.10 Yosemite.

37
00:01:55,700 --> 00:02:00,910
So if you haven't yet upgraded,
it's a good excuse to do so.

38
00:02:00,910 --> 00:02:05,480
Now Xcode 6.1 is the latest version of
the integrated development environment

39
00:02:05,480 --> 00:02:08,979
that Apple provides for free that
you can download off the app store.

40
00:02:08,979 --> 00:02:11,220
And I recommend that you
also run the latest version.

41
00:02:11,220 --> 00:02:14,700
>> If you happen to be running an earlier
version, Xcode 5 and below just

42
00:02:14,700 --> 00:02:16,741
simply do not support swift whatsoever.

43
00:02:16,741 --> 00:02:19,490
And the beta versions of six, which
were released over the summer,

44
00:02:19,490 --> 00:02:21,770
do support swift, but there's
been an enormous number

45
00:02:21,770 --> 00:02:25,220
of changes in the language, enough
so that the code that you're

46
00:02:25,220 --> 00:02:28,320
going to look at and that you
might find on the internet

47
00:02:28,320 --> 00:02:33,294
will not actually compile properly
in these prior versions of Xcode.

48
00:02:33,294 --> 00:02:35,460
So again, if you don't yet
have a developer account,

49
00:02:35,460 --> 00:02:38,560
I recommend you go to
developer.apple.com.

50
00:02:38,560 --> 00:02:42,240
Sign up, create a developer account,
and join the CS50 app development team.

51
00:02:42,240 --> 00:02:45,530
That will provide to you an opportunity
to compile your applications

52
00:02:45,530 --> 00:02:47,840
and put them on your device.

53
00:02:47,840 --> 00:02:49,222
OK, so let's get started.

54
00:02:49,222 --> 00:02:50,930
The very first thing
we're going to do is

55
00:02:50,930 --> 00:02:55,140
to actually create a very
simple project in Xcode

56
00:02:55,140 --> 00:02:59,530
that will allow you to
make an application.

57
00:02:59,530 --> 00:03:03,170
>> So if you don't yet have Xcode
open, go ahead and open it

58
00:03:03,170 --> 00:03:04,270
and create a new project.

59
00:03:04,270 --> 00:03:06,570
A special splash screen
will open and will give you

60
00:03:06,570 --> 00:03:08,800
some options about what
it is that you want to do.

61
00:03:08,800 --> 00:03:12,170
Just say that you want to create
a new project, a new application.

62
00:03:12,170 --> 00:03:15,650
This window will pop up,
assuming you're using Xcode 6.1.

63
00:03:15,650 --> 00:03:17,650
Right now, and for the
duration of this seminar,

64
00:03:17,650 --> 00:03:19,990
we're going to be using
single view applications, just

65
00:03:19,990 --> 00:03:22,590
sort of a basic application
to get your feet wet.

66
00:03:22,590 --> 00:03:25,200
And you can branch out
on your own from there.

67
00:03:25,200 --> 00:03:27,660
>> Click Next at this point.

68
00:03:27,660 --> 00:03:30,796
Now here there's a couple of things
that you might want to enter.

69
00:03:30,796 --> 00:03:32,670
The product name is the
name of your project.

70
00:03:32,670 --> 00:03:34,859
In this case, I'm just
going to call it Seminar1

71
00:03:34,859 --> 00:03:36,150
because it's our first example.

72
00:03:36,150 --> 00:03:38,290
Organization name, in
this case is just my name.

73
00:03:38,290 --> 00:03:41,760
You can of course change it
to your own name, or to CS50.

74
00:03:41,760 --> 00:03:46,160
Organization identifier, if you
happen to have a website just take

75
00:03:46,160 --> 00:03:49,940
the domain name in
reverse, com.yourname.

76
00:03:49,940 --> 00:03:54,200
and then the name of the product
should appear automatically

77
00:03:54,200 --> 00:03:55,820
after that as the bundle identifier.

78
00:03:55,820 --> 00:03:59,200
>> Obviously the language that we're
going to be using for today is swift.

79
00:03:59,200 --> 00:04:02,590
You can, of course, use Objective C
for that, but today will be swift.

80
00:04:02,590 --> 00:04:04,920
And we'll for now say
universal devices, so

81
00:04:04,920 --> 00:04:06,900
that it works on both iPad and iPhone.

82
00:04:06,900 --> 00:04:10,040
And we will leave core
data unchecked to keep

83
00:04:10,040 --> 00:04:12,830
the project relatively
simple for the time being.

84
00:04:12,830 --> 00:04:14,430
So let's go ahead and click Next.

85
00:04:14,430 --> 00:04:16,471
And it's going to ask me
where I want to save it.

86
00:04:16,471 --> 00:04:19,250
I'll just save it to my desktop for now.

87
00:04:19,250 --> 00:04:22,267
>> All right, so now this is what will
happen when you actually open Xcode.

88
00:04:22,267 --> 00:04:24,100
And notice that the
very first thing you see

89
00:04:24,100 --> 00:04:28,770
is this exclamation point that
says no signing identity found.

90
00:04:28,770 --> 00:04:31,520
I intentionally did this
on my computer and I'm

91
00:04:31,520 --> 00:04:34,220
hoping that I'm going to
be able to actually fix it,

92
00:04:34,220 --> 00:04:37,860
because I want you to see how this
will actually work on your own machine.

93
00:04:37,860 --> 00:04:40,400
>> Go ahead and click fix issue.

94
00:04:40,400 --> 00:04:45,400
It will ask you if you have an
existing apple developer account.

95
00:04:45,400 --> 00:04:48,330
This is where joining the
CS50 app development team

96
00:04:48,330 --> 00:04:51,240
is important so that you not
only have an app account,

97
00:04:51,240 --> 00:04:53,690
but you also have the
capability to sign the apps

98
00:04:53,690 --> 00:04:56,420
and put them on your iOS device.

99
00:04:56,420 --> 00:04:58,957
This is not-- clicking
fix issue is not necessary

100
00:04:58,957 --> 00:05:01,040
if you're just going to
build and develop locally,

101
00:05:01,040 --> 00:05:03,520
entirely within the iOS simulator.

102
00:05:03,520 --> 00:05:05,820
>> But for now I'm going
to develop and put them

103
00:05:05,820 --> 00:05:08,160
on my iPad, which will be
able to broadcast as well.

104
00:05:08,160 --> 00:05:10,770
So I do want to actually add this.

105
00:05:10,770 --> 00:05:13,670
And it's going to ask
me for my apple ID.

106
00:05:13,670 --> 00:05:15,700
So it's going to be this.

107
00:05:15,700 --> 00:05:18,940
And I have to fetch my
password, which is over here.

108
00:05:18,940 --> 00:05:27,760
So give me just one second to find that,
and copy that, and paste it over here.

109
00:05:27,760 --> 00:05:28,580
>> Click Add.

110
00:05:28,580 --> 00:05:31,095
It's going to ask me
which team I want to join.

111
00:05:31,095 --> 00:05:33,240
I'm going to do school of engineering.

112
00:05:33,240 --> 00:05:35,680
Click Join.

113
00:05:35,680 --> 00:05:37,780
Whoops, that's the wrong one.

114
00:05:37,780 --> 00:05:40,730
Let's do this one.

115
00:05:40,730 --> 00:05:42,060
Hopefully that one will work.

116
00:05:42,060 --> 00:05:44,220
That one still doesn't work.

117
00:05:44,220 --> 00:05:46,610
We're running out of good ones here.

118
00:05:46,610 --> 00:05:48,260
OK, this one should work.

119
00:05:48,260 --> 00:05:50,816
Now close that.

120
00:05:50,816 --> 00:05:54,450
Now let's do school of
engineering, click choose.

121
00:05:54,450 --> 00:06:00,190
>> And now hopefully after a
couple of seconds you can-- OK,

122
00:06:00,190 --> 00:06:02,550
I'll revoke and request.

123
00:06:02,550 --> 00:06:05,410
Oh man, this is going to not work.

124
00:06:05,410 --> 00:06:08,890
OK, I'll try a different one.

125
00:06:08,890 --> 00:06:11,167
Let's do this one here.

126
00:06:11,167 --> 00:06:17,020

127
00:06:17,020 --> 00:06:19,310
Live demos are failing me.

128
00:06:19,310 --> 00:06:22,540
We may have to revert to just
building entirely locally,

129
00:06:22,540 --> 00:06:25,050
but that would be OK in this case.

130
00:06:25,050 --> 00:06:28,560
>> So here, while this is actually
working, what we're going to do is just

131
00:06:28,560 --> 00:06:31,190
create a very simple
Hello World application.

132
00:06:31,190 --> 00:06:32,340
So this is Xcode.

133
00:06:32,340 --> 00:06:37,300
And if you haven't seen it yet, it
can be a little intimidating at first.

134
00:06:37,300 --> 00:06:41,430
There's a lot of panes, there's a
lot of doodads in various areas.

135
00:06:41,430 --> 00:06:44,300
But just realize that there's
really several main components

136
00:06:44,300 --> 00:06:46,580
to this development environment.

137
00:06:46,580 --> 00:06:51,090
On the far left are all of the files
that are applicable to your program

138
00:06:51,090 --> 00:06:52,997
or to your particular project.

139
00:06:52,997 --> 00:06:55,080
We'll be clicking around
on some of them and we'll

140
00:06:55,080 --> 00:06:57,660
point out the most
important ones over time.

141
00:06:57,660 --> 00:06:59,650
On the far right, we
have a set of attributes.

142
00:06:59,650 --> 00:07:02,920
And all of these attributes, there
are various panes for the attributes.

143
00:07:02,920 --> 00:07:06,770
The panes will change depending on
the context of the main content, which

144
00:07:06,770 --> 00:07:08,290
happens to be in the middle.

145
00:07:08,290 --> 00:07:11,740
Now the middle can actually show
you a variety of things, for example

146
00:07:11,740 --> 00:07:13,290
your code itself.

147
00:07:13,290 --> 00:07:17,070
Or you might actually have-- when
you click on the storyboard which

148
00:07:17,070 --> 00:07:21,270
is, by the way, just a graphical
representation of your user

149
00:07:21,270 --> 00:07:25,350
interface for your application--
then the attributes pane

150
00:07:25,350 --> 00:07:27,334
on the very far right
will actually change.

151
00:07:27,334 --> 00:07:29,750
Now there's a couple of other
things that I want to point.

152
00:07:29,750 --> 00:07:33,360
You can sort of explore around
in the environment on your own.

153
00:07:33,360 --> 00:07:35,730
But one of the things
that has been very useful

154
00:07:35,730 --> 00:07:38,470
is this button here, the
top right of the window.

155
00:07:38,470 --> 00:07:41,230
There's this button that
looks like on the far

156
00:07:41,230 --> 00:07:46,090
left it has a paragraph
followed by two circles and sort

157
00:07:46,090 --> 00:07:49,540
of two arrows pointing
away from each other.

158
00:07:49,540 --> 00:07:52,640
If you switch between the
standard editor, which

159
00:07:52,640 --> 00:07:55,560
is the far left one, the one
that's selected by default,

160
00:07:55,560 --> 00:08:01,040
and the two circles overlapping
each other, what you actually get

161
00:08:01,040 --> 00:08:02,210
are a double pane view.

162
00:08:02,210 --> 00:08:04,240
>> And this is actually
going to be useful for us

163
00:08:04,240 --> 00:08:07,330
when we need to link items
in the UI to the code.

164
00:08:07,330 --> 00:08:09,330
And we'll talk more about
that in just a moment.

165
00:08:09,330 --> 00:08:12,050
But realize that if you get
even more panes like this,

166
00:08:12,050 --> 00:08:15,830
you can simplify your view just
a little bit by clicking back

167
00:08:15,830 --> 00:08:20,680
on your single editor.

168
00:08:20,680 --> 00:08:21,580
So far so good.

169
00:08:21,580 --> 00:08:24,560
So basically we have the code on
the left, attributes on the right,

170
00:08:24,560 --> 00:08:28,260
and whatever it is we're working
on here in the very center.

171
00:08:28,260 --> 00:08:30,390
>> So here I've clicked
on the main storyboard.

172
00:08:30,390 --> 00:08:33,350
And the storyboard,
again, is a way in Xcode

173
00:08:33,350 --> 00:08:38,110
that you can actually create your user
interface using just drag and drop

174
00:08:38,110 --> 00:08:39,130
techniques.

175
00:08:39,130 --> 00:08:41,190
And so for our very
first application this

176
00:08:41,190 --> 00:08:42,720
is precisely what we're going to do.

177
00:08:42,720 --> 00:08:45,950
We're going to go down to the
very far lower right portion

178
00:08:45,950 --> 00:08:49,900
of the screen, which contains
a variety of user elements

179
00:08:49,900 --> 00:08:53,270
that you can then click and drag
to create your user interface.

180
00:08:53,270 --> 00:08:55,550
>> Now all of these
elements are called views

181
00:08:55,550 --> 00:08:57,370
because they supply some sort of view.

182
00:08:57,370 --> 00:09:00,190
There's an image view, for
example, to actually show

183
00:09:00,190 --> 00:09:01,740
an image on the user interface.

184
00:09:01,740 --> 00:09:04,310
There's a table view to
actually show a table.

185
00:09:04,310 --> 00:09:05,190
So on and so forth.

186
00:09:05,190 --> 00:09:08,250
There's a wide variety of
views that you can select here.

187
00:09:08,250 --> 00:09:11,100
So just for now we're going
to search for a label.

188
00:09:11,100 --> 00:09:13,550
You can just scroll through
all of the lists that's there.

189
00:09:13,550 --> 00:09:15,460
But there's the search
bar at the very bottom

190
00:09:15,460 --> 00:09:19,460
that makes it easier to identify
specific views that you actually

191
00:09:19,460 --> 00:09:22,020
want to drag into your user interface.

192
00:09:22,020 --> 00:09:23,560
>> Found my label.

193
00:09:23,560 --> 00:09:28,430
I'm going to drag it here, directly
onto my sample application.

194
00:09:28,430 --> 00:09:30,130
Right there in the middle looks good.

195
00:09:30,130 --> 00:09:33,180
And I'm going to type "Hello World!"

196
00:09:33,180 --> 00:09:33,810
Hit Enter.

197
00:09:33,810 --> 00:09:34,877
Now I have a label.

198
00:09:34,877 --> 00:09:36,960
It doesn't look like it's
centered quite properly.

199
00:09:36,960 --> 00:09:38,500
So I can try to re-center it.

200
00:09:38,500 --> 00:09:42,100
Fortunately it offers these
guides to make things much easier.

201
00:09:42,100 --> 00:09:44,130
I'm going to try to compile it.

202
00:09:44,130 --> 00:09:46,570
Hopefully it will actually work here.

203
00:09:46,570 --> 00:09:52,870
And if it doesn't, in just a moment
it will in fact appear on my iPad.

204
00:09:52,870 --> 00:09:54,360
It's right here.

205
00:09:54,360 --> 00:09:55,060
There it is.

206
00:09:55,060 --> 00:09:56,590
>> OK, so that's it.

207
00:09:56,590 --> 00:09:57,160
We're done.

208
00:09:57,160 --> 00:09:58,868
We've created our very
first application.

209
00:09:58,868 --> 00:10:01,330
Now obviously this doesn't do anything.

210
00:10:01,330 --> 00:10:02,280
It's just a label.

211
00:10:02,280 --> 00:10:07,350
There's no connection between
the user interface and the code.

212
00:10:07,350 --> 00:10:10,130
So if we actually wanted
to create this connection,

213
00:10:10,130 --> 00:10:14,790
if we actually wanted to have some sort
of communication between the elements

214
00:10:14,790 --> 00:10:17,540
that exist on the
screen and the code that

215
00:10:17,540 --> 00:10:19,810
allows us to control
those elements, then

216
00:10:19,810 --> 00:10:23,570
we actually need to
look at the code itself.

217
00:10:23,570 --> 00:10:27,000
>> So this is what's called
ViewController.swift.

218
00:10:27,000 --> 00:10:30,080
And for, especially for
your first few programs,

219
00:10:30,080 --> 00:10:33,120
this is going to be sort of the
bulk of the code that you enter--

220
00:10:33,120 --> 00:10:35,980
is going to be in this document here.

221
00:10:35,980 --> 00:10:38,390
There's a lot of stuff
that's in here so far, right?

222
00:10:38,390 --> 00:10:42,660
There's import UI kit class, override,
[? funk, ?] all these various things.

223
00:10:42,660 --> 00:10:45,820
And it's not quite clear what
it is that all of this means.

224
00:10:45,820 --> 00:10:48,570
So let's take a step back away
from Xcode for a little bit

225
00:10:48,570 --> 00:10:52,420
and look at the language itself, swift.

226
00:10:52,420 --> 00:10:56,370
>> So with swift, it was in
design and development

227
00:10:56,370 --> 00:10:58,645
at Apple for about four
years to my understanding.

228
00:10:58,645 --> 00:11:01,270
And there's a couple of features
about it that are really neat.

229
00:11:01,270 --> 00:11:03,910
First of all, it's compiled
language, just like C.

230
00:11:03,910 --> 00:11:06,120
So you first have to
compile it and then run it

231
00:11:06,120 --> 00:11:09,580
before you can actually
execute the code that results.

232
00:11:09,580 --> 00:11:14,250
But there is, unlike C, an interactive
prompt that you can actually run

233
00:11:14,250 --> 00:11:16,680
and type arbitrary commands into.

234
00:11:16,680 --> 00:11:20,280
And very much like a JavaScript console,
which you may be familiar with now,

235
00:11:20,280 --> 00:11:24,506
it actually will evaluate those
commands and provide to you the output.

236
00:11:24,506 --> 00:11:26,380
And they've even taken
that to the next level

237
00:11:26,380 --> 00:11:29,100
and they've created something
called playgrounds in Xcode

238
00:11:29,100 --> 00:11:31,720
that allow you to
visually work with code.

239
00:11:31,720 --> 00:11:34,910
And we'll actually see some examples
of that in just a little bit.

240
00:11:34,910 --> 00:11:41,680
It's based on C. C underlies
it, because all of the compilers

241
00:11:41,680 --> 00:11:46,820
create code out of C and
create the object code from it.

242
00:11:46,820 --> 00:11:49,240
But it really shares
relatively little syntax.

243
00:11:49,240 --> 00:11:50,721
It will look fairly different.

244
00:11:50,721 --> 00:11:51,970
There'll be some similarities.

245
00:11:51,970 --> 00:11:54,140
But there are going to be
quite a few differences

246
00:11:54,140 --> 00:11:57,200
compared to, say, JavaScript or PHP.

247
00:11:57,200 --> 00:11:59,070
And we'll point these
out in just a moment.

248
00:11:59,070 --> 00:12:01,420
>> Now one of the biggest things
about swift that's nice

249
00:12:01,420 --> 00:12:05,650
is that, especially compared
to C, it's meant to be safe.

250
00:12:05,650 --> 00:12:08,100
Everything in it is meant to
be very strongly typed in.

251
00:12:08,100 --> 00:12:10,780
In fact it's almost annoying
at first, when you first

252
00:12:10,780 --> 00:12:15,610
start working with swift, just how
much it enforces types everywhere.

253
00:12:15,610 --> 00:12:17,860
Anything that's a string
has to remain a string.

254
00:12:17,860 --> 00:12:22,100
It's very difficult to sort of convert
it or coerce it into some other form.

255
00:12:22,100 --> 00:12:23,800
>> And again, we'll show examples of this.

256
00:12:23,800 --> 00:12:26,830
But ultimately realize that
this is meant to protect you,

257
00:12:26,830 --> 00:12:32,010
and by you I mean your code, from
crashing in some horrible way when

258
00:12:32,010 --> 00:12:34,330
you have some sort of mismatched type.

259
00:12:34,330 --> 00:12:36,040
And again, work with it.

260
00:12:36,040 --> 00:12:40,210
Because it will be frustrating at first
as you try to figure out why exactly

261
00:12:40,210 --> 00:12:43,070
you're getting this unusual
error dealing with types.

262
00:12:43,070 --> 00:12:45,350
But it will be worth it in the end.

263
00:12:45,350 --> 00:12:47,267
>> It does deal with automatic
memory management,

264
00:12:47,267 --> 00:12:49,100
so no longer do you
have to deal with things

265
00:12:49,100 --> 00:12:51,400
like malloc and free and all
of these sorts of things.

266
00:12:51,400 --> 00:12:53,066
And it's also designed for generalities.

267
00:12:53,066 --> 00:12:58,360
So while we can use an Xcode to
create iOS apps and Mac applications,

268
00:12:58,360 --> 00:13:00,380
we can also just use it
as a scripting language.

269
00:13:00,380 --> 00:13:03,660
And so we can use it sort
of instead of PHP or instead

270
00:13:03,660 --> 00:13:07,800
of Python to actually
quickly parse and process

271
00:13:07,800 --> 00:13:09,800
some data that we have on our computer.

272
00:13:09,800 --> 00:13:13,290
>> It has a wide variety of modern
features, optionals, mutability,

273
00:13:13,290 --> 00:13:17,900
generics, closures, and a lot of this
stuff you may or may not recognize.

274
00:13:17,900 --> 00:13:22,810
And it's just sort of an unfortunate
part of the language that some of these

275
00:13:22,810 --> 00:13:26,700
sort of futuristic, modern elements that
are contained within the elements are

276
00:13:26,700 --> 00:13:34,520
so deeply ingrained that I actually will
have to teach you CS50.5 a little bit.

277
00:13:34,520 --> 00:13:37,305
>> We have to learn a little bit more
about some of features in order

278
00:13:37,305 --> 00:13:40,180
to really understand what's going
on and so that you can look at code

279
00:13:40,180 --> 00:13:42,450
and not feel totally lost.

280
00:13:42,450 --> 00:13:44,820
And you'll see what I mean
by that in just a minute.

281
00:13:44,820 --> 00:13:47,830
OK, so let's-- enough of this
sort of theoretical stuff.

282
00:13:47,830 --> 00:13:52,450
Let's actually look at our
very first swift program.

283
00:13:52,450 --> 00:13:53,590
It's one line of code.

284
00:13:53,590 --> 00:13:57,690
Line 14 right here, it
says print l n hello CS50.

285
00:13:57,690 --> 00:14:01,160
>> So there's a couple of things that's
very different about this compared

286
00:14:01,160 --> 00:14:04,140
to things that you might be
used to from C, for example.

287
00:14:04,140 --> 00:14:08,390
One of them is that there's no
intmain, there's no include section,

288
00:14:08,390 --> 00:14:10,790
there's none of this extra stuff.

289
00:14:10,790 --> 00:14:13,790
The include, like standard
I/O, like the libraries

290
00:14:13,790 --> 00:14:16,580
that actually provide the
standard features of the language,

291
00:14:16,580 --> 00:14:19,180
are automatically included as
part of swift's standard library

292
00:14:19,180 --> 00:14:20,680
and that are automatically imported.

293
00:14:20,680 --> 00:14:23,740
You don't have to do
that import manually.

294
00:14:23,740 --> 00:14:27,360
>> Intmain doesn't exist because
the main entry point for the code

295
00:14:27,360 --> 00:14:29,470
is actually at the
beginning of the code.

296
00:14:29,470 --> 00:14:32,000
So any code that you have
starting from the beginning

297
00:14:32,000 --> 00:14:34,940
will actually be executed at the start.

298
00:14:34,940 --> 00:14:36,520
So this really greatly simplifies.

299
00:14:36,520 --> 00:14:38,470
Notice also, that there's no semicolon.

300
00:14:38,470 --> 00:14:41,040
There's no semicolons in this language.

301
00:14:41,040 --> 00:14:43,261
You put a statement
on an individual line

302
00:14:43,261 --> 00:14:45,510
and then the next line
represents the other statement.

303
00:14:45,510 --> 00:14:47,420
If you want to put
mulitiple statements online,

304
00:14:47,420 --> 00:14:49,086
then you have separate it by semicolons.

305
00:14:49,086 --> 00:14:50,940
But for the most part,
for good style, we're

306
00:14:50,940 --> 00:14:56,530
never going to see semicolons for
the purposes of separating statements

307
00:14:56,530 --> 00:14:58,420
in swift.

308
00:14:58,420 --> 00:14:59,820
So how does this actually work?

309
00:14:59,820 --> 00:15:04,080
Well very much like C we
actually have to compile this.

310
00:15:04,080 --> 00:15:10,640
And so we can do that by using
swift c and then 1.swift.

311
00:15:10,640 --> 00:15:13,850
And then after a couple
minutes this will compile

312
00:15:13,850 --> 00:15:16,340
and then I can run item one.

313
00:15:16,340 --> 00:15:19,691
And than it will just say "Hello CS50."

314
00:15:19,691 --> 00:15:20,690
Awesome, so there we go.

315
00:15:20,690 --> 00:15:22,273
There's our first hello world program.

316
00:15:22,273 --> 00:15:24,790
Let's move on to number two.

317
00:15:24,790 --> 00:15:30,450
>> Now in this-- this has changed
slightly, because whereas normally you

318
00:15:30,450 --> 00:15:34,720
do-- in fact always do you have to
compile a swift application before you

319
00:15:34,720 --> 00:15:37,180
actually run it-- one
of the great features

320
00:15:37,180 --> 00:15:40,230
that I alluded to before was that
swift can actually be used in sort

321
00:15:40,230 --> 00:15:43,390
of a pseudo-interpretive mode, there
is in fact like an interpreter.

322
00:15:43,390 --> 00:15:46,690
But what this will do is there
is, in fact, a swift application

323
00:15:46,690 --> 00:15:47,520
that you can run.

324
00:15:47,520 --> 00:15:51,050
>> So for example if you just type
swift here, what will happen

325
00:15:51,050 --> 00:15:52,330
is that you will get a prompt.

326
00:15:52,330 --> 00:15:59,040
And you can type your swift
code, print hello, and run it.

327
00:15:59,040 --> 00:16:01,867
And it will actually print--
well, it didn't print in this case

328
00:16:01,867 --> 00:16:04,450
because it printed to centered
out, which is not visible here.

329
00:16:04,450 --> 00:16:06,660
But it is actually able to function.

330
00:16:06,660 --> 00:16:09,580
And so in this case, I'm just
going to use this as a script.

331
00:16:09,580 --> 00:16:11,259
And I can actually run this code there.

332
00:16:11,259 --> 00:16:13,800
So the way that I actually run
it will be slightly different,

333
00:16:13,800 --> 00:16:15,710
but you'll see that in just a moment.

334
00:16:15,710 --> 00:16:18,890
Now, in this case what we're going
to do is to first define a variable.

335
00:16:18,890 --> 00:16:22,160
So this is how we define
a variable in swift,

336
00:16:22,160 --> 00:16:25,900
is we use the let keyword, followed
by the name of the variable,

337
00:16:25,900 --> 00:16:29,280
and then we provide some
initializing data optionally.

338
00:16:29,280 --> 00:16:34,660
So this case we're defining
a constant called name,

339
00:16:34,660 --> 00:16:37,775
and we're going to use that in
the output of our print line

340
00:16:37,775 --> 00:16:39,590
at the very bottom, hello name.

341
00:16:39,590 --> 00:16:43,260
>> Now notice that rather than using %s,
we can encapsulate the name of this

342
00:16:43,260 --> 00:16:49,960
variable in /() and be able to
concatenate in the contents of this

343
00:16:49,960 --> 00:16:51,790
string into this string.

344
00:16:51,790 --> 00:16:56,510
Now unlike C, string is an
actual real type in swift.

345
00:16:56,510 --> 00:16:59,240
And so it sits alongside
ints and alongside

346
00:16:59,240 --> 00:17:02,220
doubles very easily
and naturally compared

347
00:17:02,220 --> 00:17:05,450
to some of the other
languages that we've seen.

348
00:17:05,450 --> 00:17:07,980
So this would actually function
just like you would expect.

349
00:17:07,980 --> 00:17:10,540
>> I can run 2.swift.

350
00:17:10,540 --> 00:17:14,390
And we see that my name is
actually spliced in, "Hello Dan."

351
00:17:14,390 --> 00:17:16,050
OK, awesome.

352
00:17:16,050 --> 00:17:17,485
Moving on to number three.

353
00:17:17,485 --> 00:17:19,359
Now it was a little bit
of a white lie that I

354
00:17:19,359 --> 00:17:23,369
said that the way that we declare
variables was to use the let keyword.

355
00:17:23,369 --> 00:17:27,640
As many times as you possibly can you do
want to use let, because what that does

356
00:17:27,640 --> 00:17:29,280
is it defines a constant.

357
00:17:29,280 --> 00:17:33,010
And that tells swift that it can
optimize the speed of your application

358
00:17:33,010 --> 00:17:36,230
because it knows that that
variable is not going to change.

359
00:17:36,230 --> 00:17:38,760
>> So evaluate carefully
when you're going to use

360
00:17:38,760 --> 00:17:41,382
a variable for the
purposes of changing it.

361
00:17:41,382 --> 00:17:43,340
And when you're going to
create a variable just

362
00:17:43,340 --> 00:17:47,010
to hold some data and that is
not actually going to change.

363
00:17:47,010 --> 00:17:50,150
So this concept of immutability,
it's not actually going to change,

364
00:17:50,150 --> 00:17:53,740
is an important one even as
far down as defining variables.

365
00:17:53,740 --> 00:17:56,870
So here we've defined a name,
let name, and in this case

366
00:17:56,870 --> 00:18:02,120
it's a constant, that is of type
string, and it is equal to Dan.

367
00:18:02,120 --> 00:18:05,580
>> So whereas in the prior
version, it infers-- and by "it"

368
00:18:05,580 --> 00:18:08,220
I mean swift-- swift
infers the type of data

369
00:18:08,220 --> 00:18:10,850
that we've entered into the variable.

370
00:18:10,850 --> 00:18:12,930
In this case, we can be explicit.

371
00:18:12,930 --> 00:18:17,590
So let then the name of this
variable is name, then a colon.

372
00:18:17,590 --> 00:18:21,350
And after the colon do we
specify the type of data.

373
00:18:21,350 --> 00:18:24,694
So no longer is it int name or
string name or something like that.

374
00:18:24,694 --> 00:18:26,860
But instead let label, we're
defining whether or not

375
00:18:26,860 --> 00:18:29,090
it's constant or variable,
followed by the name,

376
00:18:29,090 --> 00:18:31,870
followed by the type optionally.

377
00:18:31,870 --> 00:18:34,730
>> So in this case we're defining
this name is a string.

378
00:18:34,730 --> 00:18:35,790
We're saying is Dan.

379
00:18:35,790 --> 00:18:39,270
And now I have another variable,
in this case it's called label.

380
00:18:39,270 --> 00:18:42,090
But notice that it is
prefixed with the var keyword.

381
00:18:42,090 --> 00:18:44,430
The var keyword means
that this variable can

382
00:18:44,430 --> 00:18:48,720
be changed at a later point in
time, somewhere down in the code

383
00:18:48,720 --> 00:18:52,480
can we actually change it and it
won't give us any particular error.

384
00:18:52,480 --> 00:18:56,760
>> We can do standard concatenating
operator here using the plus symbol

385
00:18:56,760 --> 00:19:00,130
to actually add our
name into this string.

386
00:19:00,130 --> 00:19:02,921
And then we can print out
as we saw just a moment ago.

387
00:19:02,921 --> 00:19:04,920
Now let's say that you
want to create a variable

388
00:19:04,920 --> 00:19:06,586
but you don't want to initialize it yet.

389
00:19:06,586 --> 00:19:08,590
You don't yet want to
put any data within it.

390
00:19:08,590 --> 00:19:11,760
Well you have to tell
swift what the type of data

391
00:19:11,760 --> 00:19:16,430
is going to be before you can
actually define it properly.

392
00:19:16,430 --> 00:19:20,360
>> So in this case, when we've defined
a variable called grade we have to be

393
00:19:20,360 --> 00:19:24,450
explicit about its type, because
it cannot infer just looking

394
00:19:24,450 --> 00:19:27,300
at the initialized data
that you provide to it.

395
00:19:27,300 --> 00:19:30,050
It will give us an error if you
just type var grade, for instance,

396
00:19:30,050 --> 00:19:31,830
because it has no type therefore.

397
00:19:31,830 --> 00:19:33,353
So grade=100.

398
00:19:33,353 --> 00:19:35,790
So that 100 is an integer, it
fits very nicely into that.

399
00:19:35,790 --> 00:19:36,998
It will continue to function.

400
00:19:36,998 --> 00:19:40,350

401
00:19:40,350 --> 00:19:43,022
We can see how then we
can concatenate this in.

402
00:19:43,022 --> 00:19:44,730
Now you might be
tempted, if you actually

403
00:19:44,730 --> 00:19:48,610
wanted to concatenate the
grade into another text string,

404
00:19:48,610 --> 00:19:52,560
into another string, that you would just
use that same concatenating operator.

405
00:19:52,560 --> 00:19:54,630
And that would normally be true.

406
00:19:54,630 --> 00:20:00,540
But swift will not allow you to
implicitly change the type of data.

407
00:20:00,540 --> 00:20:03,440
So in this case, this
line, 25, will fail

408
00:20:03,440 --> 00:20:06,650
because grade is an
integer and not a string.

409
00:20:06,650 --> 00:20:08,760
And so there's a mismatch set of types.

410
00:20:08,760 --> 00:20:11,780
So you have to be explicit when
you want to change this data,

411
00:20:11,780 --> 00:20:14,080
when you want to coerce this
data into a different type

412
00:20:14,080 --> 00:20:17,250
and say, OK, I want to take
this grade, which is an integer,

413
00:20:17,250 --> 00:20:19,050
and convert it to a string.

414
00:20:19,050 --> 00:20:23,970
>> So I take a capital s String all of the
types, you'll notice, are capitalized,

415
00:20:23,970 --> 00:20:26,280
Int, Double, String, so on and so forth.

416
00:20:26,280 --> 00:20:28,930
All of them are capitalized
just to make things easier.

417
00:20:28,930 --> 00:20:32,240
And we'll say capitalize
String pass into it grade.

418
00:20:32,240 --> 00:20:35,020
And it will create a
string out of that integer.

419
00:20:35,020 --> 00:20:37,970
And then we can concatenate
the two very nicely.

420
00:20:37,970 --> 00:20:40,500
Any questions on this stuff so far?

421
00:20:40,500 --> 00:20:43,770
All right, let's plow
through to number four.

422
00:20:43,770 --> 00:20:47,870
>> Now let's talk about some more advanced
structures, like arrays and loops.

423
00:20:47,870 --> 00:20:54,920
And unlike C, arrays in swift
are not represented by pointers.

424
00:20:54,920 --> 00:20:58,730
Pointers in swift,
although they exist, called

425
00:20:58,730 --> 00:21:02,840
like unsafe pointers or
some similar type like this,

426
00:21:02,840 --> 00:21:04,950
they're not exposed to you normally.

427
00:21:04,950 --> 00:21:07,300
So it becomes very difficult
for you to manipulate

428
00:21:07,300 --> 00:21:10,020
the memory directly of your computer.

429
00:21:10,020 --> 00:21:11,670
>> So arrays are just a data type.

430
00:21:11,670 --> 00:21:16,830
And they're referenced using this sort
of now standard square bracket notation

431
00:21:16,830 --> 00:21:18,280
that you've seen before.

432
00:21:18,280 --> 00:21:21,130
But when you actually want to
define a type of a variable

433
00:21:21,130 --> 00:21:24,330
as an array of some
particular type, then you

434
00:21:24,330 --> 00:21:27,150
put that type in square brackets.

435
00:21:27,150 --> 00:21:30,260
So what I'm saying here is that
I'm creating a variable called

436
00:21:30,260 --> 00:21:33,930
grades of type int array.

437
00:21:33,930 --> 00:21:37,380
And I'm setting that equal to some
initialized data, which in this case

438
00:21:37,380 --> 00:21:42,960
is 100, 0, 90, 85, which is just a
collection of arbitrary grades here.

439
00:21:42,960 --> 00:21:46,480
Now in this case I could,
remember, remove the type,

440
00:21:46,480 --> 00:21:49,580
and it would be able to infer it
based on the initialized data.

441
00:21:49,580 --> 00:21:51,990
But if I removed this and
I needed to set it later,

442
00:21:51,990 --> 00:21:56,840
then I would have to make sure
that I have the type there.

443
00:21:56,840 --> 00:21:58,750
All right, let's move along.

444
00:21:58,750 --> 00:22:03,010
So we can-- arrays
provide to us a variety

445
00:22:03,010 --> 00:22:07,130
of methods through that dot notation
at you are probably now familiar with.

446
00:22:07,130 --> 00:22:10,360
So grades.count, for example,
tells us precisely the number

447
00:22:10,360 --> 00:22:13,680
of elements that are
contained within this array.

448
00:22:13,680 --> 00:22:17,260
>> If I want to add additional--
now notice that this is a var

449
00:22:17,260 --> 00:22:20,140
and not-- this is a variable
and not a constant, which

450
00:22:20,140 --> 00:22:24,410
means that I can change the contents
of this array, I can add objects to it.

451
00:22:24,410 --> 00:22:28,870
But I can't just say grades
and then in square brackets

452
00:22:28,870 --> 00:22:33,280
four, because that will be an
out of bounds error in this case.

453
00:22:33,280 --> 00:22:36,190
If I want to actually change
the size of this array,

454
00:22:36,190 --> 00:22:41,140
I have to use the dot append method to
add something on to the very end of it.

455
00:22:41,140 --> 00:22:46,900
I can, however, change
individual indices.

456
00:22:46,900 --> 00:22:48,920
>> So I could use grades
and then square brackets

457
00:22:48,920 --> 00:22:52,480
zero to manipulate this first index and
so on, like you would normally expect.

458
00:22:52,480 --> 00:22:56,530
And I can do the same to actually
receive the data from that as well.

459
00:22:56,530 --> 00:23:00,420
Now there's also sort of a fancy method
of doing this, grades plus equals

460
00:23:00,420 --> 00:23:02,525
and then another index,
which will append--

461
00:23:02,525 --> 00:23:04,400
or not another index--
but another list which

462
00:23:04,400 --> 00:23:07,340
will append that list
to the back of grades.

463
00:23:07,340 --> 00:23:09,780
And the grades will
then contain all that.

464
00:23:09,780 --> 00:23:13,850
But that's sort of an extra thing
that I'm just showing you for fun.

465
00:23:13,850 --> 00:23:14,910
>> Now there's a for loop.

466
00:23:14,910 --> 00:23:18,970
And this is the start of where
things start to change a little bit.

467
00:23:18,970 --> 00:23:22,920
Notice how this for loop is
different from for loops in C.

468
00:23:22,920 --> 00:23:26,470
Now I will note that
for loops in Swift can

469
00:23:26,470 --> 00:23:30,650
be made to look like for loops in C, but
there's a lot of more useful constructs

470
00:23:30,650 --> 00:23:37,840
that essentially eliminate the need
to have for var i equals 0 semicolon i

471
00:23:37,840 --> 00:23:40,340
is less than some length,
so on and so forth, right?

472
00:23:40,340 --> 00:23:42,940
And this construct is just one of them.

473
00:23:42,940 --> 00:23:49,030
>> For index, index is new
variable, in this case, in range.

474
00:23:49,030 --> 00:23:52,730
And what I'm saying is that there's
a range from 0 all the way up to

475
00:23:52,730 --> 00:23:55,870
but not including grades.count.

476
00:23:55,870 --> 00:23:58,470
So this dot dot less
than sign represents

477
00:23:58,470 --> 00:24:05,040
a range of values starting from zero
all the way up to grades.count minus 1.

478
00:24:05,040 --> 00:24:07,070
There is a separate
operator that exists,

479
00:24:07,070 --> 00:24:13,320
which is dot dot dot, which would
mean that I want the range of zero

480
00:24:13,320 --> 00:24:16,310
to grades count inclusive.

481
00:24:16,310 --> 00:24:19,130
>> But in this case, because these
arrays are zero index, we of course

482
00:24:19,130 --> 00:24:23,290
do not want to go to the
maximum number of grades.

483
00:24:23,290 --> 00:24:26,390
I can sum the grades, as you might
expect, and output all of this stuff.

484
00:24:26,390 --> 00:24:29,620
OK, moving on.

485
00:24:29,620 --> 00:24:32,270
Now let's talk about functions.

486
00:24:32,270 --> 00:24:35,465
In order to define a function
you use the funk keyword.

487
00:24:35,465 --> 00:24:38,090
And again, in Swift you have to
be very careful with the types.

488
00:24:38,090 --> 00:24:41,530
You provide to it parameters
by defining, for example,

489
00:24:41,530 --> 00:24:45,440
the name of the parameter and
then in colin, the type of data

490
00:24:45,440 --> 00:24:47,690
that you expect that
parameter to accept.

491
00:24:47,690 --> 00:24:50,700
>> So in this case we have a
function called print grade count.

492
00:24:50,700 --> 00:24:54,630
It accepts a variable called gradebook,
or rather a parameter called gradebook.

493
00:24:54,630 --> 00:24:59,267
And we are expecting that gradebook
to be an array of integers.

494
00:24:59,267 --> 00:25:01,350
If that gradebook is empty,
we'll print one thing.

495
00:25:01,350 --> 00:25:06,090
Otherwise we will print out the number
of grades that this actually has.

496
00:25:06,090 --> 00:25:09,470
>> Now if we want to return
some value, then the way

497
00:25:09,470 --> 00:25:14,595
that we modify this definition is
to actually use this arrow keyword,

498
00:25:14,595 --> 00:25:16,870
or to use this arrow signifier.

499
00:25:16,870 --> 00:25:19,440
So here we're going to define
a function called average.

500
00:25:19,440 --> 00:25:21,940
We're going to accept a list of numbers.

501
00:25:21,940 --> 00:25:25,430
And we're going to return a
double, which will hopefully

502
00:25:25,430 --> 00:25:31,270
be the average of this array.

503
00:25:31,270 --> 00:25:34,570
And in order to do that, in order
to actually calculate this average,

504
00:25:34,570 --> 00:25:38,651
we will take a sum and we will of
course sum up all of the objects

505
00:25:38,651 --> 00:25:39,400
within this array.

506
00:25:39,400 --> 00:25:41,480
>> Notice that there's a new
style of for loop here.

507
00:25:41,480 --> 00:25:45,450
We don't have to be explicit about
iterating over every single element,

508
00:25:45,450 --> 00:25:48,280
but we can instead say for
grade and gradebook, meaning

509
00:25:48,280 --> 00:25:50,930
that for every single
item that we have in this,

510
00:25:50,930 --> 00:25:53,482
provide that item in this
variable called grade.

511
00:25:53,482 --> 00:25:54,940
And I want to do something with it.

512
00:25:54,940 --> 00:26:00,350
So I'm going to sum all of this data
and actually return the double division.

513
00:26:00,350 --> 00:26:04,436
>> Now notice again here there is the
concept of integer division in Swift.

514
00:26:04,436 --> 00:26:06,810
If you want to double division
because you want decimals,

515
00:26:06,810 --> 00:26:09,460
then you have to be explicit,
not just about one side,

516
00:26:09,460 --> 00:26:14,030
because it's not going to allow you
to coerce data on either side of this,

517
00:26:14,030 --> 00:26:17,030
you have to actually course
both sides into doubles

518
00:26:17,030 --> 00:26:19,440
so that you're very
explicit about making sure

519
00:26:19,440 --> 00:26:23,370
that you're doing double division.

520
00:26:23,370 --> 00:26:26,150
>> Let's move on.

521
00:26:26,150 --> 00:26:31,150
So if I actually want to accept--
so in this particular example,

522
00:26:31,150 --> 00:26:34,260
this is still a command
line based application.

523
00:26:34,260 --> 00:26:37,920
And we're starting to see some of
the limitations of the young language

524
00:26:37,920 --> 00:26:41,850
in that although we can
access the arguments by using

525
00:26:41,850 --> 00:26:44,940
this process.arguments, it's
still not necessarily the cleanest

526
00:26:44,940 --> 00:26:46,200
thing that we've ever seen.

527
00:26:46,200 --> 00:26:49,142
But basically I encourage you
to sort of look at this code

528
00:26:49,142 --> 00:26:51,100
and try to figure out
what exactly is going on.

529
00:26:51,100 --> 00:26:55,030
>> Essentially what's happening is that
we're taking a list of arguments

530
00:26:55,030 --> 00:26:57,610
and were coercing them into
integers, and then we're

531
00:26:57,610 --> 00:27:03,620
going to use that as a way to print
out the average of all of our grades.

532
00:27:03,620 --> 00:27:06,150

533
00:27:06,150 --> 00:27:07,350
Moving on.

534
00:27:07,350 --> 00:27:11,190
Now there's another type of data--
another data type rather than arrays

535
00:27:11,190 --> 00:27:14,940
called dictionaries, which are very
similar to hash tables or hash maps

536
00:27:14,940 --> 00:27:18,560
and are similar also to
PHP's associative arrays.

537
00:27:18,560 --> 00:27:20,770
So they have the notion
of keys and values.

538
00:27:20,770 --> 00:27:23,780
>> And they're defined also with
this square bracket notation,

539
00:27:23,780 --> 00:27:26,750
but the difference is
that dictionaries have

540
00:27:26,750 --> 00:27:29,370
inside of the square bracket, a colon.

541
00:27:29,370 --> 00:27:33,850
And the colon separates the data
type that is the key and the value.

542
00:27:33,850 --> 00:27:38,540
So in this case, I'm going to create
a dictionary to accept some grades.

543
00:27:38,540 --> 00:27:44,200
And it is going to be
of type string:int,

544
00:27:44,200 --> 00:27:46,940
which means that all of the
keys are going to be strings,

545
00:27:46,940 --> 00:27:53,080
and all of the values of those
keys are going to be integers.

546
00:27:53,080 --> 00:27:55,780
>> What this means is that I can
then reference the specific data

547
00:27:55,780 --> 00:28:00,490
that I want using those keys rather
than using numeric indices like I

548
00:28:00,490 --> 00:28:04,350
would have for a standard array.

549
00:28:04,350 --> 00:28:06,470
Now let's see, there's
one important thing

550
00:28:06,470 --> 00:28:10,790
that I also want to mention about
this particular sequence of code.

551
00:28:10,790 --> 00:28:12,910
And that is that there's
another type of data,

552
00:28:12,910 --> 00:28:15,580
or rather there's this
idea of data that is

553
00:28:15,580 --> 00:28:18,340
contained within Swift called optionals.

554
00:28:18,340 --> 00:28:21,270
>> And what optionals means is
that it acknowledges the fact

555
00:28:21,270 --> 00:28:27,500
that sometimes you're not going to
get the data that you actually expect.

556
00:28:27,500 --> 00:28:31,400
And so what I mean by that is-- let's
take a look at this sequence of code

557
00:28:31,400 --> 00:28:38,910
which iterates over all of the
arguments that were passed to this code

558
00:28:38,910 --> 00:28:43,460
and tries to convert them, tries
to split into a variety of strings,

559
00:28:43,460 --> 00:28:47,310
because it accepts a very
particular type of argument.

560
00:28:47,310 --> 00:28:51,530
And then it is going to try to coerce
the strings that represent numbers

561
00:28:51,530 --> 00:28:55,460
into integers that are grades,
that I can then compute.

562
00:28:55,460 --> 00:28:58,230
>> So basically I'm going to
use this split function that

563
00:28:58,230 --> 00:29:00,080
exists within the
Swift standard library.

564
00:29:00,080 --> 00:29:03,720
I'm going to pass into it the
string that I want to split.

565
00:29:03,720 --> 00:29:06,980
And then in using this
sort of funky syntax, which

566
00:29:06,980 --> 00:29:09,670
I don't know if we'll
get to, but maybe, we

567
00:29:09,670 --> 00:29:14,320
will actually specify the precise
character that we want to split at.

568
00:29:14,320 --> 00:29:16,030
So what does this actually look like?

569
00:29:16,030 --> 00:29:18,740
Let's take a look at
actually running this code.

570
00:29:18,740 --> 00:29:22,000
>> So for example, let's say I have
a quiz and I got 50 on that.

571
00:29:22,000 --> 00:29:23,960
And I have a PSETs and
I got a hundred on that.

572
00:29:23,960 --> 00:29:29,180
And I got-- there's another
quiz and I got a 40 on that.

573
00:29:29,180 --> 00:29:33,520
I hit Enter, and eventually what
will happen is that what it's doing

574
00:29:33,520 --> 00:29:37,730
is taking these parameters, splitting
the strings at these colons,

575
00:29:37,730 --> 00:29:41,390
recognizing that there's
two elements in each one,

576
00:29:41,390 --> 00:29:43,700
and it's essentially
keeping track of each.

577
00:29:43,700 --> 00:29:49,226
>> So I have in my dictionary a quiz, whose
value is represented by the number 50,

578
00:29:49,226 --> 00:29:54,290
I have a PSET that has value of 100,
and a quiz one which has a value of 40.

579
00:29:54,290 --> 00:29:57,400
Then later on in the code I
actually average all of those values

580
00:29:57,400 --> 00:30:01,160
and list all of the keys of
that particular dictionary.

581
00:30:01,160 --> 00:30:03,217
But this is important
so that you can notice

582
00:30:03,217 --> 00:30:06,050
what is happening, is that what we
want to do is to take this string

583
00:30:06,050 --> 00:30:11,450
and split it at this character,
which we can do again with this split

584
00:30:11,450 --> 00:30:15,690
function using this sort of
interesting syntax that exists here.

585
00:30:15,690 --> 00:30:17,880
>> Just for now assume that that's OK.

586
00:30:17,880 --> 00:30:19,980
We'll look more at this
in just a little while.

587
00:30:19,980 --> 00:30:23,230
But now there's an interesting
aspect that we actually

588
00:30:23,230 --> 00:30:27,250
want to try to convert this
string into an integer.

589
00:30:27,250 --> 00:30:29,720
But in other languages
what might happen is

590
00:30:29,720 --> 00:30:33,440
that we would probably try
to do it and either get back

591
00:30:33,440 --> 00:30:36,185
some sort of sentinel
value like negative one

592
00:30:36,185 --> 00:30:39,420
or maybe a null or something like that.

593
00:30:39,420 --> 00:30:41,070
Or maybe it would just caused an error.

594
00:30:41,070 --> 00:30:42,820
And we would have to
then catch that error

595
00:30:42,820 --> 00:30:44,820
and then try to do
something based on the fact

596
00:30:44,820 --> 00:30:48,280
that this conversion
to an integer failed.

597
00:30:48,280 --> 00:30:50,460
That's where this idea
of optionals comes in.

598
00:30:50,460 --> 00:30:56,120
You can actually create a data type that
is an int question mark, for example.

599
00:30:56,120 --> 00:30:59,140

600
00:30:59,140 --> 00:31:01,910
That means that this integer
is, in fact, optional.

601
00:31:01,910 --> 00:31:05,980
And what will happen is that it may
contain an integer, or it may not.

602
00:31:05,980 --> 00:31:10,650
It may, in fact, be this other
idea, entirely called nill.

603
00:31:10,650 --> 00:31:14,900
In which that means that there's
no value whatsoever in this.

604
00:31:14,900 --> 00:31:16,810
It's not even zero,
there's just no value.

605
00:31:16,810 --> 00:31:18,790
There's absolutely no value represented.

606
00:31:18,790 --> 00:31:21,650
>> And that is what this line 71 is doing.

607
00:31:21,650 --> 00:31:25,990
Is that it is saying that I
want to try to set a value,

608
00:31:25,990 --> 00:31:31,790
a variable called grade, equal to the
conversion of this string into an int.

609
00:31:31,790 --> 00:31:34,010
So I've taken this string,
this first components,

610
00:31:34,010 --> 00:31:37,680
or rather the second
components, because this

611
00:31:37,680 --> 00:31:40,770
is zero indexed, of this
string that I've split.

612
00:31:40,770 --> 00:31:42,930
And I want to convert
that to an integer.

613
00:31:42,930 --> 00:31:46,730
But it may not always proceed
normally, because imagine

614
00:31:46,730 --> 00:31:50,710
what would happen if, rather than type
a number, I type of course like asdf.

615
00:31:50,710 --> 00:31:51,534
>> It's going to fail.

616
00:31:51,534 --> 00:31:54,200
It's not actually going to be
able to convert that to an integer

617
00:31:54,200 --> 00:31:55,510
as I would expect.

618
00:31:55,510 --> 00:31:58,660
So rather than kick off
some sort of an error,

619
00:31:58,660 --> 00:32:01,210
we have this idea of an optional.

620
00:32:01,210 --> 00:32:04,240
And that means that using
this question mark I can say,

621
00:32:04,240 --> 00:32:09,100
OK, is it possible that I can take
this, converted it into an int,

622
00:32:09,100 --> 00:32:12,630
and put it into a variable,
which will also be an int.

623
00:32:12,630 --> 00:32:15,420
If so, then that means
that this was successful

624
00:32:15,420 --> 00:32:18,720
and this first portion of
the block can continue.

625
00:32:18,720 --> 00:32:21,040
>> Otherwise, it failed.

626
00:32:21,040 --> 00:32:25,840
There is no value in grade-- or
rather there is no value in existing,

627
00:32:25,840 --> 00:32:30,220
and I actually have to try to
handle this error condition.

628
00:32:30,220 --> 00:32:33,340
You're going to see this
question mark all the time

629
00:32:33,340 --> 00:32:35,990
in Swift and in example code for Swift.

630
00:32:35,990 --> 00:32:40,980
And in fact the nill operator, this sort
of question mark, the optionals part,

631
00:32:40,980 --> 00:32:45,057
is going to be probably one
of the more difficult things

632
00:32:45,057 --> 00:32:47,640
to sort of wrap your head around
as you actually work with it.

633
00:32:47,640 --> 00:32:48,490
>> It might make sense now.

634
00:32:48,490 --> 00:32:50,760
And in fact, when I was
writing sample code for this,

635
00:32:50,760 --> 00:32:52,780
certainly I understood
what was going on,

636
00:32:52,780 --> 00:32:55,570
but still caught me by
surprise every so often

637
00:32:55,570 --> 00:32:58,370
when I would find that
some data was actually

638
00:32:58,370 --> 00:33:04,024
a nil version, an optional version
of the data that I was expecting.

639
00:33:04,024 --> 00:33:06,190
So just realize that if you
have an optional version

640
00:33:06,190 --> 00:33:09,360
you have to unpack that
data from this box.

641
00:33:09,360 --> 00:33:15,870
>> So it's sort of like I-- imagine if you
have a box and it contains something.

642
00:33:15,870 --> 00:33:18,490
And what you need to do
is to ask the question,

643
00:33:18,490 --> 00:33:22,800
is it possible that this box actually
contains the data that I'm looking for?

644
00:33:22,800 --> 00:33:28,180
If so, then pull that data out and
put it into this variable existing.

645
00:33:28,180 --> 00:33:32,080
If not, then I just have to
disregard the contents of this box

646
00:33:32,080 --> 00:33:34,310
altogether because it
literally contains nothing.

647
00:33:34,310 --> 00:33:36,880

648
00:33:36,880 --> 00:33:40,400
>> Any questions on this?

649
00:33:40,400 --> 00:33:44,430
OK, let's move away from this
sort of command line based thing

650
00:33:44,430 --> 00:33:47,610
and start looking at
some of the technology

651
00:33:47,610 --> 00:33:53,060
that Xcode provides to us
in the form of playgrounds.

652
00:33:53,060 --> 00:33:56,669
So there's a lot of
capability here with Swift.

653
00:33:56,669 --> 00:33:59,210
And if you open up Xcode and it
asks you what you want to do,

654
00:33:59,210 --> 00:34:01,340
you can open up the playground
and just play around

655
00:34:01,340 --> 00:34:06,200
with a lot of different structures
and aspects of the language

656
00:34:06,200 --> 00:34:11,800
before you even start touching
the iOS SDK or the Mac SDK.

657
00:34:11,800 --> 00:34:15,670
>> So this case, let's say that I have--
I have a relatively contrived example

658
00:34:15,670 --> 00:34:18,460
here, but bear with me as we sort
of work through this example.

659
00:34:18,460 --> 00:34:22,639
Let's say that we have to do a lot
of exponents with a fixed value,

660
00:34:22,639 --> 00:34:26,397
like we know that we're going to need to
do a lot of square powers, for example.

661
00:34:26,397 --> 00:34:28,980
So we're going to take some value
x, we're going to square it,

662
00:34:28,980 --> 00:34:30,540
we're going to take some value
y and we're going to square it.

663
00:34:30,540 --> 00:34:31,780
So on and so forth.

664
00:34:31,780 --> 00:34:35,549
>> Now we might actually just create a
power of 2 function for this, right?

665
00:34:35,549 --> 00:34:37,090
So we'd create a power of 2 function.

666
00:34:37,090 --> 00:34:38,600
We'll accept a double.

667
00:34:38,600 --> 00:34:41,489
We'll output-- or we'll
return a double type.

668
00:34:41,489 --> 00:34:46,159
We'll take this result
and then for twice

669
00:34:46,159 --> 00:34:52,040
what we actually take the results, which
was the initialized to value of one,

670
00:34:52,040 --> 00:34:53,090
and multiply it by x.

671
00:34:53,090 --> 00:34:56,540
So in essence we have x times x here.

672
00:34:56,540 --> 00:35:01,860
>> And so then I can then, as we might
expect, take this, run power of 2,

673
00:35:01,860 --> 00:35:03,680
provide to it some data, I like 2.0.

674
00:35:03,680 --> 00:35:05,756
And we get to see the results here 4.0.

675
00:35:05,756 --> 00:35:09,200
Run power of 2 on 3.2 and we
get to see our result, 10.24.

676
00:35:09,200 --> 00:35:10,840
So far so good, right?

677
00:35:10,840 --> 00:35:12,070
Now we're thinking, well, OK.

678
00:35:12,070 --> 00:35:15,530
Now I actually need to
do a lot of powers of 3.

679
00:35:15,530 --> 00:35:19,180
So I'll copy paste all of this code,
change the name of the function from

680
00:35:19,180 --> 00:35:24,440
power of 2 to power of 3, and everything
will be the same except for this value

681
00:35:24,440 --> 00:35:26,740
here, this range, 1...2.

682
00:35:26,740 --> 00:35:29,590
>> So rather than repeating
this loop twice,

683
00:35:29,590 --> 00:35:31,880
I want to repeat this loop three times.

684
00:35:31,880 --> 00:35:36,330
So I just change that value from
1 to 3-- or rather from 2 to 3.

685
00:35:36,330 --> 00:35:39,230
So again, the same code,
that's the only change.

686
00:35:39,230 --> 00:35:40,080
Now this also works.

687
00:35:40,080 --> 00:35:43,860
Power of 3 provided in some value of 2.

688
00:35:43,860 --> 00:35:44,420
We get 8.

689
00:35:44,420 --> 00:35:45,370
So 2 cubed.

690
00:35:45,370 --> 00:35:48,060
And 3.2 cubed is 32.768.

691
00:35:48,060 --> 00:35:50,597
And so far so good, right?

692
00:35:50,597 --> 00:35:52,930
But hopefully this is a little
bit of a red flag for you

693
00:35:52,930 --> 00:35:55,530
in that we now have
some duplication of code

694
00:35:55,530 --> 00:35:58,800
except for some very minor
change from one to the next.

695
00:35:58,800 --> 00:36:02,170
So is there some way that
we might be able to simplify

696
00:36:02,170 --> 00:36:06,080
this problem, where we can actually,
at run time, figure out some,

697
00:36:06,080 --> 00:36:11,320
provide to us some function that has
precisely the power of that we want.

698
00:36:11,320 --> 00:36:13,960
>> And there's this idea of
closures, which is really, really

699
00:36:13,960 --> 00:36:18,180
important in the context of Swift,
and in many other languages as well.

700
00:36:18,180 --> 00:36:21,580
But probably you will see
it used more so in Swift

701
00:36:21,580 --> 00:36:23,650
because it's embedded
within the language

702
00:36:23,650 --> 00:36:28,280
than you will in other
also modern languages.

703
00:36:28,280 --> 00:36:31,140
So the idea of a closure
is this, is that we

704
00:36:31,140 --> 00:36:35,430
can have a function that is meant to
be a generic function, a generic power

705
00:36:35,430 --> 00:36:36,860
of function.

706
00:36:36,860 --> 00:36:41,010
>> And this function is going to accept
this exponent that we actually

707
00:36:41,010 --> 00:36:42,990
want to create.

708
00:36:42,990 --> 00:36:46,550
So for example, the very first
instance, we wanted a power of 2.

709
00:36:46,550 --> 00:36:50,050
So we would provide power of
and then in parentheses 2.

710
00:36:50,050 --> 00:36:52,490
And now notice what
this actually returns.

711
00:36:52,490 --> 00:36:57,680
This takes an input of a primer
called y that is an integer,

712
00:36:57,680 --> 00:37:03,090
and it returns this crazy looking
thing in parentheses-- parentheses

713
00:37:03,090 --> 00:37:06,230
double and then arrow double.

714
00:37:06,230 --> 00:37:10,270
>> What this means is that I'm
going to return a function.

715
00:37:10,270 --> 00:37:13,510
I'm not returning
another type of data, I'm

716
00:37:13,510 --> 00:37:16,350
in fact returning a function
that has this parameter, that

717
00:37:16,350 --> 00:37:22,680
accepts a double as input and
outputs a double as a return value.

718
00:37:22,680 --> 00:37:29,750
And as a result, because now I've called
power of, passing in some value for y,

719
00:37:29,750 --> 00:37:32,280
and I'm creating this other
function-- notice that there's

720
00:37:32,280 --> 00:37:35,980
another function that's being created
inside of this-- what I am doing

721
00:37:35,980 --> 00:37:37,830
is I can then change
that value, that one

722
00:37:37,830 --> 00:37:41,010
value that I had changed
from 2 to 3, I now make it y.

723
00:37:41,010 --> 00:37:42,500
>> And this persists.

724
00:37:42,500 --> 00:37:48,530
So every time that I call power
of, essentially what happens

725
00:37:48,530 --> 00:37:51,030
is that I get returned a function.

726
00:37:51,030 --> 00:37:54,310
Notice that here I've defined
a new variable called square.

727
00:37:54,310 --> 00:37:59,340
I've set it equal to power of,
provided this value 2 to power of.

728
00:37:59,340 --> 00:38:02,030
And what this returned is the function.

729
00:38:02,030 --> 00:38:05,970
So square, the variable
square, is now of type function

730
00:38:05,970 --> 00:38:11,390
that has this-- oops, scroll up a
little bit-- that has this signature,

731
00:38:11,390 --> 00:38:15,560
accept a double and output a double.

732
00:38:15,560 --> 00:38:17,330
>> So now what I've done
is I've essentially

733
00:38:17,330 --> 00:38:22,890
created a function called square that
accepts any value and will square it.

734
00:38:22,890 --> 00:38:24,960
We can see what happens down here.

735
00:38:24,960 --> 00:38:29,960
Square 3 for example, means I'm going
to take the value 3 and squared it.

736
00:38:29,960 --> 00:38:32,010
So how exactly does this work?

737
00:38:32,010 --> 00:38:37,800
When I pass power of 2-- when I
pass 2 into this power of function,

738
00:38:37,800 --> 00:38:44,430
this variable y is
populated with that value 2.

739
00:38:44,430 --> 00:38:46,340
And that is sort of held in memory.

740
00:38:46,340 --> 00:38:49,430
That's sort of like held in
state somewhere in the computer,

741
00:38:49,430 --> 00:38:51,980
we don't really care how
or where at this point.

742
00:38:51,980 --> 00:38:54,692
>> But I return this function
called exponentiate.

743
00:38:54,692 --> 00:38:57,400
And again, it doesn't really matter
what this function is called,

744
00:38:57,400 --> 00:39:01,730
we can really call it anything, that
accepts a double and returns a double,

745
00:39:01,730 --> 00:39:05,640
but uses this value y inside of it.

746
00:39:05,640 --> 00:39:09,290
So even though it's this function,
this exponentiater function that's

747
00:39:09,290 --> 00:39:13,600
been returned back to my
variable that I called square,

748
00:39:13,600 --> 00:39:17,980
it has contained within it
this notion of what y was.

749
00:39:17,980 --> 00:39:19,070
And it remembers that.

750
00:39:19,070 --> 00:39:24,810
>> So every time I call that function that
is now called square, it uses that.

751
00:39:24,810 --> 00:39:27,990
But this also means that I can
create another variable using

752
00:39:27,990 --> 00:39:29,120
a different power of.

753
00:39:29,120 --> 00:39:33,240
So I can create a cube variable, for
example, provide to it power of 3.

754
00:39:33,240 --> 00:39:37,230
Now cube will actually take some
value and cube that and return it.

755
00:39:37,230 --> 00:39:39,570
So we can see that I get
a value 8 out of that.

756
00:39:39,570 --> 00:39:42,720
>> But that value y hasn't
changed because they're

757
00:39:42,720 --> 00:39:44,980
held in sort of independent variables.

758
00:39:44,980 --> 00:39:47,480
They are sort of held in
independent spaces in memory.

759
00:39:47,480 --> 00:39:51,290
So cube will always have
x to the power of 3.

760
00:39:51,290 --> 00:39:55,380
And square will always have
x to the power of 2, which

761
00:39:55,380 --> 00:39:58,470
means that square will always
square numbers, as I expect.

762
00:39:58,470 --> 00:40:01,794
And cube will always cubed
numbers, as I expect.

763
00:40:01,794 --> 00:40:04,960
This also means that sometimes you can
get some sort of funky looking syntax

764
00:40:04,960 --> 00:40:09,030
where you have power of at the very
bottom of the screen here, power of 5.

765
00:40:09,030 --> 00:40:11,410
And you pass into the result.

766
00:40:11,410 --> 00:40:14,670
You call that function that's
been returned with the number 4.

767
00:40:14,670 --> 00:40:17,440
And so what essentially this
is 4 to the fifth power,

768
00:40:17,440 --> 00:40:20,830
we can see the results there.

769
00:40:20,830 --> 00:40:23,690
With me so far?

770
00:40:23,690 --> 00:40:26,620
>> So this idea is called a closure,
because what we're basically doing

771
00:40:26,620 --> 00:40:30,610
is we're encapsulating
some data into-- sort

772
00:40:30,610 --> 00:40:33,050
of enclosing this data
into a function and we're

773
00:40:33,050 --> 00:40:36,240
being able to reuse this function.

774
00:40:36,240 --> 00:40:41,480
Now this syntax though can actually
be simplified a great amount.

775
00:40:41,480 --> 00:40:45,005
And there's lots of possibility
in Swift for this simplification.

776
00:40:45,005 --> 00:40:47,780
And that's what sort of the
subsequent ones actually look at.

777
00:40:47,780 --> 00:40:51,400
So in 7b for example, we
take this exact same code.

778
00:40:51,400 --> 00:40:54,360
>> But now rather than
actually define a function

779
00:40:54,360 --> 00:40:57,910
inside of this power of
function and give it a name,

780
00:40:57,910 --> 00:41:00,150
and then return the name
of that function, which

781
00:41:00,150 --> 00:41:02,357
then is used as part of
this closure, instead we're

782
00:41:02,357 --> 00:41:03,440
just going to simplify it.

783
00:41:03,440 --> 00:41:06,580
We don't need this function to be named.

784
00:41:06,580 --> 00:41:09,760
So this is the concept of an
anonymous function where we can then

785
00:41:09,760 --> 00:41:15,180
accept as input, in parentheses here,
the variable x which is of type double.

786
00:41:15,180 --> 00:41:17,250
>> We're going to return the type double.

787
00:41:17,250 --> 00:41:19,830
And then the keyword, n, is
the beginning of this function.

788
00:41:19,830 --> 00:41:22,180
So notice that all of this
is within curly brackets

789
00:41:22,180 --> 00:41:25,310
and we're defining an
anonymous function here.

790
00:41:25,310 --> 00:41:29,910
Just a simpler way of
defining the exact same thing.

791
00:41:29,910 --> 00:41:30,810
OK?

792
00:41:30,810 --> 00:41:36,740
But hold on, Swift actually allows us
to go further and simplify even more,

793
00:41:36,740 --> 00:41:40,180
because really we don't
care that this parameter is

794
00:41:40,180 --> 00:41:41,700
named any particular thing.

795
00:41:41,700 --> 00:41:48,090
It can really be called anything and
we can still use that first parameter.

796
00:41:48,090 --> 00:41:53,800
>> So in fact there is this special
type of data in anonymous functions,

797
00:41:53,800 --> 00:41:57,710
there's this special name of
variables in anonymous functions

798
00:41:57,710 --> 00:42:00,280
that start with the
dollar sign and represent

799
00:42:00,280 --> 00:42:03,785
the parameter numbers, zero
indexed, for this function.

800
00:42:03,785 --> 00:42:05,410
So there's a couple of things going on.

801
00:42:05,410 --> 00:42:08,550
Here I'm going to return, and then a
curly brace representing a function,

802
00:42:08,550 --> 00:42:09,050
right?

803
00:42:09,050 --> 00:42:13,920
>> Notice that I don't have defined the
parameter types or the return type.

804
00:42:13,920 --> 00:42:16,460
It can actually be inferred
because of the signature

805
00:42:16,460 --> 00:42:18,360
of this original function.

806
00:42:18,360 --> 00:42:20,500
So we can eliminate
that as a possibility.

807
00:42:20,500 --> 00:42:25,120
But also I can use dollar sign zero to
represent this first parameter that's

808
00:42:25,120 --> 00:42:28,200
passed into this anonymous function.

809
00:42:28,200 --> 00:42:31,630
So simplifying it even more.

810
00:42:31,630 --> 00:42:32,750
OK?

811
00:42:32,750 --> 00:42:33,820
So far, so good?

812
00:42:33,820 --> 00:42:36,980
>> Now it's this type-- do you
remember this dollar sign zero

813
00:42:36,980 --> 00:42:40,130
that we saw in this curly brace
that we saw just a little while

814
00:42:40,130 --> 00:42:43,870
ago in this Swift six example?

815
00:42:43,870 --> 00:42:46,560
It was right here.

816
00:42:46,560 --> 00:42:48,430
Notice that's exactly
what we're looking at,

817
00:42:48,430 --> 00:42:51,580
is that we have passed
into this split function

818
00:42:51,580 --> 00:42:55,140
an anonymous function that
checks the first parameter

819
00:42:55,140 --> 00:42:57,830
to see if it equals the colon symbol.

820
00:42:57,830 --> 00:42:59,830
And that's exactly what's
happening, is that all

821
00:42:59,830 --> 00:43:02,320
we're doing-- the return
keyword is implied

822
00:43:02,320 --> 00:43:05,800
in this case-- we're returning
this value where we're comparing

823
00:43:05,800 --> 00:43:10,020
the first parameter against
this character colon.

824
00:43:10,020 --> 00:43:11,730
And so that sort of demystifies this.

825
00:43:11,730 --> 00:43:17,210
And you're going to see this construct
a lot in Swift syntax, so do keep that

826
00:43:17,210 --> 00:43:19,400
in mind when you're
taking a look at this.

827
00:43:19,400 --> 00:43:21,970
Now we can get off
the rails a little bit

828
00:43:21,970 --> 00:43:25,460
and go really fancy that shows
even some more of Swift's power.

829
00:43:25,460 --> 00:43:27,950
You might even see some
of these in sample codes.

830
00:43:27,950 --> 00:43:29,790
So that's why I'm going
to show this to you.

831
00:43:29,790 --> 00:43:37,260
>> Basically what we can do is that, first
of all, it was kind of needless for me

832
00:43:37,260 --> 00:43:41,710
to implement all of that power of
code because if you import the Darwin

833
00:43:41,710 --> 00:43:46,490
library, it actually includes a function
called pow that does this for you.

834
00:43:46,490 --> 00:43:50,570
So we can simplify it even more and
have our power up function now just

835
00:43:50,570 --> 00:43:54,890
be a wonderful one liner where we just
return this anonymous function that

836
00:43:54,890 --> 00:44:00,780
accepts dollar sign 0 as its
base and y as its exponent.

837
00:44:00,780 --> 00:44:02,582
>> But we can get really,
really fancy when we

838
00:44:02,582 --> 00:44:04,790
realize that Swift has a
lot of power under the hood.

839
00:44:04,790 --> 00:44:07,010
A lot of the operators that
we've been dealing with,

840
00:44:07,010 --> 00:44:11,270
plus signs and division symbols and
all these things that you normally

841
00:44:11,270 --> 00:44:15,620
operate with with data types
in a programming language,

842
00:44:15,620 --> 00:44:17,600
are actually extensible in Swift.

843
00:44:17,600 --> 00:44:21,460
So what that means in that we
can define our own operators.

844
00:44:21,460 --> 00:44:26,020
>> So now I am tired of typing in all this
pow and then a parentheses and then

845
00:44:26,020 --> 00:44:26,520
the base.

846
00:44:26,520 --> 00:44:27,520
I don't want to do that.

847
00:44:27,520 --> 00:44:30,190
I actually want to have an
operator that allows me to do that.

848
00:44:30,190 --> 00:44:34,510
So I can tell Swift that I want
to create an operator, star

849
00:44:34,510 --> 00:44:39,472
star-- by the way I can't use the carat
because the carat is an operator that

850
00:44:39,472 --> 00:44:40,680
does something else entirely.

851
00:44:40,680 --> 00:44:42,720
So I don't want to sort
of collide with that.

852
00:44:42,720 --> 00:44:45,750
And so what you see in a variety
of languages, including Python,

853
00:44:45,750 --> 00:44:48,810
is like star star operator
to represent exponents.

854
00:44:48,810 --> 00:44:50,730
>> So that's the only reason
why I've done that.

855
00:44:50,730 --> 00:44:53,067
And it's going to be
an infix type operator.

856
00:44:53,067 --> 00:44:54,900
And I have to provide
to it some information

857
00:44:54,900 --> 00:44:58,386
about the precedence of this
operator so it's left associative.

858
00:44:58,386 --> 00:45:00,260
It's like relatively
high precedence compared

859
00:45:00,260 --> 00:45:02,432
to summation or multiplication.

860
00:45:02,432 --> 00:45:04,140
It's higher precedence
than all of those.

861
00:45:04,140 --> 00:45:04,931
So on and so forth.

862
00:45:04,931 --> 00:45:07,410
And then I define the
function that actually

863
00:45:07,410 --> 00:45:10,070
dictates what this operator does.

864
00:45:10,070 --> 00:45:14,150
So assuming that I have a left
hand side and right hand side,

865
00:45:14,150 --> 00:45:17,330
which would be perhaps a
better variable name for this.

866
00:45:17,330 --> 00:45:20,690
Left hand side and right hand side.

867
00:45:20,690 --> 00:45:26,740
I can then take this power of the
left hand side to the right hand side

868
00:45:26,740 --> 00:45:28,980
and return that value.

869
00:45:28,980 --> 00:45:30,370
So now it's super sweet.

870
00:45:30,370 --> 00:45:33,790
All we have to do is 2 star star 3
and that is 2 to the third power,

871
00:45:33,790 --> 00:45:35,290
and we get a value of 8.

872
00:45:35,290 --> 00:45:40,280
2 star star 10 is 2 to the
10th power, we get 1,024.

873
00:45:40,280 --> 00:45:43,630
>> So now our power of function,
which again is different,

874
00:45:43,630 --> 00:45:47,030
because the whole idea behind this
was that we have one function that

875
00:45:47,030 --> 00:45:50,700
always takes some value and
multiplies it-- or rather

876
00:45:50,700 --> 00:45:53,240
takes the exponent to the same power.

877
00:45:53,240 --> 00:45:54,300
So now it's even simpler.

878
00:45:54,300 --> 00:45:57,070
So now it's just dollar
sign 0 star star y.

879
00:45:57,070 --> 00:46:01,190
We don't even have to use pow anymore.

880
00:46:01,190 --> 00:46:03,020
>> OK, who's lost?

881
00:46:03,020 --> 00:46:03,700
Are we doing OK?

882
00:46:03,700 --> 00:46:05,090
Any questions on this stuff?

883
00:46:05,090 --> 00:46:05,815
Yeah?

884
00:46:05,815 --> 00:46:09,500
>> AUDIENCE: When you-- [INAUDIBLE]
the funk power of y double.

885
00:46:09,500 --> 00:46:11,441
So when you're returning a function.

886
00:46:11,441 --> 00:46:13,190
DANIEL ARMENDARIZ:
Funk power of y double.

887
00:46:13,190 --> 00:46:14,270
Oh yeah, I don't know
what the y numbers are.

888
00:46:14,270 --> 00:46:15,708
Sorry about that.

889
00:46:15,708 --> 00:46:19,420
>> AUDIENCE: Why are you returning
a function [INAUDIBLE] enclosure.

890
00:46:19,420 --> 00:46:24,214
Isn't dollar zero star
star y [INAUDIBLE]

891
00:46:24,214 --> 00:46:29,710
find that operator with that
returning double [INAUDIBLE] double?

892
00:46:29,710 --> 00:46:32,742
>> DANIEL ARMENDARIZ: So let
me answer your question

893
00:46:32,742 --> 00:46:35,950
how I understand it and you can tell me
if I didn't understand your question.

894
00:46:35,950 --> 00:46:42,850
So this construct, the curly brace
dollar sign zero star star y,

895
00:46:42,850 --> 00:46:44,280
is a function.

896
00:46:44,280 --> 00:46:50,080
And it accepts a parameter that is
represented by this dollar sign zero.

897
00:46:50,080 --> 00:46:55,830
The return keyword is implied in this
very short, anonymous function syntax.

898
00:46:55,830 --> 00:46:57,870
>> Which means that essentially
what this is saying

899
00:46:57,870 --> 00:47:01,270
is that I'm defining a
function-- and then I'll

900
00:47:01,270 --> 00:47:05,320
just call it something--
where I have some value y.

901
00:47:05,320 --> 00:47:08,300
I have y, which is double.

902
00:47:08,300 --> 00:47:10,750
And I'm returning a double.

903
00:47:10,750 --> 00:47:19,010
And I have within that return y-- sorry,
I shouldn't have called this y-- x.

904
00:47:19,010 --> 00:47:20,240
Oh dear, oh dear, oh dear.

905
00:47:20,240 --> 00:47:27,440
X-- nope-- star star y.

906
00:47:27,440 --> 00:47:29,720
>> So this is just a
simplified version of this.

907
00:47:29,720 --> 00:47:33,990
And so the reason that I have dollar
sign zero is that using this enclosure

908
00:47:33,990 --> 00:47:41,050
means that I no longer have
to type pow, or no longer do

909
00:47:41,050 --> 00:47:45,570
I have to do something
like 3 star star 2.

910
00:47:45,570 --> 00:47:48,530
I can just have a single
function called square

911
00:47:48,530 --> 00:47:50,820
that will always take
some value as input

912
00:47:50,820 --> 00:47:52,980
and actually return the square of that.

913
00:47:52,980 --> 00:47:56,460
>> So the whole purpose of the closure is
to just sort of encapsulate the fact

914
00:47:56,460 --> 00:47:59,920
that I always want to use y whenever
I call that function as the power

915
00:47:59,920 --> 00:48:01,710
when taking this exponent.

916
00:48:01,710 --> 00:48:04,650
So returning then, a
function that accepts

917
00:48:04,650 --> 00:48:08,460
a double, which is the base, and
returning the result of that exponent

918
00:48:08,460 --> 00:48:10,740
is the key here.

919
00:48:10,740 --> 00:48:12,790
And that's the major distinction.

920
00:48:12,790 --> 00:48:14,430
There was just a bit of a flourish.

921
00:48:14,430 --> 00:48:17,970
>> This is not any different
compared to the prior examples,

922
00:48:17,970 --> 00:48:20,530
but it was just a bit of
a flourish we can actually

923
00:48:20,530 --> 00:48:24,500
create an operator in Swift
and actually do stuff with it,

924
00:48:24,500 --> 00:48:26,396
which is kind of a cool thing.

925
00:48:26,396 --> 00:48:27,520
Did I answer your question?

926
00:48:27,520 --> 00:48:28,390
Sweet.

927
00:48:28,390 --> 00:48:31,350
Anything else before we move on?

928
00:48:31,350 --> 00:48:33,570
OK.

929
00:48:33,570 --> 00:48:36,430
>> Now this sort of begs the
question is that-- well OK,

930
00:48:36,430 --> 00:48:40,870
now we have the ability for
functions to be returned.

931
00:48:40,870 --> 00:48:48,950
Can we also pass functions as data
or as parameters to other functions?

932
00:48:48,950 --> 00:48:50,710
And in fact we can.

933
00:48:50,710 --> 00:48:53,480
So let's say that we have
all of the same code.

934
00:48:53,480 --> 00:48:56,120
We have the square variable
that will square this code.

935
00:48:56,120 --> 00:48:59,320
And we have the cube variable
that will cube some data.

936
00:48:59,320 --> 00:49:02,440
And we actually want to apply
to a wide range of numbers.

937
00:49:02,440 --> 00:49:06,870
>> So what we might be tempted to do,
of course, which is certainly valid,

938
00:49:06,870 --> 00:49:15,430
is to iterate over this list of numbers
and apply my functions square and cube

939
00:49:15,430 --> 00:49:22,270
and get two new lists as results
that are this original list squared

940
00:49:22,270 --> 00:49:24,970
and cubed, respectively.

941
00:49:24,970 --> 00:49:26,880
Perfectly acceptable.

942
00:49:26,880 --> 00:49:29,130
But what's the thing that
we see here is that we have,

943
00:49:29,130 --> 00:49:31,310
again, duplication of our code.

944
00:49:31,310 --> 00:49:34,310
And there's perhaps an opportunity
for us to simplify this a little bit.

945
00:49:34,310 --> 00:49:41,260
What if there was a way for us to
actually always iterate over some list

946
00:49:41,260 --> 00:49:45,450
and just pass to this magical
function a variable that

947
00:49:45,450 --> 00:49:47,350
represents a function
that we want to apply

948
00:49:47,350 --> 00:49:50,336
to every single item in this list.

949
00:49:50,336 --> 00:49:53,210
This brings up the concept of what
are called higher order functions.

950
00:49:53,210 --> 00:49:57,150
And that is essentially what this
is, is that we can create a function.

951
00:49:57,150 --> 00:50:00,210
>> And in this case it's called a
mapper, just to give it a name, just

952
00:50:00,210 --> 00:50:02,510
mapping over every
single item in a list.

953
00:50:02,510 --> 00:50:06,191
Where I take a list
and I take a function.

954
00:50:06,191 --> 00:50:08,440
And that function, of course,
has a certain signature.

955
00:50:08,440 --> 00:50:11,980
It accepts as a parameter double
and it will output is a double.

956
00:50:11,980 --> 00:50:14,310
And the whole result of
this function is going

957
00:50:14,310 --> 00:50:18,921
to be a new list that is of type double.

958
00:50:18,921 --> 00:50:19,420
OK?

959
00:50:19,420 --> 00:50:22,650
>> And what I'm going to do
is to apply this function f

960
00:50:22,650 --> 00:50:24,960
to every element in my list.

961
00:50:24,960 --> 00:50:30,280
And reply-- and rather return this new
list as a result, which is really cool.

962
00:50:30,280 --> 00:50:31,820
Now I can pass functions around.

963
00:50:31,820 --> 00:50:35,290
And this idea of higher order
functions is really important.

964
00:50:35,290 --> 00:50:39,260
And this mapper is really just
the poor man's implementation

965
00:50:39,260 --> 00:50:43,130
of a function that is built
into Swift called map.

966
00:50:43,130 --> 00:50:45,690
And it does precisely this,
perhaps even a little bit better.

967
00:50:45,690 --> 00:50:48,260
>> This is just sort of a generic,
simplified version that

968
00:50:48,260 --> 00:50:51,270
allows us to see the
concept that applies here.

969
00:50:51,270 --> 00:50:54,630
Now look at the way that I
can actually apply my square

970
00:50:54,630 --> 00:50:57,850
and my cube functions
to this list of numbers.

971
00:50:57,850 --> 00:50:58,780
I run my mapper.

972
00:50:58,780 --> 00:51:00,280
I provide to it my list of numbers.

973
00:51:00,280 --> 00:51:02,155
I provide to it the the
function that's going

974
00:51:02,155 --> 00:51:04,170
to apply to each of those indices.

975
00:51:04,170 --> 00:51:07,120
And it is going to be
output as a result.

976
00:51:07,120 --> 00:51:11,810
And I will get to see that I've squared
and cubed my numbers as a result.

977
00:51:11,810 --> 00:51:14,660
>> And of course the mapper will take
any sort of anonymous function.

978
00:51:14,660 --> 00:51:17,640
We can even see that I've created
a new anonymous function that

979
00:51:17,640 --> 00:51:20,220
just takes some parameter
and divides it by 2.

980
00:51:20,220 --> 00:51:24,340
And we can see that I've, in fact,
divided my list by 2 instead.

981
00:51:24,340 --> 00:51:25,250
Cool?

982
00:51:25,250 --> 00:51:27,340
So far, so good?

983
00:51:27,340 --> 00:51:29,650
All right, now let's
come back to this idea.

984
00:51:29,650 --> 00:51:36,160
Let's implement this back in
the context of a gradebook.

985
00:51:36,160 --> 00:51:41,860
>> And if I do that, we can see that I can
apply a wide variety of these options--

986
00:51:41,860 --> 00:51:44,330
or a wide variety of these
higher order functions

987
00:51:44,330 --> 00:51:51,450
to actually simplify my ability to do a
variety of things on lists of numbers.

988
00:51:51,450 --> 00:51:53,660
So for example, if I
take a list of numbers,

989
00:51:53,660 --> 00:51:57,060
one of the higher order functions
that exists is called reduce.

990
00:51:57,060 --> 00:52:00,080
What reduce does rather
than map, is reduced will

991
00:52:00,080 --> 00:52:03,710
take two elements in the list,
will take some function that

992
00:52:03,710 --> 00:52:07,420
compares the two elements of
the list, and it will then

993
00:52:07,420 --> 00:52:09,610
sort of output-- the
output of that function

994
00:52:09,610 --> 00:52:13,790
will be another element that
you then compare to others.

995
00:52:13,790 --> 00:52:18,190
>> So you could use this to actually
sum of the numbers in your list.

996
00:52:18,190 --> 00:52:20,640
For example, if you had
a list of 1, 2, 3, 4, 5,

997
00:52:20,640 --> 00:52:22,940
you take the first elements, 1 and 2.

998
00:52:22,940 --> 00:52:27,270
You can apply to it an addition
function that takes those two elements

999
00:52:27,270 --> 00:52:30,980
and spits out one of those elements,
which would be the value 3.

1000
00:52:30,980 --> 00:52:35,684
Then we take that value 3 with the next
element of the list, sum those two,

1001
00:52:35,684 --> 00:52:37,100
and then keep going down the list.

1002
00:52:37,100 --> 00:52:40,410
>> We're reducing the
list to a single value.

1003
00:52:40,410 --> 00:52:42,700
And it just so happens
that the plus symbol

1004
00:52:42,700 --> 00:52:44,670
is an operator, just like we just saw.

1005
00:52:44,670 --> 00:52:47,500
This operator is
actually a function that

1006
00:52:47,500 --> 00:52:53,100
has precisely this list that we
would want, rather these properties

1007
00:52:53,100 --> 00:52:54,770
that we would want.

1008
00:52:54,770 --> 00:52:56,760
So I encourage you to
take a look at this.

1009
00:52:56,760 --> 00:52:59,290
I want to sort of move
on from some of this code

1010
00:52:59,290 --> 00:53:05,330
so that we can actually look at some
actual, real, true Swift in Xcode,

1011
00:53:05,330 --> 00:53:06,880
in iOS development.

1012
00:53:06,880 --> 00:53:08,630
But take a look at
this and see if you can

1013
00:53:08,630 --> 00:53:11,171
parse through what's going on
with some of these higher order

1014
00:53:11,171 --> 00:53:13,790
functions including filter,
reduce, and you'll even

1015
00:53:13,790 --> 00:53:17,060
see somewhere in here map as well.

1016
00:53:17,060 --> 00:53:17,910
It's right here.

1017
00:53:17,910 --> 00:53:20,410
Where it will take a sequence
of grades and it will actually

1018
00:53:20,410 --> 00:53:24,230
map them using the switch construct,
which you might recognize from C,

1019
00:53:24,230 --> 00:53:27,640
but actually it is a lot more
powerful than the switch construct

1020
00:53:27,640 --> 00:53:29,810
that we have in C.

1021
00:53:29,810 --> 00:53:31,930
>> And we'll apply that to
every element in the list

1022
00:53:31,930 --> 00:53:34,540
and actually provide
the letter grade of each

1023
00:53:34,540 --> 00:53:40,780
of those grades using all these concepts
that we've just talked about before.

1024
00:53:40,780 --> 00:53:44,760
Now let's sidestep for just a
minute and talk about structs.

1025
00:53:44,760 --> 00:53:49,680
And so structs are a wait in C that we
were able to define a new type of data.

1026
00:53:49,680 --> 00:53:53,590
Structs exist within Swift.

1027
00:53:53,590 --> 00:53:58,980
And so do a lot of other constructs
called enums and classes, that really

1028
00:53:58,980 --> 00:54:01,175
take this idea to a
whole different level.

1029
00:54:01,175 --> 00:54:05,300
>> And basically it's just a way
of defining a new type of data.

1030
00:54:05,300 --> 00:54:11,010
So if you get-- if you come
across class or structs or enums,

1031
00:54:11,010 --> 00:54:13,290
don't get confused by it.

1032
00:54:13,290 --> 00:54:16,280
It's just the way of defining
some new particular type of data.

1033
00:54:16,280 --> 00:54:20,230
And this is really important when
we're talking about iOS app development

1034
00:54:20,230 --> 00:54:24,630
because everything that
exists within the iOS app

1035
00:54:24,630 --> 00:54:27,460
is essentially an object of some kind.

1036
00:54:27,460 --> 00:54:31,980
And an object is basically a
class or an enum or a struct.

1037
00:54:31,980 --> 00:54:34,760
>> So in this case I'm
defining a new type of data

1038
00:54:34,760 --> 00:54:37,740
that I'm calling assessment
that's some properties, including

1039
00:54:37,740 --> 00:54:41,040
a name and a sequence of grades.

1040
00:54:41,040 --> 00:54:43,470
So one type of assessment
that I might have in mind

1041
00:54:43,470 --> 00:54:44,760
would be quizzes, for example.

1042
00:54:44,760 --> 00:54:48,180
I would want to have an
assessment that was a quiz

1043
00:54:48,180 --> 00:54:51,460
and that had a variety of grades
associated with that, for quiz one,

1044
00:54:51,460 --> 00:54:52,840
quiz two, so on and so forth.

1045
00:54:52,840 --> 00:54:55,720
>> Or I might have a different type
of assessment for problem sets.

1046
00:54:55,720 --> 00:54:56,650
And I can do things.

1047
00:54:56,650 --> 00:54:59,860
I can actually have
functions within this type

1048
00:54:59,860 --> 00:55:02,645
of data, which are now called methods.

1049
00:55:02,645 --> 00:55:04,520
So if you ever see the
word method, it really

1050
00:55:04,520 --> 00:55:08,190
is just a function that applies
to a very specific class,

1051
00:55:08,190 --> 00:55:10,100
or to a very specific type of data.

1052
00:55:10,100 --> 00:55:12,350
It allows us to modify the data within.

1053
00:55:12,350 --> 00:55:15,510
>> So in other words, if I want to
add a grade to my assessment,

1054
00:55:15,510 --> 00:55:18,630
then all I need to do is to
append the score that was input

1055
00:55:18,630 --> 00:55:22,660
to this function to
my internal property.

1056
00:55:22,660 --> 00:55:25,880
There's another neat construct here
in Swift, which is this dot dot dot

1057
00:55:25,880 --> 00:55:31,780
operator, which means that scores can
now accept any number of integers.

1058
00:55:31,780 --> 00:55:33,940
And scores will be an
array of integers that

1059
00:55:33,940 --> 00:55:39,030
have been passed to my function, which
means that I can do stuff like this.

1060
00:55:39,030 --> 00:55:42,360
>> I can do add grades and just provide
arbitrary numbers of integers into it

1061
00:55:42,360 --> 00:55:47,420
and actually be provided an array
of those values in my function

1062
00:55:47,420 --> 00:55:50,270
or in my method, as is the case.

1063
00:55:50,270 --> 00:55:54,040
Now this is important because
everything in Xcode, everything in iOS,

1064
00:55:54,040 --> 00:55:56,250
is in fact an object.

1065
00:55:56,250 --> 00:55:59,630
So keep that in mind
when we bust open Xcode

1066
00:55:59,630 --> 00:56:04,890
and skip ahead beyond iOS
versions two and three

1067
00:56:04,890 --> 00:56:08,820
and actually go on to version four.

1068
00:56:08,820 --> 00:56:11,940
>> And again, all of this will
be posted on the seminar page.

1069
00:56:11,940 --> 00:56:16,980
iOS four is sort of a full blown
implementation of a very basic app.

1070
00:56:16,980 --> 00:56:23,920
And what this app does is it
loads a UI, which looks like this.

1071
00:56:23,920 --> 00:56:28,680
Again, if we click on storyboard we can
see that this is what it looks like.

1072
00:56:28,680 --> 00:56:31,320
This is the UI.

1073
00:56:31,320 --> 00:56:33,676
It has a title at the very top.

1074
00:56:33,676 --> 00:56:34,800
I've called it web gallery.

1075
00:56:34,800 --> 00:56:38,400
>> In the middle there's an element
called the UI image view.

1076
00:56:38,400 --> 00:56:41,340
And at the bottom there's a
toolbar with a single button that

1077
00:56:41,340 --> 00:56:46,850
has stretchy spaces that allow it to
center in the middle of this toolbar.

1078
00:56:46,850 --> 00:56:51,780
And what happens is that when this
loads it downloads a JSON file that's

1079
00:56:51,780 --> 00:56:55,540
contained on a server elsewhere,
parses that JSON file,

1080
00:56:55,540 --> 00:56:58,130
and the JSON file looks a bit like this.

1081
00:56:58,130 --> 00:57:02,770

1082
00:57:02,770 --> 00:57:06,230
The JSON file looks like this.

1083
00:57:06,230 --> 00:57:08,650
There it is.

1084
00:57:08,650 --> 00:57:11,730
>> It has an album name and
it has an array of photos.

1085
00:57:11,730 --> 00:57:13,490
Each of those photos
have a name and also

1086
00:57:13,490 --> 00:57:19,460
a URL themselves that represent the
jpeg version of that individual photo.

1087
00:57:19,460 --> 00:57:24,780
So what happen is that when this program
loads, it downloads the JSON file,

1088
00:57:24,780 --> 00:57:30,590
parses it, puts all of this into
the equivalent of an array in iOS

1089
00:57:30,590 --> 00:57:33,020
app development, which is an nsarray.

1090
00:57:33,020 --> 00:57:37,520
And then I can then load
this data into an application

1091
00:57:37,520 --> 00:57:41,100
and load it on my screen.

1092
00:57:41,100 --> 00:57:44,760
>> There is an image that was loaded
with the button at the very bottom.

1093
00:57:44,760 --> 00:57:49,190
If I click Get Next Image, it then
pulls that image from the internet

1094
00:57:49,190 --> 00:57:53,370
and replaces that image
in the UI image view.

1095
00:57:53,370 --> 00:57:57,820
So you can download this and actually
take a look at it on your computer.

1096
00:57:57,820 --> 00:58:00,940
And build it and actually
compile it onto your device.

1097
00:58:00,940 --> 00:58:04,710
But essentially the process was
this, create the storyboard--

1098
00:58:04,710 --> 00:58:08,080
or rather not create--
but select the storyboard.

1099
00:58:08,080 --> 00:58:15,030
And actually we'll-- if you don't mind--
we'll take just a couple of seconds

1100
00:58:15,030 --> 00:58:18,390
to actually show you how this was done.

1101
00:58:18,390 --> 00:58:22,430

1102
00:58:22,430 --> 00:58:27,820
>> Just so that how we can actually
achieve this is made a little bit more

1103
00:58:27,820 --> 00:58:28,360
apparent.

1104
00:58:28,360 --> 00:58:30,651
Single view application, I'm
going to call this seminar

1105
00:58:30,651 --> 00:58:35,330
four representing this
particular number.

1106
00:58:35,330 --> 00:58:36,335
Save it on the desktop.

1107
00:58:36,335 --> 00:58:39,890

1108
00:58:39,890 --> 00:58:42,110
OK, going to click on the storyboard.

1109
00:58:42,110 --> 00:58:47,030
And what I'm going to do
is to find my image view,

1110
00:58:47,030 --> 00:58:50,940
drag it onto my user
interface and center it.

1111
00:58:50,940 --> 00:58:54,850
Now just centering it unfortunately
is not going to do a whole lot,

1112
00:58:54,850 --> 00:58:58,680
except for a screen
that is this exact size.

1113
00:58:58,680 --> 00:59:03,950
>> So we can convince ourselves of that by
clicking on this double circle thing,

1114
00:59:03,950 --> 00:59:08,290
bringing down this pop
up menu here and changing

1115
00:59:08,290 --> 00:59:11,110
to preview, where we'll actually
get a chance to preview how

1116
00:59:11,110 --> 00:59:13,530
this will actually
look on other devices.

1117
00:59:13,530 --> 00:59:16,500
As we can see, we don't even
see it on this particular case.

1118
00:59:16,500 --> 00:59:18,500
So I'm going to close this for now.

1119
00:59:18,500 --> 00:59:22,100
>> And I'm going to select
this icon down at the very

1120
00:59:22,100 --> 00:59:23,910
bottom portion of the screen.

1121
00:59:23,910 --> 00:59:26,584
It says Resolve Auto Layout Issues.

1122
00:59:26,584 --> 00:59:28,000
Sorry, it's cut off at the bottom.

1123
00:59:28,000 --> 00:59:36,360
But if I click on that, what I
get is this pop up-- go away.

1124
00:59:36,360 --> 00:59:39,740

1125
00:59:39,740 --> 00:59:51,220
What I get is this pop up that
allows me to add missing constraints.

1126
00:59:51,220 --> 00:59:53,780
And by doing that it
will then sort of lock it

1127
00:59:53,780 --> 00:59:56,640
into the center portion of the
screen like I might expect.

1128
00:59:56,640 --> 01:00:00,520
>> Now in order to get this button on
top of it, I need to go to the Editor.

1129
01:00:00,520 --> 01:00:05,010
Go to Embed In and click
Navigation Controller.

1130
01:00:05,010 --> 01:00:08,900
What that will do is that will add
this whole other component to it,

1131
01:00:08,900 --> 01:00:11,310
but it will actually link
it back to my original UI.

1132
01:00:11,310 --> 01:00:14,450
And the details, again, we don't
really need to care about right now.

1133
01:00:14,450 --> 01:00:16,710
But I do want to have a
toolbar at the very bottom.

1134
01:00:16,710 --> 01:00:18,530
So I'll check Shows Toolbar.

1135
01:00:18,530 --> 01:00:21,870
>> And this provides within my view,
which is now somewhere else,

1136
01:00:21,870 --> 01:00:23,900
we can see it's linked over here.

1137
01:00:23,900 --> 01:00:28,710
It now provides a toolbar
at the bottom of my UI.

1138
01:00:28,710 --> 01:00:34,770
So now, rather than selecting an
image view, I can find a label,

1139
01:00:34,770 --> 01:00:41,140
or rather a toolbar--
let's see, where is that?

1140
01:00:41,140 --> 01:00:41,890
What is it called?

1141
01:00:41,890 --> 01:00:49,760
A button-- item bar-- item--
sorry-- bar button item.

1142
01:00:49,760 --> 01:00:54,590
Plop that there and apply a couple
of flexible spaces on either side

1143
01:00:54,590 --> 01:00:57,429
to actually center that.

1144
01:00:57,429 --> 01:00:58,970
So now I've created my UI, basically.

1145
01:00:58,970 --> 01:01:01,428
And I can give it a name by
double clicking at the very top

1146
01:01:01,428 --> 01:01:04,880
here and saying web gallery and so on.

1147
01:01:04,880 --> 01:01:08,100
Now again, these are elements
that exist by themselves.

1148
01:01:08,100 --> 01:01:10,400
And I have to connect
them to my code which

1149
01:01:10,400 --> 01:01:14,297
I can do by again bringing
up this double circle icon,

1150
01:01:14,297 --> 01:01:15,380
changing from the preview.

1151
01:01:15,380 --> 01:01:18,950
Which, by the way, now we can see is
nicely centered and will look good

1152
01:01:18,950 --> 01:01:23,720
on a variety of devices.

1153
01:01:23,720 --> 01:01:27,280
>> Switch to automatic, which will
bring up the ViewController code.

1154
01:01:27,280 --> 01:01:29,030
And now this part is important.

1155
01:01:29,030 --> 01:01:34,590
In order for you to connect these
two elements, your code to the UI,

1156
01:01:34,590 --> 01:01:36,680
you select the item that
you want to connect.

1157
01:01:36,680 --> 01:01:39,570
So in this case, we
actually want to encode

1158
01:01:39,570 --> 01:01:43,520
change the image that's contained
within this UI image view.

1159
01:01:43,520 --> 01:01:47,070
So if you control click from
the image view and drag,

1160
01:01:47,070 --> 01:01:51,960
you'll notice that you get a little bar,
when you let go of everything this pop

1161
01:01:51,960 --> 01:01:53,550
up will occur.

1162
01:01:53,550 --> 01:01:56,470
>> And it says that we will
create a connection.

1163
01:01:56,470 --> 01:01:59,300
And from here I want to give it
a name, something like gallery.

1164
01:01:59,300 --> 01:02:00,240
Hit Enter.

1165
01:02:00,240 --> 01:02:03,040
And this actually provides
a variable called gallery

1166
01:02:03,040 --> 01:02:08,600
that I can then reference in my code
to change the image, for example.

1167
01:02:08,600 --> 01:02:10,430
So how does that code actually look?

1168
01:02:10,430 --> 01:02:13,030
Well again, I don't want to
spend too much time on it.

1169
01:02:13,030 --> 01:02:15,430
And I encourage you to
download it and take a look.

1170
01:02:15,430 --> 01:02:18,330
But one of the most
important aspect is the code

1171
01:02:18,330 --> 01:02:20,980
that actually fetches an image.

1172
01:02:20,980 --> 01:02:26,470
>> So in this case I want
to get within my photos

1173
01:02:26,470 --> 01:02:28,520
array, which is contained
within my class.

1174
01:02:28,520 --> 01:02:33,390
I want define the name and the URL
that's been parsed out of this JSON.

1175
01:02:33,390 --> 01:02:39,810
Actually ask the device to get the
URL, to fetch the URL from this,

1176
01:02:39,810 --> 01:02:44,060
and then fetch the data from
the contents of that URL.

1177
01:02:44,060 --> 01:02:49,430
Then convert that data into an image
by passing it into the UI image.

1178
01:02:49,430 --> 01:02:52,880
So again, these are all different types
of objects, different types of classes.

1179
01:02:52,880 --> 01:02:58,410
>> And then I can then set my
gallery.image equal to that data.

1180
01:02:58,410 --> 01:03:00,750
And that's sort of the meat
of it that actually is then

1181
01:03:00,750 --> 01:03:08,250
able to change the data from-- change
the picture from one to the next.

1182
01:03:08,250 --> 01:03:10,660
So again, hopefully now
a lot of the constructs

1183
01:03:10,660 --> 01:03:12,240
will make a little bit more sense.

1184
01:03:12,240 --> 01:03:15,260
Notice that there's some
exclamation points here.

1185
01:03:15,260 --> 01:03:19,810
The exclamation points are
essentially related to the optionals.

1186
01:03:19,810 --> 01:03:22,657
>> What I'm basically saying is
that without even checking

1187
01:03:22,657 --> 01:03:24,490
to see if there's data
within this optional,

1188
01:03:24,490 --> 01:03:27,140
I'm going to go ahead and assume
that there is and unwrap it.

1189
01:03:27,140 --> 01:03:31,340
Remember that we used the analogy of
sort of a package for the optionals

1190
01:03:31,340 --> 01:03:34,700
and we need to unwrap the
package and pull the data out.

1191
01:03:34,700 --> 01:03:37,570
The exclamation point
forces that actually happen.

1192
01:03:37,570 --> 01:03:39,590
>> But I know that this is
safe because I checked

1193
01:03:39,590 --> 01:03:42,070
to see if image data is equal
to nil, I've actually check

1194
01:03:42,070 --> 01:03:45,420
to see if that optional
was, in fact, failed.

1195
01:03:45,420 --> 01:03:47,110
If that had, in fact, failed already.

1196
01:03:47,110 --> 01:03:52,450
And so I'm sure that once I get to this
point I can safely unwrap that data.

1197
01:03:52,450 --> 01:03:55,710
You might also see it in
the form of a question mark.

1198
01:03:55,710 --> 01:03:59,100
So if we scroll down to where I
need to actually parse the data.

1199
01:03:59,100 --> 01:04:01,850
>> So don't be put off by
these sort of lengthy names.

1200
01:04:01,850 --> 01:04:06,580
You can find in the Apple
developer site a lot

1201
01:04:06,580 --> 01:04:09,620
of references to all of the
objects and all of the processes

1202
01:04:09,620 --> 01:04:11,170
that actually make this possible.

1203
01:04:11,170 --> 01:04:15,990
But notice that this is essentially
a function where I pass it some data.

1204
01:04:15,990 --> 01:04:18,410
And I get back some sort of data.

1205
01:04:18,410 --> 01:04:24,190
And I need to use this as keyword to
convert it into this nsdictionary?

1206
01:04:24,190 --> 01:04:26,490
Which is again, an
optional nsdictionary.

1207
01:04:26,490 --> 01:04:31,070
Which I then need to
check to see if it exists.

1208
01:04:31,070 --> 01:04:37,130
>> So I can use that if let
successful equals parsed,

1209
01:04:37,130 --> 01:04:40,620
then I know that that optional
actually contains some data.

1210
01:04:40,620 --> 01:04:43,840
Or what I did here was to
just assume that if there

1211
01:04:43,840 --> 01:04:49,067
were no errors that it is in fact safe.

1212
01:04:49,067 --> 01:04:51,400
All right, I want to thank
you all very much for coming.

1213
01:04:51,400 --> 01:04:53,540
I know this was a lot,
but it was only an hour

1214
01:04:53,540 --> 01:04:55,920
to talk about some
pretty advanced stuff.

1215
01:04:55,920 --> 01:04:59,640
And so hopefully you'll get a
chance to download all of the code

1216
01:04:59,640 --> 01:05:01,657
and take a better, more
thorough look at it.

1217
01:05:01,657 --> 01:05:04,240
Sort of convince yourself of all
of the stuff that's going on.

1218
01:05:04,240 --> 01:05:06,800
And I want to thank you
all, again, for coming.

1219
01:05:06,800 --> 01:05:08,760
And good luck with your final projects.

1220
01:05:08,760 --> 01:05:10,600
Have a great day.

1221
01:05:10,600 --> 01:05:11,467
