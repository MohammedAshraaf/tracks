1
00:00:00,000 --> 00:00:11,050

2
00:00:11,050 --> 00:00:13,351
>> ROB BOWDEN: This is the
more comfortable section,

3
00:00:13,351 --> 00:00:16,309
but that doesn't mean that if you
feel like you're not more comfortable

4
00:00:16,309 --> 00:00:18,420
you won't learn things here.

5
00:00:18,420 --> 00:00:20,600
So let's get started.

6
00:00:20,600 --> 00:00:22,819
Do you have slides
going right into things.

7
00:00:22,819 --> 00:00:24,360
Am I about to just take it right now?

8
00:00:24,360 --> 00:00:25,680

9
00:00:25,680 --> 00:00:26,450
Switching laptops.

10
00:00:26,450 --> 00:00:30,470

11
00:00:30,470 --> 00:00:32,950
>> ALLISON: You don't want to
introduce yourself, Rob?

12
00:00:32,950 --> 00:00:34,090
>> ROB BOWDEN: Oh, I'm Rob.

13
00:00:34,090 --> 00:00:35,182

14
00:00:35,182 --> 00:00:37,470
This is my fifth year TF-ing CS50.

15
00:00:37,470 --> 00:00:38,760

16
00:00:38,760 --> 00:00:39,650
>> GABRIEL: I'm Gabriel.

17
00:00:39,650 --> 00:00:41,610
I'm head TF of CS50.

18
00:00:41,610 --> 00:00:44,009
I was TF last year and this year.

19
00:00:44,009 --> 00:00:46,675
ALLISON: And I'm Alison, and this
is my second year TF-ing CS50.

20
00:00:46,675 --> 00:00:48,510

21
00:00:48,510 --> 00:00:50,825
>> ROB BOWDEN: All right, so
this thing on the left,

22
00:00:50,825 --> 00:00:52,250
hopefully you've seen it before.

23
00:00:52,250 --> 00:00:54,112
If not because you
download it for yourself,

24
00:00:54,112 --> 00:00:55,570
you should have seen it in lecture.

25
00:00:55,570 --> 00:00:56,590

26
00:00:56,590 --> 00:01:01,320
So this is the CS50 appliance, and he
did a somewhat of a description of it

27
00:01:01,320 --> 00:01:01,880
in lecture.

28
00:01:01,880 --> 00:01:06,890
But basically it's just you
are running an operating

29
00:01:06,890 --> 00:01:10,550
system within your operating
system so that we can give you

30
00:01:10,550 --> 00:01:12,540
programs without needing
to worry, oh is this

31
00:01:12,540 --> 00:01:15,989
going to work on both Windows
and Mac, or if some of you

32
00:01:15,989 --> 00:01:17,280
are already using Linux, Linux.

33
00:01:17,280 --> 00:01:18,532

34
00:01:18,532 --> 00:01:20,240
It's just supposed to
be a common playing

35
00:01:20,240 --> 00:01:23,010
field so everyone has the
same exact environment.

36
00:01:23,010 --> 00:01:25,344
>> So if you haven't
downloaded this already,

37
00:01:25,344 --> 00:01:28,510
you should download it, because you're
going to need it for the problem set.

38
00:01:28,510 --> 00:01:32,335
And it is a two gigabyte
download, so it might take awhile.

39
00:01:32,335 --> 00:01:33,780
On the Harvard it'll go fast.

40
00:01:33,780 --> 00:01:35,870

41
00:01:35,870 --> 00:01:37,440
So CS50 appliance.

42
00:01:37,440 --> 00:01:41,980
>> Now in the beginning, we're going to
talk about just a bunch of command line

43
00:01:41,980 --> 00:01:46,880
stuff, and so by that, I mean working
in this little environment over here.

44
00:01:46,880 --> 00:01:53,230
And notice all of things
I say right here right now

45
00:01:53,230 --> 00:01:56,900
are going to work if you're inside of
a terminal inside of the appliance,

46
00:01:56,900 --> 00:02:00,790
or if you are inside of
the gedit terminal window

47
00:02:00,790 --> 00:02:02,090
inside of the appliance.

48
00:02:02,090 --> 00:02:03,770
So those environments are identical.

49
00:02:03,770 --> 00:02:04,940

50
00:02:04,940 --> 00:02:07,270
>> But I'm going to go a third route.

51
00:02:07,270 --> 00:02:12,200
And notice down here this
little IP address right here.

52
00:02:12,200 --> 00:02:15,940
So you don't have to
do this, but this IP

53
00:02:15,940 --> 00:02:19,700
address-- now if I-- except
it's blocked by this thing.

54
00:02:19,700 --> 00:02:22,790

55
00:02:22,790 --> 00:02:27,000
OK, so that IP address
over in a terminal

56
00:02:27,000 --> 00:02:31,090
here-- so this terminal over
here is a terminal in my Mac.

57
00:02:31,090 --> 00:02:34,540
So this is in no way currently
associated with the appliance at all.

58
00:02:34,540 --> 00:02:39,360
And if you're on Windows, then you're
going to need to download something

59
00:02:39,360 --> 00:02:44,430
specifically for this, in particular
people tend use Putty, P-U-T-T-Y.

60
00:02:44,430 --> 00:02:50,700
>> So what I'm going to do is type
SSH and then that IP address.

61
00:02:50,700 --> 00:02:54,030
Well, jharvard at that IP address.

62
00:02:54,030 --> 00:03:00,150
So 192.168.24.220.

63
00:03:00,150 --> 00:03:02,127
This scary message, ignore it.

64
00:03:02,127 --> 00:03:02,710
Just type yes.

65
00:03:02,710 --> 00:03:04,550

66
00:03:04,550 --> 00:03:06,030
This is CS50 in a box.

67
00:03:06,030 --> 00:03:07,460
It asks for your password.

68
00:03:07,460 --> 00:03:11,910
>> And so in a lot of these contexts where
it asks for the password, [INAUDIBLE].

69
00:03:11,910 --> 00:03:15,670
We've got a lot of questions where
it says it's not actually typing.

70
00:03:15,670 --> 00:03:20,011
It doesn't show you the characters of
the password as you type, if anything,

71
00:03:20,011 --> 00:03:23,010
for a security feature, because if
someone is looking over your shoulder

72
00:03:23,010 --> 00:03:25,870
and they see star star
star star, then they

73
00:03:25,870 --> 00:03:28,640
know that your password
is four characters.

74
00:03:28,640 --> 00:03:32,660
So the idea is it will ask
you for your password, type.

75
00:03:32,660 --> 00:03:34,490
It's not going to show
you the characters,

76
00:03:34,490 --> 00:03:36,090
but it's actually accepting them.

77
00:03:36,090 --> 00:03:39,210
In this case, any time you
ever see a password prompt

78
00:03:39,210 --> 00:03:42,280
dealing with the appliance, the
password is going to be crimson.

79
00:03:42,280 --> 00:03:43,270
So crimson.

80
00:03:43,270 --> 00:03:44,730

81
00:03:44,730 --> 00:03:50,550
>> And now here inside of this
window that is in my Mac,

82
00:03:50,550 --> 00:03:54,120
I am basically having
the same exact view

83
00:03:54,120 --> 00:03:57,040
as inside of a terminal
in the appliance.

84
00:03:57,040 --> 00:03:58,470
So you don't have to do this.

85
00:03:58,470 --> 00:04:01,300
You can do everything you
want inside of the appliance.

86
00:04:01,300 --> 00:04:05,140
I almost never actually do
anything in the appliance.

87
00:04:05,140 --> 00:04:09,440
I almost always minimize that and now
I'm working SSH into the appliance.

88
00:04:09,440 --> 00:04:11,480

89
00:04:11,480 --> 00:04:14,180
>> If anything, if you
have a slower computer,

90
00:04:14,180 --> 00:04:15,820
you might notice a difference.

91
00:04:15,820 --> 00:04:18,839
I do this because I prefer
this terminal window.

92
00:04:18,839 --> 00:04:20,881
It has some features like
I can split the window,

93
00:04:20,881 --> 00:04:22,672
and now I can SSH in
through the appliance.

94
00:04:22,672 --> 00:04:24,105
I got two SSH's going on at once.

95
00:04:24,105 --> 00:04:28,030

96
00:04:28,030 --> 00:04:32,250
If your computer is particularly slow
and you're working in the appliance,

97
00:04:32,250 --> 00:04:35,200
and you realize this is
really laggy, whatever.

98
00:04:35,200 --> 00:04:38,220
Tends to be much faster
if you're SSH-ed in.

99
00:04:38,220 --> 00:04:40,960
But otherwise you can work either way.

100
00:04:40,960 --> 00:04:42,388
>> AUDIENCE: What does SSH mean?

101
00:04:42,388 --> 00:04:43,820

102
00:04:43,820 --> 00:04:47,479
>> ROB BOWDEN: Secure shells,
something like that?

103
00:04:47,479 --> 00:04:48,270
What does SSH mean?

104
00:04:48,270 --> 00:04:54,214

105
00:04:54,214 --> 00:04:55,130
GABRIEL: Secure shell.

106
00:04:55,130 --> 00:04:56,463
ALLISON: It's just secure shell.

107
00:04:56,463 --> 00:04:57,720
ROB BOWDEN: Secure shell.

108
00:04:57,720 --> 00:05:03,700
It's a protocol that you-- it's
a secure protocol, so encrypted.

109
00:05:03,700 --> 00:05:06,850
People can't snoop the network and
see what you're saying to anything

110
00:05:06,850 --> 00:05:08,120
you're SSH-ed to.

111
00:05:08,120 --> 00:05:12,900
And in fact, in the olden
days of CS50, so in 2009

112
00:05:12,900 --> 00:05:19,300
when I was a freshman, the way that
you worked on CS50 problem sets,

113
00:05:19,300 --> 00:05:22,490
was you SSH-ed to some server
that we gave you access to,

114
00:05:22,490 --> 00:05:23,497
and you worked on there.

115
00:05:23,497 --> 00:05:25,330
So you didn't have this
graphical appliance.

116
00:05:25,330 --> 00:05:26,160
You didn't have gedit.

117
00:05:26,160 --> 00:05:28,930
You didn't have all these things that
you could visually point and click.

118
00:05:28,930 --> 00:05:30,346
You had to work in this interface.

119
00:05:30,346 --> 00:05:31,580

120
00:05:31,580 --> 00:05:33,716
I prefer to work in this interface.

121
00:05:33,716 --> 00:05:36,090
So part of what we're going
to be going to over right now

122
00:05:36,090 --> 00:05:39,560
are a bunch of the
commands that you should

123
00:05:39,560 --> 00:05:42,095
start to get familiar with as
you go along in the course.

124
00:05:42,095 --> 00:05:43,190

125
00:05:43,190 --> 00:05:45,790
And honestly, once you
get used to them, it

126
00:05:45,790 --> 00:05:48,220
is so much faster to
work in this environment

127
00:05:48,220 --> 00:05:53,690
than it is to work with finder,
dragging and clicking things.

128
00:05:53,690 --> 00:05:55,340

129
00:05:55,340 --> 00:05:57,210
>> So here we are.

130
00:05:57,210 --> 00:06:01,779
Now I just SSH-ed in, and so
the default location-- you

131
00:06:01,779 --> 00:06:04,820
saw some of these commands in class,
but we'll go over all of them again.

132
00:06:04,820 --> 00:06:08,060
The default location we're
in is the home directory.

133
00:06:08,060 --> 00:06:11,520
And directory, just
another word for folder.

134
00:06:11,520 --> 00:06:13,310
So we're in the home directory.

135
00:06:13,310 --> 00:06:15,889
Type ls, list the files
in this directory.

136
00:06:15,889 --> 00:06:17,430
Evidently I created a blah.c earlier.

137
00:06:17,430 --> 00:06:19,120

138
00:06:19,120 --> 00:06:20,472
So we have a desktop directory.

139
00:06:20,472 --> 00:06:21,930
You notice the syntax highlighting?

140
00:06:21,930 --> 00:06:27,400

141
00:06:27,400 --> 00:06:32,900
The light blue highlighting indicates
a directory and the straight white

142
00:06:32,900 --> 00:06:34,380
indicates just a plain file.

143
00:06:34,380 --> 00:06:35,410

144
00:06:35,410 --> 00:06:37,690
So there are going to be
some other colors you see.

145
00:06:37,690 --> 00:06:41,240
An executable file is probably going
to be green or something like that.

146
00:06:41,240 --> 00:06:44,820
OK, so we are in the home directory.

147
00:06:44,820 --> 00:06:48,970
>> Now if I want to go into a different
directory, cd is the command I want.

148
00:06:48,970 --> 00:06:52,720
So change directory, and then you
pass the name of the directory

149
00:06:52,720 --> 00:06:54,020
that you want to go into.

150
00:06:54,020 --> 00:06:55,780
So here we have four options.

151
00:06:55,780 --> 00:07:03,397
I can go into downloads, and now we see
here it has updated this parenthetical

152
00:07:03,397 --> 00:07:04,480
to say I'm in ~/downloads.

153
00:07:04,480 --> 00:07:05,620

154
00:07:05,620 --> 00:07:06,800
>> So what is tilde?

155
00:07:06,800 --> 00:07:10,640
It's a shorthand for
your home directory.

156
00:07:10,640 --> 00:07:15,260
So almost everything you do is going to
be with respect to your home directory,

157
00:07:15,260 --> 00:07:20,620
and pwd is just a command
I use once in a year that

158
00:07:20,620 --> 00:07:22,420
just prints the current directory.

159
00:07:22,420 --> 00:07:25,730
And so you see here that
~/downloads really resolves

160
00:07:25,730 --> 00:07:26,896
to /home/jharvard/downloads.

161
00:07:26,896 --> 00:07:29,320

162
00:07:29,320 --> 00:07:32,230
So /home/jharvard is my home directory.

163
00:07:32,230 --> 00:07:33,700

164
00:07:33,700 --> 00:07:39,400
>> So we can cd dot dot.

165
00:07:39,400 --> 00:07:47,800
Now dot dot is a special directory that
always refers to the one directory up.

166
00:07:47,800 --> 00:07:51,730
So if I'm in ~/downloads, then cd dot
dot is going to bring me to tilde.

167
00:07:51,730 --> 00:07:52,950

168
00:07:52,950 --> 00:07:55,490
What do we think cd dot dot
is going to bring me to now?

169
00:07:55,490 --> 00:07:58,740

170
00:07:58,740 --> 00:08:00,570
It'll bring me to /home.

171
00:08:00,570 --> 00:08:04,450
So tilde by print working directory,
I'm in now /home/jharvard.

172
00:08:04,450 --> 00:08:06,060

173
00:08:06,060 --> 00:08:08,820
one directory up from that,
now it says here /home.

174
00:08:08,820 --> 00:08:12,330

175
00:08:12,330 --> 00:08:17,180
>> Now cd dot dot.

176
00:08:17,180 --> 00:08:20,910
Now I'm in the root directory,
and you can't do it again.

177
00:08:20,910 --> 00:08:23,340
You'll just stay in the
root directory forever.

178
00:08:23,340 --> 00:08:26,700
The root directory has a whole bunch of
things that, if you want to look into,

179
00:08:26,700 --> 00:08:27,410
you can.

180
00:08:27,410 --> 00:08:29,700
For example, if I go
into bin, that contains

181
00:08:29,700 --> 00:08:35,789
all these binaries, such as ls,
and cd, and all of those things.

182
00:08:35,789 --> 00:08:38,630
So these commands need to
exist somewhere in the system,

183
00:08:38,630 --> 00:08:40,820
and it's in the /bin directory.

184
00:08:40,820 --> 00:08:44,530
But almost everything you do is
going to be from your home directory.

185
00:08:44,530 --> 00:08:49,490
And cd without any arguments whatsoever,
you could say cd ~, don't need to.

186
00:08:49,490 --> 00:08:51,810
cd is going to bring you
back to your home directory.

187
00:08:51,810 --> 00:08:53,170

188
00:08:53,170 --> 00:08:54,230
>> One last one.

189
00:08:54,230 --> 00:09:00,200
cd - is going to bring you back to
the last directory that you were in.

190
00:09:00,200 --> 00:09:04,080
So I just cd'd twice in a row, so my
last directory was the home directory.

191
00:09:04,080 --> 00:09:11,520
If I go to slash bin, and now
let's go up and into user.

192
00:09:11,520 --> 00:09:12,550

193
00:09:12,550 --> 00:09:13,280
User share.

194
00:09:13,280 --> 00:09:14,840

195
00:09:14,840 --> 00:09:15,940
Let's go to user share.

196
00:09:15,940 --> 00:09:17,140
Now I'm now in user share.

197
00:09:17,140 --> 00:09:19,320
cd -, back in bin.

198
00:09:19,320 --> 00:09:22,980
So this gets particularly useful
when you have-- and it'll toggle.

199
00:09:22,980 --> 00:09:25,660
So user share, back bin, share bin.

200
00:09:25,660 --> 00:09:27,250
>> So this gets useful.

201
00:09:27,250 --> 00:09:33,150
You may find yourself having many,
many, many nested directories.

202
00:09:33,150 --> 00:09:37,370
And you want to do something
real quick in an upper directory.

203
00:09:37,370 --> 00:09:40,330
You go to that directory, make
changes and stuff like that,

204
00:09:40,330 --> 00:09:42,400
and now you want to go
back to where you were.

205
00:09:42,400 --> 00:09:43,660
cd -.

206
00:09:43,660 --> 00:09:47,320
I'm always frustrated
when I happen to go

207
00:09:47,320 --> 00:09:49,630
to that directory I
wanted to do work in.

208
00:09:49,630 --> 00:09:52,670
I always get frustrated when I did
it in two steps instead of one step,

209
00:09:52,670 --> 00:09:55,715
because that means that cd - is going
to bring into that intermediate location

210
00:09:55,715 --> 00:09:57,010
instead of where I want to go.

211
00:09:57,010 --> 00:09:59,350

212
00:09:59,350 --> 00:10:01,450
>> So we see all the list files.

213
00:10:01,450 --> 00:10:03,300
We know how to get around so far.

214
00:10:03,300 --> 00:10:09,900
So now let's talk about editing files.

215
00:10:09,900 --> 00:10:18,790
So in this course, you're almost
always expected to use gedit.

216
00:10:18,790 --> 00:10:24,410
If you want, you can take the next step
and start learning a command line text

217
00:10:24,410 --> 00:10:25,240
editor.

218
00:10:25,240 --> 00:10:27,560
So various options exist.

219
00:10:27,560 --> 00:10:31,760
>> And the ones that are probably
going to be relevant to you,

220
00:10:31,760 --> 00:10:35,340
we have Nano, Vim, and Emacs.

221
00:10:35,340 --> 00:10:40,196
So Nano is the beginners
command line text editor.

222
00:10:40,196 --> 00:10:42,985
So Nano let's go on
blah.c I created earlier.

223
00:10:42,985 --> 00:10:44,030

224
00:10:44,030 --> 00:10:46,480
It's just this standard C file.

225
00:10:46,480 --> 00:10:51,540
And you see a whole bunch of stuff
going on at the bottom of the screen,

226
00:10:51,540 --> 00:10:54,100
and apparently blah.c
contains this C code.

227
00:10:54,100 --> 00:10:55,420

228
00:10:55,420 --> 00:11:00,330
>> So in this particular editor,
what it's saying at the bottom--

229
00:11:00,330 --> 00:11:06,290
now this caret symbol,
we see this ^G, ^X, ^O.

230
00:11:06,290 --> 00:11:10,310
So that in almost all
context that you see,

231
00:11:10,310 --> 00:11:13,530
you might see that caret symbol in
other places online, on Stack Overflow,

232
00:11:13,530 --> 00:11:14,450
something like that.

233
00:11:14,450 --> 00:11:16,970
It almost always refers to control.

234
00:11:16,970 --> 00:11:21,590
So to exit I want to do
Control X. Control X, exits.

235
00:11:21,590 --> 00:11:22,750

236
00:11:22,750 --> 00:11:26,855
And I can use my arrow
keys to move around.

237
00:11:26,855 --> 00:11:28,010

238
00:11:28,010 --> 00:11:31,015
Notice I cannot point and click readily.

239
00:11:31,015 --> 00:11:33,000

240
00:11:33,000 --> 00:11:35,010
You need use your arrow
keys to move around.

241
00:11:35,010 --> 00:11:36,950
There might be a setting
to point and click.

242
00:11:36,950 --> 00:11:40,000
>> But let's make some changes.

243
00:11:40,000 --> 00:11:42,100
Now Control X to go exit.

244
00:11:42,100 --> 00:11:44,120
It's going to say save modified buffer.

245
00:11:44,120 --> 00:11:47,900
Now the prompt, y for yes, n for no.

246
00:11:47,900 --> 00:11:49,900
Control C for cancel.

247
00:11:49,900 --> 00:11:50,780
I'll just say yes.

248
00:11:50,780 --> 00:11:51,709
File name to write.

249
00:11:51,709 --> 00:11:53,500
The default is the file
that it already is.

250
00:11:53,500 --> 00:11:54,230
Hit Enter.

251
00:11:54,230 --> 00:11:54,740
OK.

252
00:11:54,740 --> 00:11:58,580
Now I've just edited that file,
saved it, and it is changed.

253
00:11:58,580 --> 00:11:59,770

254
00:11:59,770 --> 00:12:03,000
>> So Nano is the easiest
text editor get used to.

255
00:12:03,000 --> 00:12:05,520
The alternatives are Vim and Emacs.

256
00:12:05,520 --> 00:12:11,250
Those are higher level text editors
that have a very steep learning curve.

257
00:12:11,250 --> 00:12:13,740
So my personal preference is Vim.

258
00:12:13,740 --> 00:12:17,175
And it has a wide variety of options.

259
00:12:17,175 --> 00:12:18,210

260
00:12:18,210 --> 00:12:24,070
And once you get used
to it, you'll never

261
00:12:24,070 --> 00:12:26,900
want to go to any other
text editor because you just

262
00:12:26,900 --> 00:12:29,590
have so many things
available to you in these,

263
00:12:29,590 --> 00:12:31,690
but it takes a really
long time to learn.

264
00:12:31,690 --> 00:12:36,000
So maybe you just want to force
yourself right now to get used to it,

265
00:12:36,000 --> 00:12:38,130
but I would say it's worth it.

266
00:12:38,130 --> 00:12:39,660
But it is hard.

267
00:12:39,660 --> 00:12:41,220
>> And then Emacs.

268
00:12:41,220 --> 00:12:44,940
I always struggle in Emacs because
I know how to do absolutely nothing.

269
00:12:44,940 --> 00:12:47,755
Apparently Emacs is not by default
installed on the appliance.

270
00:12:47,755 --> 00:12:49,210

271
00:12:49,210 --> 00:12:51,720
We will probably add that
as a default installations.

272
00:12:51,720 --> 00:12:59,620

273
00:12:59,620 --> 00:13:02,390
Once you learn one of
Vim or Emacs, there's

274
00:13:02,390 --> 00:13:04,810
no compelling reason to
ever learn the other,

275
00:13:04,810 --> 00:13:07,570
but it's a completely different style.

276
00:13:07,570 --> 00:13:10,460
OK so that's editing text files.

277
00:13:10,460 --> 00:13:13,374
>> AUDIENCE: If you were stuck
in Vim right now, how do we--

278
00:13:13,374 --> 00:13:18,840

279
00:13:18,840 --> 00:13:20,800
>> ROB BOWDEN: There are
multiple modes in Vim,

280
00:13:20,800 --> 00:13:23,770
and there are entire
tutorials on learning Vim.

281
00:13:23,770 --> 00:13:27,390
So if you happen to be
in insert mode in order

282
00:13:27,390 --> 00:13:29,930
to type text, which you can
enter that in various ways,

283
00:13:29,930 --> 00:13:31,610
but i is how you get into insert mode.

284
00:13:31,610 --> 00:13:34,780
In or get out of any special
mode that you're in, just Escape.

285
00:13:34,780 --> 00:13:37,640
And you just bash Escape to get
out of any nested modes your in.

286
00:13:37,640 --> 00:13:40,360
Just OK, now I'm back in normal mode.

287
00:13:40,360 --> 00:13:43,790
>> And so in normal mode, a colon.

288
00:13:43,790 --> 00:13:45,160
You see it appear at the bottom.

289
00:13:45,160 --> 00:13:46,240
And then q.

290
00:13:46,240 --> 00:13:52,600
So q will quit if you've made changes,
which I-- have I made changes?

291
00:13:52,600 --> 00:13:54,180
I have made changes apparently.

292
00:13:54,180 --> 00:13:57,264
So if you've made changes, it'll
say you can put an exclamation mark.

293
00:13:57,264 --> 00:13:58,430
I'm going to call it a bang.

294
00:13:58,430 --> 00:14:02,040
So you can put a ban to just
quit without doing anything,

295
00:14:02,040 --> 00:14:04,520
or colon wq will save and quit.

296
00:14:04,520 --> 00:14:06,580
So w in general is write.

297
00:14:06,580 --> 00:14:08,300
So write the file.

298
00:14:08,300 --> 00:14:09,810
I can write and quit.

299
00:14:09,810 --> 00:14:13,606
Or you could have just
qx slam, q bang just

300
00:14:13,606 --> 00:14:16,230
to get out of there regardless
of any changes that you've made.

301
00:14:16,230 --> 00:14:21,310

302
00:14:21,310 --> 00:14:28,940
>> All right, so now let's
go-- we can create files.

303
00:14:28,940 --> 00:14:30,890
Let's start removing files.

304
00:14:30,890 --> 00:14:35,450
And I'll just throw in one
quick new command, touch.

305
00:14:35,450 --> 00:14:38,200
So touch foo.

306
00:14:38,200 --> 00:14:39,340
Touch bar.

307
00:14:39,340 --> 00:14:40,220
Touch baz.

308
00:14:40,220 --> 00:14:42,810
If I ls, now we see
that those files exist.

309
00:14:42,810 --> 00:14:44,315
They're completely empty.

310
00:14:44,315 --> 00:14:47,178
So touch is just an easy
way of one, [INAUDIBLE].

311
00:14:47,178 --> 00:14:50,850

312
00:14:50,850 --> 00:14:54,640
Two, technically just to state
it, it updates the timestamps.

313
00:14:54,640 --> 00:14:58,470
So any file that you create has
a timestamp associated with it.

314
00:14:58,470 --> 00:15:01,330
So baz was created on
September 14 at 16:21.

315
00:15:01,330 --> 00:15:02,570

316
00:15:02,570 --> 00:15:06,670
It's now 16:22, so if
I touch baz again, we

317
00:15:06,670 --> 00:15:11,420
see that baz was most
recently modified at 16:22.

318
00:15:11,420 --> 00:15:17,680
But otherwise I almost never
look at the timestamps on files.

319
00:15:17,680 --> 00:15:20,490
So touch, here I'm just using
it to create some quick files.

320
00:15:20,490 --> 00:15:21,620

321
00:15:21,620 --> 00:15:27,400
>> All right, so now rm is the
command that we care about here.

322
00:15:27,400 --> 00:15:28,665
And we can rm boo.

323
00:15:28,665 --> 00:15:31,000
Say remove regular empty file boo.

324
00:15:31,000 --> 00:15:34,070
And we can type y, and now it's removes.

325
00:15:34,070 --> 00:15:34,850
rm baz.

326
00:15:34,850 --> 00:15:35,910

327
00:15:35,910 --> 00:15:38,620
Remove regular empty file
baz and type n for no.

328
00:15:38,620 --> 00:15:40,060
Now it's not removed.

329
00:15:40,060 --> 00:15:41,240
So bar and baz still exist.

330
00:15:41,240 --> 00:15:42,232
Foo is gone.

331
00:15:42,232 --> 00:15:43,148
GABRIEL: Keep talking.

332
00:15:43,148 --> 00:15:43,970

333
00:15:43,970 --> 00:15:44,720
ROB BOWDEN: Great.

334
00:15:44,720 --> 00:15:45,800

335
00:15:45,800 --> 00:15:50,370
So the annoying message
here, remove regular empty--

336
00:15:50,370 --> 00:15:52,390
what are you doing down there?

337
00:15:52,390 --> 00:15:54,030
Remove regular empty file.

338
00:15:54,030 --> 00:15:58,840

339
00:15:58,840 --> 00:16:01,610
So if we don't want to be
bothered by that message,

340
00:16:01,610 --> 00:16:05,340
we can throw in this -f
flag, and so that's force.

341
00:16:05,340 --> 00:16:11,330
And now if I rm -f, it's not going to
say do you want to remove this file.

342
00:16:11,330 --> 00:16:12,040
It'll just do it.

343
00:16:12,040 --> 00:16:13,720
And ls, I don't see bar there anymore.

344
00:16:13,720 --> 00:16:14,810

345
00:16:14,810 --> 00:16:18,021
>> Now that is a potentially
dangerous command.

346
00:16:18,021 --> 00:16:19,020
It tends not to too bad.

347
00:16:19,020 --> 00:16:22,240
We'll come back in a second how
it can get really dangerous.

348
00:16:22,240 --> 00:16:28,740
And let's create some temp directory.

349
00:16:28,740 --> 00:16:30,880
mkdir, another command.

350
00:16:30,880 --> 00:16:34,880
So mkdir is a command
that makes a directory.

351
00:16:34,880 --> 00:16:40,650
And now by ls we see this nice light
blue highlighted temp directory.

352
00:16:40,650 --> 00:16:42,295
I can cd into temp.

353
00:16:42,295 --> 00:16:44,590
And I can mkdir foo.

354
00:16:44,590 --> 00:16:46,330
cd into foo. mkdir bar.

355
00:16:46,330 --> 00:16:46,860
cd into bar.

356
00:16:46,860 --> 00:16:49,400

357
00:16:49,400 --> 00:16:54,300
>> So we see we can easily get
into some pretty deep nesting.

358
00:16:54,300 --> 00:16:56,385
Now how do I remove a directory?

359
00:16:56,385 --> 00:16:57,020

360
00:16:57,020 --> 00:16:57,520
rmdir.

361
00:16:57,520 --> 00:16:59,030

362
00:16:59,030 --> 00:17:03,540
So if I just straight try to rm,
like we did with a regular file,

363
00:17:03,540 --> 00:17:06,420
rm bar is going to
say cannot remove bar.

364
00:17:06,420 --> 00:17:07,569
It is a directory.

365
00:17:07,569 --> 00:17:10,619
There's a special command for
removing directories, kind of.

366
00:17:10,619 --> 00:17:12,900
So rmdir bar.

367
00:17:12,900 --> 00:17:13,710
Now bar is gone.

368
00:17:13,710 --> 00:17:14,980

369
00:17:14,980 --> 00:17:22,680
>> OK, so rmdir I pretty much never use.

370
00:17:22,680 --> 00:17:32,220
The reason being-- now let's
make a regular file bar in here.

371
00:17:32,220 --> 00:17:34,780
So rmdir boo.

372
00:17:34,780 --> 00:17:35,760
rmdir.

373
00:17:35,760 --> 00:17:36,900
Failed to remove foo.

374
00:17:36,900 --> 00:17:38,420
Directory not empty.

375
00:17:38,420 --> 00:17:43,420
So you cannot use remove dir on a
directory that has things in it.

376
00:17:43,420 --> 00:17:44,830
>> So you have some options.

377
00:17:44,830 --> 00:17:49,780
You can go into that directory, remove
everything manually, and then come out

378
00:17:49,780 --> 00:17:51,759
and rmdir the directory.

379
00:17:51,759 --> 00:17:53,050
That obviously sounds annoying.

380
00:17:53,050 --> 00:17:55,000
What if there are thousands
of files in there?

381
00:17:55,000 --> 00:17:58,119
Well, you could rm *.

382
00:17:58,119 --> 00:17:59,410
We'll talk about * in a second.

383
00:17:59,410 --> 00:18:00,870
It basically means all the things.

384
00:18:00,870 --> 00:18:02,030

385
00:18:02,030 --> 00:18:05,470
But better yet, so rm -r.

386
00:18:05,470 --> 00:18:10,220
So rm -r-- in a lot of
contexts, -r means recursive,

387
00:18:10,220 --> 00:18:13,810
which we'll talk about what
recursive means in several weeks.

388
00:18:13,810 --> 00:18:18,630
But it basically means traverse
the entirety of this directory

389
00:18:18,630 --> 00:18:20,190
and remove everything.

390
00:18:20,190 --> 00:18:24,420
>> So rm -r foo is going to say
descend into directory foo?

391
00:18:24,420 --> 00:18:25,210
Yes.

392
00:18:25,210 --> 00:18:26,800
Remove regular empty file foo/bar?

393
00:18:26,800 --> 00:18:27,880

394
00:18:27,880 --> 00:18:28,540
Yes.

395
00:18:28,540 --> 00:18:29,760
Remove directory foo?

396
00:18:29,760 --> 00:18:30,260
Yes.

397
00:18:30,260 --> 00:18:31,470

398
00:18:31,470 --> 00:18:35,020
So now foo and everything
within it has been removed.

399
00:18:35,020 --> 00:18:42,370
>> Now that can get particularly annoying
when-- let's touch 1, touch 2, touch 3.

400
00:18:42,370 --> 00:18:44,400
Could have a whole bunch of files.

401
00:18:44,400 --> 00:18:49,060
If I wanted, I could create
thousands of files in here.

402
00:18:49,060 --> 00:18:53,340
And rm -r foo is going
to be pretty annoying.

403
00:18:53,340 --> 00:18:55,374
Yes, yes, yes, yes, yes, yes.

404
00:18:55,374 --> 00:18:57,540
With a lot more files you
quickly see how many times

405
00:18:57,540 --> 00:18:58,581
I would have to type yes.

406
00:18:58,581 --> 00:19:02,265
Well, we just saw before how we can
get rid of needing to type yes, -f.

407
00:19:02,265 --> 00:19:03,330

408
00:19:03,330 --> 00:19:07,020
So mkdir foo cd foo touch 1 2 3.

409
00:19:07,020 --> 00:19:08,380

410
00:19:08,380 --> 00:19:17,190
OK, so rm -rf foo is going to
blindly remove foo entirely.

411
00:19:17,190 --> 00:19:17,960
No prompt.

412
00:19:17,960 --> 00:19:18,650
No anything.

413
00:19:18,650 --> 00:19:20,040
Foo is gone.

414
00:19:20,040 --> 00:19:23,830
>> So I tend to use this
command all the time.

415
00:19:23,830 --> 00:19:25,120

416
00:19:25,120 --> 00:19:27,830
That said, it is a
very dangerous command,

417
00:19:27,830 --> 00:19:33,240
because if I do something like
this, it will not prompt you.

418
00:19:33,240 --> 00:19:34,730
It will be gone.

419
00:19:34,730 --> 00:19:40,140
And it happens pretty frequently,
and even in higher level CS courses.

420
00:19:40,140 --> 00:19:42,070
Sometimes we'll see
something where someone

421
00:19:42,070 --> 00:19:48,360
says I accidentally our rm rf-ed my home
directory and all of my P set is gone.

422
00:19:48,360 --> 00:19:52,422
And it's devastating,
but there's no trash can.

423
00:19:52,422 --> 00:19:54,380
There's no there's nothing
for you to retrieve.

424
00:19:54,380 --> 00:19:55,330
It's just gone.

425
00:19:55,330 --> 00:19:56,529

426
00:19:56,529 --> 00:19:58,320
Even worse would be
something like rm -rf/.

427
00:19:58,320 --> 00:19:59,432

428
00:19:59,432 --> 00:20:01,140
So we just discussed
that root directory.

429
00:20:01,140 --> 00:20:03,095
It holds all of the
files on your system.

430
00:20:03,095 --> 00:20:04,120

431
00:20:04,120 --> 00:20:07,380
Things tend to get pretty messy
when you remove things like ls,

432
00:20:07,380 --> 00:20:10,280
and cd, and all of those.

433
00:20:10,280 --> 00:20:15,467
>> AUDIENCE: What's the difference
between rm, rf, and rm*

434
00:20:15,467 --> 00:20:16,300
ROB BOWDEN: So rm*--

435
00:20:16,300 --> 00:20:17,700

436
00:20:17,700 --> 00:20:22,300
>> ALLISON: Question was what's the
difference between rm, rf, and rm*.

437
00:20:22,300 --> 00:20:23,750

438
00:20:23,750 --> 00:20:25,950
>> ROB BOWDEN: So rm*.

439
00:20:25,950 --> 00:20:31,910
Star in general means all of
the contents of this directory.

440
00:20:31,910 --> 00:20:33,540

441
00:20:33,540 --> 00:20:35,540
Trying to think of other
ways of showing star.

442
00:20:35,540 --> 00:20:38,280

443
00:20:38,280 --> 00:20:44,780
Well, star actually generally
means match any pattern.

444
00:20:44,780 --> 00:20:54,930
So if I have a file called dog1,
touch dog2, touch cat1, touch cat2.

445
00:20:54,930 --> 00:20:56,050

446
00:20:56,050 --> 00:21:02,110
So ls*1 is going to print cat1 and
dog1, because that star can be filled

447
00:21:02,110 --> 00:21:06,270
in with-- the one needs to be there,
but star can be either cat or dog.

448
00:21:06,270 --> 00:21:07,247
It's a wild card.

449
00:21:07,247 --> 00:21:08,580
That's the word I'm looking for.

450
00:21:08,580 --> 00:21:09,120
Wild card.

451
00:21:09,120 --> 00:21:10,180

452
00:21:10,180 --> 00:21:13,960
Or I could ls dog*, and
I'm got to see dog1, dog2.

453
00:21:13,960 --> 00:21:16,870
So those are listing the files
that match that particular pattern.

454
00:21:16,870 --> 00:21:18,150
You can use ls in this way.

455
00:21:18,150 --> 00:21:19,350

456
00:21:19,350 --> 00:21:22,020
>> Ls* star matches anything.

457
00:21:22,020 --> 00:21:25,710
So it's going to print all of
the contents of this directory

458
00:21:25,710 --> 00:21:27,290
since all of them match.

459
00:21:27,290 --> 00:21:30,130
It's not going to print anything
in upper level directories.

460
00:21:30,130 --> 00:21:38,680
If I have a sub directory, foo, and
touch 1 2 3-- so now if rm* star,

461
00:21:38,680 --> 00:21:41,450
remove cat1, cat2, dog1, dog2.

462
00:21:41,450 --> 00:21:42,340
Cannot remove foo.

463
00:21:42,340 --> 00:21:43,090
It is a directory.

464
00:21:43,090 --> 00:21:43,920

465
00:21:43,920 --> 00:21:50,340
>> So star expands to all the
files in the directory.

466
00:21:50,340 --> 00:21:55,210
So technically rm* is like saying
rm cat1, cat2, dog1, dog2, foo.

467
00:21:55,210 --> 00:22:03,630
Whereas rm -rf, technically star would
accomplish what we want, but rm -rf--

468
00:22:03,630 --> 00:22:06,090
if I go out of this
directory, rm -rf temp,

469
00:22:06,090 --> 00:22:08,890
that's going to go into temp and
recursively remove everything.

470
00:22:08,890 --> 00:22:11,260

471
00:22:11,260 --> 00:22:21,060
>> So star is separate in that that
is understood by-- so this thing

472
00:22:21,060 --> 00:22:25,090
that I'm running in, this thing
that is prompting me for commands

473
00:22:25,090 --> 00:22:28,770
and then executing and doing
them, I call this my shell.

474
00:22:28,770 --> 00:22:31,930
And so this shell is itself a program.

475
00:22:31,930 --> 00:22:35,010
And if I wanted, I
could run in /bin/bash.

476
00:22:35,010 --> 00:22:36,930
The shell is called bash.

477
00:22:36,930 --> 00:22:39,340
And now we notice something
has slightly changed,

478
00:22:39,340 --> 00:22:42,200
and that's because my settings for
the shell are somewhat different.

479
00:22:42,200 --> 00:22:45,415
>> But now I'm technically running
a shell within my original shell,

480
00:22:45,415 --> 00:22:49,570
and I can exit that shell, and now
I'm back to my top level shell.

481
00:22:49,570 --> 00:22:55,240
The purpose of saying
that is-- the star.

482
00:22:55,240 --> 00:22:59,020
So the star is something
understood by bash.

483
00:22:59,020 --> 00:23:04,260
So rm -rf, -rf flag is
understood by just rm.

484
00:23:04,260 --> 00:23:06,380
It knows that when you
pass a -rf that you

485
00:23:06,380 --> 00:23:09,520
want it to recursively remove
all files without prompting.

486
00:23:09,520 --> 00:23:13,960
The star is something understood
by bash that when you say rm*,

487
00:23:13,960 --> 00:23:16,890
bash isn't going to say
hey rm*, remove star.

488
00:23:16,890 --> 00:23:21,010
Bash is going to say rm*
remove cat1, cat2, dog1, dog2.

489
00:23:21,010 --> 00:23:24,305
It's automatically going to expand
all of the files in the directory.

490
00:23:24,305 --> 00:23:29,100

491
00:23:29,100 --> 00:23:33,140
>> And similarly tilde is another
symbol that bash understands.

492
00:23:33,140 --> 00:23:37,130
When you say cd ~, bash expands
that to your home directory.

493
00:23:37,130 --> 00:23:38,910

494
00:23:38,910 --> 00:23:40,210
Other questions so far?

495
00:23:40,210 --> 00:23:42,760

496
00:23:42,760 --> 00:23:46,060
OK so we're going to start going quick.

497
00:23:46,060 --> 00:23:47,700

498
00:23:47,700 --> 00:23:48,545
>> Tab completion.

499
00:23:48,545 --> 00:23:49,670
Just to throw it out there.

500
00:23:49,670 --> 00:23:51,530
A lot of people don't
realize this exists.

501
00:23:51,530 --> 00:23:55,060
So if I type cd dow, I
want to go into downloads.

502
00:23:55,060 --> 00:23:56,700
I do not need to type nloads.

503
00:23:56,700 --> 00:23:57,960

504
00:23:57,960 --> 00:24:00,770
I can just hit Tab.

505
00:24:00,770 --> 00:24:03,794
So it recognizes that
dow is a prefix that

506
00:24:03,794 --> 00:24:05,710
doesn't match anything
else in this directory,

507
00:24:05,710 --> 00:24:07,520
so it will complete that for you.

508
00:24:07,520 --> 00:24:08,610
Now I can enter.

509
00:24:08,610 --> 00:24:10,110
>> I also do that recursively.

510
00:24:10,110 --> 00:24:11,205
So mkdir foo.

511
00:24:11,205 --> 00:24:12,480

512
00:24:12,480 --> 00:24:13,300
Let's go into foo.

513
00:24:13,300 --> 00:24:14,830
mkdir bar.

514
00:24:14,830 --> 00:24:17,345
So going back to my home
directory, I can see downloads.

515
00:24:17,345 --> 00:24:19,040

516
00:24:19,040 --> 00:24:21,860
Now hitting tab again,
automatically going to fill in foo.

517
00:24:21,860 --> 00:24:22,880
It's the only directory.

518
00:24:22,880 --> 00:24:25,340
Hitting tab again, automatically
going to fill in bar.

519
00:24:25,340 --> 00:24:26,798
So now I'm in (~Downloads/foo/bar).

520
00:24:26,798 --> 00:24:27,310

521
00:24:27,310 --> 00:24:31,692
>> So this tab completion,
whenever I got to office hours,

522
00:24:31,692 --> 00:24:33,400
and I'm standing over
someone's shoulder,

523
00:24:33,400 --> 00:24:40,470
and they're going rm
D-O-W-N-L-O-A-D-S, I'm dying.

524
00:24:40,470 --> 00:24:41,990
Just tab, tab, tab, tab.

525
00:24:41,990 --> 00:24:44,550

526
00:24:44,550 --> 00:24:45,630
So definitely used tab.

527
00:24:45,630 --> 00:24:47,890

528
00:24:47,890 --> 00:24:49,840
And similarly up and
down, a lot of people

529
00:24:49,840 --> 00:24:51,930
just that happened to
never have hit up and down.

530
00:24:51,930 --> 00:24:54,870
It'll go through the previous
commands, so if you just ran something,

531
00:24:54,870 --> 00:24:58,300
and you want to run it again,
just hold up till you get to it.

532
00:24:58,300 --> 00:24:59,870

533
00:24:59,870 --> 00:25:00,370
OK.

534
00:25:00,370 --> 00:25:01,460

535
00:25:01,460 --> 00:25:03,585
>> So quick, some other things.

536
00:25:03,585 --> 00:25:04,800

537
00:25:04,800 --> 00:25:05,930
Let's go back into temp.

538
00:25:05,930 --> 00:25:06,976

539
00:25:06,976 --> 00:25:08,125
Let's create some files.

540
00:25:08,125 --> 00:25:10,480

541
00:25:10,480 --> 00:25:15,215
So in here, I'm just
going to list some words.

542
00:25:15,215 --> 00:25:18,460

543
00:25:18,460 --> 00:25:21,035
dog, cat, meow.

544
00:25:21,035 --> 00:25:23,940

545
00:25:23,940 --> 00:25:26,040
Let's do dog, fish.

546
00:25:26,040 --> 00:25:27,500

547
00:25:27,500 --> 00:25:32,320
So now rep is a very
useful commands that you

548
00:25:32,320 --> 00:25:37,820
use to search throughout
files for a particular text,

549
00:25:37,820 --> 00:25:40,910
and technically you can do really
complex expressions for it to match.

550
00:25:40,910 --> 00:25:44,830
>> So here, if I grep, and what
do I want to search for?

551
00:25:44,830 --> 00:25:49,130
Let's say I'm searching for cats, and
I want to search all of these files.

552
00:25:49,130 --> 00:25:50,650
So how do I do all of these files?

553
00:25:50,650 --> 00:25:51,900
Star.

554
00:25:51,900 --> 00:25:54,939
So in file one, I have cat.

555
00:25:54,939 --> 00:25:56,980
I probably could have
called it something better,

556
00:25:56,980 --> 00:25:59,063
because that looks like
line numbers or something.

557
00:25:59,063 --> 00:26:01,590
But in file one I have a line with cat.

558
00:26:01,590 --> 00:26:04,160
In file two I have a line with cat.

559
00:26:04,160 --> 00:26:07,280
So now I can look inside file one and
see oh yeah, that file did have cat.

560
00:26:07,280 --> 00:26:10,210
Notice file three was not matched
because cat isn't in there.

561
00:26:10,210 --> 00:26:13,882
I can grep for meow.

562
00:26:13,882 --> 00:26:14,840
Only file two has meow.

563
00:26:14,840 --> 00:26:16,120

564
00:26:16,120 --> 00:26:20,640
>> So this you can combine,
again, with -r, which

565
00:26:20,640 --> 00:26:23,580
as I said before
frequently means recursive.

566
00:26:23,580 --> 00:26:29,800
And so I can come up here, grep -r
for any instance of-- let's edit

567
00:26:29,800 --> 00:26:32,010
this one just to throw a cat in there.

568
00:26:32,010 --> 00:26:38,800
So grep -r for any instance of
cat throughout this directory.

569
00:26:38,800 --> 00:26:41,600
And it will recursively
search any subdirectories.

570
00:26:41,600 --> 00:26:43,940
So in baz, there's cat.

571
00:26:43,940 --> 00:26:45,570
In temp/2, there's cat.

572
00:26:45,570 --> 00:26:47,960
And in temp/1 there's cat.

573
00:26:47,960 --> 00:26:50,045
So that's searching within files.

574
00:26:50,045 --> 00:26:51,250

575
00:26:51,250 --> 00:26:55,090
>> Now you can also use a find.

576
00:26:55,090 --> 00:26:59,640
And so find is specifically about
looking for files with a given name.

577
00:26:59,640 --> 00:27:02,490
So let's make some more.

578
00:27:02,490 --> 00:27:03,660
Let's go into downloads.

579
00:27:03,660 --> 00:27:04,680

580
00:27:04,680 --> 00:27:05,380
Touch dog1.

581
00:27:05,380 --> 00:27:06,840

582
00:27:06,840 --> 00:27:07,770
Touch cat2.

583
00:27:07,770 --> 00:27:09,290

584
00:27:09,290 --> 00:27:10,760
Touch cat_dog.

585
00:27:10,760 --> 00:27:14,550

586
00:27:14,550 --> 00:27:15,975
Touch catcat.

587
00:27:15,975 --> 00:27:18,270

588
00:27:18,270 --> 00:27:23,810
>> So I want to find all
files with dog in the name.

589
00:27:23,810 --> 00:27:28,060
So find, and for the longest
time I never remembered

590
00:27:28,060 --> 00:27:33,760
how find worked, until I finally
read something that made it so clear.

591
00:27:33,760 --> 00:27:35,784
So find, automatically recursive.

592
00:27:35,784 --> 00:27:36,950
You don't need to pass a -r.

593
00:27:36,950 --> 00:27:38,090

594
00:27:38,090 --> 00:27:39,110
So find dot.

595
00:27:39,110 --> 00:27:40,750
We haven't talked about dot yet.

596
00:27:40,750 --> 00:27:44,800
Whereas dot dot always
means one directory up.

597
00:27:44,800 --> 00:27:46,960
Dot always means the current directory.

598
00:27:46,960 --> 00:27:51,390
So I could rm -r dot in the
same way I can rm -rf *.

599
00:27:51,390 --> 00:27:53,140
Ultimately they
accomplish the same thing.

600
00:27:53,140 --> 00:27:56,040
rm -rf dot is going to remove
the entire current directory.

601
00:27:56,040 --> 00:27:57,440

602
00:27:57,440 --> 00:27:59,680
>> OK, which I don't want to do there.

603
00:27:59,680 --> 00:28:01,490

604
00:28:01,490 --> 00:28:04,320
But find dot.

605
00:28:04,320 --> 00:28:07,920
So recursively search the current
directory, and now everything

606
00:28:07,920 --> 00:28:14,125
after this are a bunch of flags that you
use to exclude things from the return.

607
00:28:14,125 --> 00:28:17,250
So find dot returns everything that it
can find from the current directory.

608
00:28:17,250 --> 00:28:19,700
Those are all the files
recursively searching.

609
00:28:19,700 --> 00:28:21,250
We'll see some of those in a second.

610
00:28:21,250 --> 00:28:23,150

611
00:28:23,150 --> 00:28:27,140
>> But in case you're wondering how I do
that, so Command K, at the very least

612
00:28:27,140 --> 00:28:29,660
in my terminal in the Mac clears it.

613
00:28:29,660 --> 00:28:34,660
Control L generally clears
it for any sort of terminal.

614
00:28:34,660 --> 00:28:36,480
You can also type clear.

615
00:28:36,480 --> 00:28:38,410
And if you ever get
into a weird scenario--

616
00:28:38,410 --> 00:28:42,790
it's happened to me a couple time--
where the colors of your prompts

617
00:28:42,790 --> 00:28:46,590
are all messed up, or you
aren't able to see anything

618
00:28:46,590 --> 00:28:51,232
being typed when you're typing, because
sometimes like background color is set

619
00:28:51,232 --> 00:28:53,940
the same as the foreground color
and now you can't see the fonts.

620
00:28:53,940 --> 00:28:55,110

621
00:28:55,110 --> 00:28:59,830
Reset is something that just resets
you to the default black background,

622
00:28:59,830 --> 00:29:01,840
white front, or whatever
you set them to.

623
00:29:01,840 --> 00:29:03,390

624
00:29:03,390 --> 00:29:04,790
>> So where were we?

625
00:29:04,790 --> 00:29:05,930
Find dot.

626
00:29:05,930 --> 00:29:09,360
So now everything past this
point restricts the results

627
00:29:09,360 --> 00:29:11,450
to something that matches
the given pattern.

628
00:29:11,450 --> 00:29:16,110
So here I want to search
everything with the name cat.

629
00:29:16,110 --> 00:29:17,300
I got nothing.

630
00:29:17,300 --> 00:29:18,390
Why is that the case?

631
00:29:18,390 --> 00:29:21,230
Well, I'm just searching for
something with exactly the name cat.

632
00:29:21,230 --> 00:29:25,150
If I want to search something
that has some pattern, and cat--

633
00:29:25,150 --> 00:29:28,890
the quotes technically aren't necessary,
but I'm throwing them in there.

634
00:29:28,890 --> 00:29:32,720
So now it finds catcat because
that's the only thing that

635
00:29:32,720 --> 00:29:36,040
has some arbitrary
pattern followed by cat.

636
00:29:36,040 --> 00:29:41,950
I can put cat*, and now
find catcat, cat_dog, cat2,

637
00:29:41,950 --> 00:29:45,245
because those are all things with cat
at the beginning followed by anything.

638
00:29:45,245 --> 00:29:46,120
You can combine this.

639
00:29:46,120 --> 00:29:50,480
If you want to search for all C files
that you have, you might do *.c.

640
00:29:50,480 --> 00:29:51,960
We have blah.c here.

641
00:29:51,960 --> 00:29:53,000

642
00:29:53,000 --> 00:29:55,020
So that's a find works.

643
00:29:55,020 --> 00:29:55,770
You can search.

644
00:29:55,770 --> 00:29:58,270
It has a whole bunch of flags
for further restrictions.

645
00:29:58,270 --> 00:30:00,960
And one on them, let's say -d.

646
00:30:00,960 --> 00:30:02,110

647
00:30:02,110 --> 00:30:04,435
So deprecated.

648
00:30:04,435 --> 00:30:05,425

649
00:30:05,425 --> 00:30:06,550
Oh, that's not what I want.

650
00:30:06,550 --> 00:30:07,730
Not -d.

651
00:30:07,730 --> 00:30:08,860
Type d.

652
00:30:08,860 --> 00:30:13,820
So find dot - type d.

653
00:30:13,820 --> 00:30:17,760
So what that just did is I'm searching
for all files in the current directory

654
00:30:17,760 --> 00:30:21,680
with a-- d stands for
directory-- directory type.

655
00:30:21,680 --> 00:30:24,430
This returns all directories
in the current directory.

656
00:30:24,430 --> 00:30:27,670
And type F is all regular
files, all non directories.

657
00:30:27,670 --> 00:30:29,809
So that's just an
example of other ways you

658
00:30:29,809 --> 00:30:32,350
can restrict the search other
than just the name of the file.

659
00:30:32,350 --> 00:30:34,126

660
00:30:34,126 --> 00:30:35,570
>> It's been 30 minutes.

661
00:30:35,570 --> 00:30:36,848
Still going.

662
00:30:36,848 --> 00:30:38,132
>> ALLISON: I'll breeze through.

663
00:30:38,132 --> 00:30:39,670
It'll be fine.

664
00:30:39,670 --> 00:30:41,460
>> ROB BOWDEN: So some other things.

665
00:30:41,460 --> 00:30:45,700
Now bang, exclamation mark.

666
00:30:45,700 --> 00:30:50,530
So that generally means--
well, let's see an example.

667
00:30:50,530 --> 00:30:52,230
So !f, what is that going to do?

668
00:30:52,230 --> 00:30:53,520

669
00:30:53,520 --> 00:30:57,810
Well it seems to have
repeated find dot -type f.

670
00:30:57,810 --> 00:30:59,240
What about !g?

671
00:30:59,240 --> 00:31:00,760
That just grep -r cat*.

672
00:31:00,760 --> 00:31:02,010

673
00:31:02,010 --> 00:31:05,720
So bang you can use to repeat
a recently done command.

674
00:31:05,720 --> 00:31:13,280
So if I type !gre, it's going to re-run
the commands that began with gre most

675
00:31:13,280 --> 00:31:14,060
recently.

676
00:31:14,060 --> 00:31:17,090
>> And you can see all these
commands with history.

677
00:31:17,090 --> 00:31:17,880
So history.

678
00:31:17,880 --> 00:31:19,630
These are all the
commands I've run today.

679
00:31:19,630 --> 00:31:21,089

680
00:31:21,089 --> 00:31:23,130
And well, it's not literally
restricted to today,

681
00:31:23,130 --> 00:31:25,180
but I've only used this
appliance as of today.

682
00:31:25,180 --> 00:31:28,730
It's your entirety of the
history of your bash shell,

683
00:31:28,730 --> 00:31:30,433
except it cuts off at some point.

684
00:31:30,433 --> 00:31:33,474
AUDIENCE: What happens if you do
history [INAUDIBLE] command and an error

685
00:31:33,474 --> 00:31:35,430
in the result will still print the--

686
00:31:35,430 --> 00:31:44,110
>> ROB BOWDEN: Yeah, if there is an
error in one of these commands--

687
00:31:44,110 --> 00:31:48,090
so let's say, that is an
error command not found.

688
00:31:48,090 --> 00:31:49,312

689
00:31:49,312 --> 00:31:50,520
Still appears in the history.

690
00:31:50,520 --> 00:31:52,620

691
00:31:52,620 --> 00:31:53,170
All right.

692
00:31:53,170 --> 00:31:54,750

693
00:31:54,750 --> 00:31:56,040
Other questions on anything?

694
00:31:56,040 --> 00:31:58,760

695
00:31:58,760 --> 00:32:00,300
So that's bang.

696
00:32:00,300 --> 00:32:04,230
>> Now, really useful command, man.

697
00:32:04,230 --> 00:32:07,750
So that gives you the
manual for a given command.

698
00:32:07,750 --> 00:32:11,640
So let's say man ls, so
this is showing me ls.

699
00:32:11,640 --> 00:32:13,400
It lists directory contents.

700
00:32:13,400 --> 00:32:17,150
And this is where I see that there
are these various flags that exist.

701
00:32:17,150 --> 00:32:21,340
So we see that ls -l exists
if we were to read that. ls -l

702
00:32:21,340 --> 00:32:26,150
gives me this full listing of the
directory with who owns the file,

703
00:32:26,150 --> 00:32:29,750
the size of the file, the
the modified timestamp.

704
00:32:29,750 --> 00:32:31,130

705
00:32:31,130 --> 00:32:34,980
So ls -a is another one that you might
actually use somewhat frequently.

706
00:32:34,980 --> 00:32:38,130
-al is my most common flag this past ls.

707
00:32:38,130 --> 00:32:42,520
>> So -a, notice there's a lot
more files than just ls.

708
00:32:42,520 --> 00:32:44,170
ls -a.

709
00:32:44,170 --> 00:32:46,170
What's in common with all these files?

710
00:32:46,170 --> 00:32:47,790
They start with a dot.

711
00:32:47,790 --> 00:32:54,710
So this is a convention in Linux that
files that begin with a dot are hidden.

712
00:32:54,710 --> 00:32:58,330
So it just means that
when we just straight ls,

713
00:32:58,330 --> 00:33:04,170
or we're searching this directory using
the finder equivalent, or the Windows

714
00:33:04,170 --> 00:33:07,250
Explorer equivalent, that we
don't want to see these dot files.

715
00:33:07,250 --> 00:33:09,680
They just pollute the view of things.

716
00:33:09,680 --> 00:33:11,790
So they are hidden
unless you specifically

717
00:33:11,790 --> 00:33:14,250
request them with something like -a.

718
00:33:14,250 --> 00:33:18,920
So I can cd into .local, and I see
that that is itself a directory with

719
00:33:18,920 --> 00:33:22,220
a shared directory, and
applications, and blah blah blah.

720
00:33:22,220 --> 00:33:24,520
So dot, files they're just hidden.

721
00:33:24,520 --> 00:33:26,250

722
00:33:26,250 --> 00:33:29,355
>> OK, so other important ones.

723
00:33:29,355 --> 00:33:30,490

724
00:33:30,490 --> 00:33:32,000
I have a couple I can skip.

725
00:33:32,000 --> 00:33:38,160
Let's just real quick talk about
the file redirection things.

726
00:33:38,160 --> 00:33:43,020
So there's a whole complex series
of things you can do with these,

727
00:33:43,020 --> 00:33:47,204
but just to see them, let's say, echo.

728
00:33:47,204 --> 00:33:47,870
Another command.

729
00:33:47,870 --> 00:33:48,920
Really dumb command.

730
00:33:48,920 --> 00:33:50,710
All it does is print what I tell it to.

731
00:33:50,710 --> 00:33:52,070
So echo hello.

732
00:33:52,070 --> 00:33:53,850
It just echoed hello to the screen.

733
00:33:53,850 --> 00:33:55,170

734
00:33:55,170 --> 00:33:56,390
Hello world.

735
00:33:56,390 --> 00:33:57,890
Echoes hello world.

736
00:33:57,890 --> 00:34:02,650
>> So one command or one
symbol that bash understands

737
00:34:02,650 --> 00:34:07,620
is this greater than symbol, and
that is the output to a file symbol.

738
00:34:07,620 --> 00:34:10,940
So if I output this to
foo, there's now a file

739
00:34:10,940 --> 00:34:15,100
called foo, inside of
which is hello world.

740
00:34:15,100 --> 00:34:18,489
So notice that when I echo
hello world pipe into foo,

741
00:34:18,489 --> 00:34:19,980
it didn't echo hello world.

742
00:34:19,980 --> 00:34:22,630
Instead it was put into file foo.

743
00:34:22,630 --> 00:34:25,340
And another command just
to throw it at you, cat.

744
00:34:25,340 --> 00:34:29,191
That's an easy way to just completely
list the contents of the file

745
00:34:29,191 --> 00:34:31,440
so that I don't have to open
a text editor to view it.

746
00:34:31,440 --> 00:34:34,159
So the contents of the
foo file are hello world.

747
00:34:34,159 --> 00:34:38,460
And I could cat blah.c,
the contents are this.

748
00:34:38,460 --> 00:34:42,123
>> Again, these are commands that, don't
expect you have them all memorized.

749
00:34:42,123 --> 00:34:43,860
The idea is you've seen them.

750
00:34:43,860 --> 00:34:45,735
Maybe you're working on
something, and you're

751
00:34:45,735 --> 00:34:47,230
like I'm sick of opening this file.

752
00:34:47,230 --> 00:34:50,120
I wish I could just look
at the contents real quick.

753
00:34:50,120 --> 00:34:52,320
You could do that, then
look back and say oh I

754
00:34:52,320 --> 00:34:55,250
remember something like
that exists, and it's cat.

755
00:34:55,250 --> 00:35:00,630
>> So that is going to a file.

756
00:35:00,630 --> 00:35:06,639
Now there isn't really any good
example of reading from a file yet.

757
00:35:06,639 --> 00:35:08,930
What's something that takes
something from standard in?

758
00:35:08,930 --> 00:35:10,010

759
00:35:10,010 --> 00:35:11,544
Any simple Linux command?

760
00:35:11,544 --> 00:35:13,480

761
00:35:13,480 --> 00:35:16,970
When we get to it, in a couple
weeks all the piece-- well,

762
00:35:16,970 --> 00:35:20,470
this week you have a piece where you
start taking input from the user.

763
00:35:20,470 --> 00:35:23,696
And so usually you type
that input at the keyboard.

764
00:35:23,696 --> 00:35:25,570
Instead of typing that
input at the keyboard,

765
00:35:25,570 --> 00:35:30,950
you can instead pipe in from a file
so that when you do Mario, ./mario,

766
00:35:30,950 --> 00:35:35,200
pipe in from any given file, and
that's going to run the mario program.

767
00:35:35,200 --> 00:35:37,300
Not expecting input at
the keyboard, instead it's

768
00:35:37,300 --> 00:35:39,650
just going to read the
lines from the foo file.

769
00:35:39,650 --> 00:35:45,230
>> So greater than foo puts it into
the foo file, and less than foo

770
00:35:45,230 --> 00:35:50,170
takes stuff from the foo file and
uses that as input to this program.

771
00:35:50,170 --> 00:35:51,520

772
00:35:51,520 --> 00:36:00,630
And just to see it, we could also echo
foo bar baz, and then instead of one

773
00:36:00,630 --> 00:36:03,850
greater than, let's do two into foo.

774
00:36:03,850 --> 00:36:05,610
What does that do?

775
00:36:05,610 --> 00:36:07,180
It just appends to the file.

776
00:36:07,180 --> 00:36:15,360
So instead notice if I do echo blah into
foo and then cat foo, it's just blah.

777
00:36:15,360 --> 00:36:18,285
So when you output to a file, it
completely overwrites that file.

778
00:36:18,285 --> 00:36:19,330

779
00:36:19,330 --> 00:36:22,740
If you just want to append,
double [? grader. ?]

780
00:36:22,740 --> 00:36:24,080
>> And last is pipe.

781
00:36:24,080 --> 00:36:29,590
Pipe Gets much more complicated, where
it takes the output of one command

782
00:36:29,590 --> 00:36:32,320
and feeds it into the next command.

783
00:36:32,320 --> 00:36:36,140
So some common thing, history.

784
00:36:36,140 --> 00:36:37,920
So, ugh, I don't want to look at this.

785
00:36:37,920 --> 00:36:40,680

786
00:36:40,680 --> 00:36:44,485
Show me all commands in my history
where I grep-ed for something.

787
00:36:44,485 --> 00:36:45,360
No, that's confusing.

788
00:36:45,360 --> 00:36:50,360
Show me all commands where I find.

789
00:36:50,360 --> 00:36:52,360
All find commands I ever ran.

790
00:36:52,360 --> 00:36:55,050
>> So history.

791
00:36:55,050 --> 00:36:59,017
Now history outputs to the
screen this list of commands,

792
00:36:59,017 --> 00:37:00,850
but I don't want to
output it to the screen.

793
00:37:00,850 --> 00:37:03,445
Instead I'm going to pipe it into grep.

794
00:37:03,445 --> 00:37:04,790

795
00:37:04,790 --> 00:37:07,830
So let's grep for all instances of find.

796
00:37:07,830 --> 00:37:09,550

797
00:37:09,550 --> 00:37:17,000
So now instead of grep taking
the input, instead of--

798
00:37:17,000 --> 00:37:24,360
grep is able to handle as input-- we're
using grep slightly differently here.

799
00:37:24,360 --> 00:37:29,550
So instead of typing the list of
things we wanted to search for

800
00:37:29,550 --> 00:37:31,070
and said grep is taking as input.

801
00:37:31,070 --> 00:37:34,810
So if I do just grep find, it
waits for me to type things.

802
00:37:34,810 --> 00:37:37,661
So cat hello find.

803
00:37:37,661 --> 00:37:38,160
Hello.

804
00:37:38,160 --> 00:37:40,430

805
00:37:40,430 --> 00:37:40,930
Find.

806
00:37:40,930 --> 00:37:43,670
Notice every time I type find
it recognizes that I typed find.

807
00:37:43,670 --> 00:37:44,880

808
00:37:44,880 --> 00:37:49,540
So instead of this, will
search files for find.

809
00:37:49,540 --> 00:37:53,930
>> So history is now going to
output a list of all commands.

810
00:37:53,930 --> 00:37:55,200

811
00:37:55,200 --> 00:37:58,100
We're putting that output,
and we're feeding it to grep,

812
00:37:58,100 --> 00:38:00,180
and so it's spitting out
all instances of find.

813
00:38:00,180 --> 00:38:02,170

814
00:38:02,170 --> 00:38:05,570
The reason I said it'd be confusing
is if I-- it's still confusing.

815
00:38:05,570 --> 00:38:07,030
If I grep for grep.

816
00:38:07,030 --> 00:38:08,755

817
00:38:08,755 --> 00:38:11,130
Notice it's pretty much always
showing the command I just

818
00:38:11,130 --> 00:38:15,280
ran because that command
itself has grep inside of it.

819
00:38:15,280 --> 00:38:16,580

820
00:38:16,580 --> 00:38:20,674
>> OK, so any questions on anything?

821
00:38:20,674 --> 00:38:22,340
And I'll transfer it over at this point.

822
00:38:22,340 --> 00:38:24,690
Hopefully this is a nice
overview of all commands

823
00:38:24,690 --> 00:38:30,100
that you don't need to have
memorized, but these make up

824
00:38:30,100 --> 00:38:32,950
a solid 95% of what I
do at the command line.

825
00:38:32,950 --> 00:38:34,310

826
00:38:34,310 --> 00:38:39,140
Also keep in mind that the command line
itself, bash is a programming language,

827
00:38:39,140 --> 00:38:43,070
and so when you get down to it, you
might want to do really complex things.

828
00:38:43,070 --> 00:38:47,522
And so it has things like
loops, and ifs, and all of those

829
00:38:47,522 --> 00:38:50,230
that you're going to get used to
with your programming languages.

830
00:38:50,230 --> 00:38:53,660
But that is beyond the
scope of this section.

831
00:38:53,660 --> 00:38:55,520

832
00:38:55,520 --> 00:38:56,985
OK, so no questions?

833
00:38:56,985 --> 00:38:57,940

834
00:38:57,940 --> 00:38:58,523
ALLISON: None?

835
00:38:58,523 --> 00:38:59,450
GABRIEL: Are you going to--

836
00:38:59,450 --> 00:39:01,158
ALLISON: I can do it
on mine if you want.

837
00:39:01,158 --> 00:39:02,626
We can see what happens.

838
00:39:02,626 --> 00:39:03,750
ROB BOWDEN: Off to Allison.

839
00:39:03,750 --> 00:39:05,090
ALLISON: Woo.

840
00:39:05,090 --> 00:39:07,504
You're a hard act to follow, Rob.

841
00:39:07,504 --> 00:39:08,920
Do you want me to switch with you?

842
00:39:08,920 --> 00:39:10,246
Or you got, OK.

843
00:39:10,246 --> 00:39:13,590

844
00:39:13,590 --> 00:39:16,990
I'm going to try and not
quite be as lengthy there.

845
00:39:16,990 --> 00:39:20,619

846
00:39:20,619 --> 00:39:22,660
Let's see if this will
work the way I want it to.

847
00:39:22,660 --> 00:39:26,170

848
00:39:26,170 --> 00:39:26,670
Maybe?

849
00:39:26,670 --> 00:39:27,760

850
00:39:27,760 --> 00:39:28,296
Haha!

851
00:39:28,296 --> 00:39:28,796
Yes.

852
00:39:28,796 --> 00:39:30,460

853
00:39:30,460 --> 00:39:34,066
>> So I'm just going to very quickly go
through variables, loops, conditionals,

854
00:39:34,066 --> 00:39:35,440
and a little bit on the compiler.

855
00:39:35,440 --> 00:39:38,570
If you have questions at
any time, please stop me.

856
00:39:38,570 --> 00:39:42,750
These guys will remind me to repeat
your question in case I forget,

857
00:39:42,750 --> 00:39:44,210
but shouldn't be too bad.

858
00:39:44,210 --> 00:39:45,850
>> So variables, yeah.

859
00:39:45,850 --> 00:39:48,060
We have no one of your
Scratch pieces here.

860
00:39:48,060 --> 00:39:50,440
I'm sure most of you, if
you had some sort of game

861
00:39:50,440 --> 00:39:53,810
that you created with Scratch, you had
to keep track of something like score,

862
00:39:53,810 --> 00:39:55,870
or time, or something like that.

863
00:39:55,870 --> 00:39:58,080
So those bright orange
pieces that we see there

864
00:39:58,080 --> 00:40:02,630
are just the Scratch form of
variables, and you will definitely

865
00:40:02,630 --> 00:40:04,640
be using variables
throughout your programs.

866
00:40:04,640 --> 00:40:07,350
If you're not, I'm not really
sure what you're doing.

867
00:40:07,350 --> 00:40:09,000

868
00:40:09,000 --> 00:40:12,215
>> But anyway, big thing,
defining variables.

869
00:40:12,215 --> 00:40:13,630

870
00:40:13,630 --> 00:40:16,970
With C every variable has
to have a type declared,

871
00:40:16,970 --> 00:40:22,090
so I gave you a very
general one at the top.

872
00:40:22,090 --> 00:40:24,045
So you'll have your
type and then whatever

873
00:40:24,045 --> 00:40:25,420
you decide to call your variable.

874
00:40:25,420 --> 00:40:27,500

875
00:40:27,500 --> 00:40:29,680
So in this case, type
in your variable list.

876
00:40:29,680 --> 00:40:31,400
>> We have three examples.

877
00:40:31,400 --> 00:40:34,439
Char of some grade,
of an A, which is what

878
00:40:34,439 --> 00:40:36,230
I'm sure you all want
to get in this class.

879
00:40:36,230 --> 00:40:37,380

880
00:40:37,380 --> 00:40:40,670
You can define multiple
variables on one line

881
00:40:40,670 --> 00:40:43,880
as long as they're all the same type,
which is our second example there

882
00:40:43,880 --> 00:40:46,409
where you have three
variables, x, y, and z.

883
00:40:46,409 --> 00:40:47,200
They're all floats.

884
00:40:47,200 --> 00:40:49,160

885
00:40:49,160 --> 00:40:53,250
And then you can also, in this last
example with int score and number

886
00:40:53,250 --> 00:40:56,510
of teams, you can
initialize them right there.

887
00:40:56,510 --> 00:41:01,270
>> So in the middle example where we
just have float of x, y, and z,

888
00:41:01,270 --> 00:41:02,730
those are not initialized yet.

889
00:41:02,730 --> 00:41:04,140
They have no value.

890
00:41:04,140 --> 00:41:05,600
Or they have garbage values.

891
00:41:05,600 --> 00:41:07,370

892
00:41:07,370 --> 00:41:10,790
And if you try and use them,
the compiler will yell at you.

893
00:41:10,790 --> 00:41:14,727
You have to both declare and
initialize your variables.

894
00:41:14,727 --> 00:41:16,310
So in this last one, we're doing both.

895
00:41:16,310 --> 00:41:19,320
We are declaring variables
of score and number of teams,

896
00:41:19,320 --> 00:41:24,134
and we are initializing them, giving
them their initial values of 7 and 4

897
00:41:24,134 --> 00:41:24,675
respectively.

898
00:41:24,675 --> 00:41:26,310

899
00:41:26,310 --> 00:41:27,190
Cool.

900
00:41:27,190 --> 00:41:28,550
Everyone good?

901
00:41:28,550 --> 00:41:29,470
Awesome.

902
00:41:29,470 --> 00:41:31,690
>> OK, so some conventions.

903
00:41:31,690 --> 00:41:35,965
If you guys have read
through style 50, these

904
00:41:35,965 --> 00:41:39,510
are just things that we'd like for
you to implement in your style.

905
00:41:39,510 --> 00:41:41,230
So meaningful names.

906
00:41:41,230 --> 00:41:45,700
If you start calling things
just x, y, and z, especially

907
00:41:45,700 --> 00:41:47,902
as you get into lengthier
programs, you're

908
00:41:47,902 --> 00:41:49,610
probably going to
confuse yourself and be

909
00:41:49,610 --> 00:41:52,930
like what is this variable referring to.

910
00:41:52,930 --> 00:41:55,880
I have no idea what this means.

911
00:41:55,880 --> 00:41:59,280
>> So if it's meant to hold
a score, call it score.

912
00:41:59,280 --> 00:42:05,720
If it's meant to hold some answer
or result, give it a name like that.

913
00:42:05,720 --> 00:42:09,920
For loops, which we will
get into in the next slide,

914
00:42:09,920 --> 00:42:12,985
single letter variables are fine.

915
00:42:12,985 --> 00:42:16,033

916
00:42:16,033 --> 00:42:18,449
ROB BOWDEN: I, j, and k are
just conventions for for loops

917
00:42:18,449 --> 00:42:22,050
that everyone expects them
to be called i, j, and k.

918
00:42:22,050 --> 00:42:26,890
You can call them-- I see row
column or row call sometimes

919
00:42:26,890 --> 00:42:29,450
for two nested loops, and
that's also kind of standard.

920
00:42:29,450 --> 00:42:31,450
But i and j is completely understood.

921
00:42:31,450 --> 00:42:33,670
>> ALLISON: Yeah, i and
j you're totally fine.

922
00:42:33,670 --> 00:42:36,250
For sake of clarity like
in some of your P sets,

923
00:42:36,250 --> 00:42:39,745
it might make sense to have more
descriptive things in there just

924
00:42:39,745 --> 00:42:40,920
to keep track of it.

925
00:42:40,920 --> 00:42:45,100
But I think i, j, and k I think
the vast majority of us all use.

926
00:42:45,100 --> 00:42:46,890

927
00:42:46,890 --> 00:42:50,340
>> ROB BOWDEN: With these
conventions, so style is important.

928
00:42:50,340 --> 00:42:53,520
It's one of the four axes
on which you're graded,

929
00:42:53,520 --> 00:42:58,110
and it is so easy to just go over
your P set at the end and make sure

930
00:42:58,110 --> 00:42:59,770
that there aren't stylistic mistakes.

931
00:42:59,770 --> 00:43:01,742
So make sure you're tabbing correctly.

932
00:43:01,742 --> 00:43:03,200
Make sure your variables are named.

933
00:43:03,200 --> 00:43:04,450
Leave some comments.

934
00:43:04,450 --> 00:43:06,677
It is very easy to get those points.

935
00:43:06,677 --> 00:43:09,510
You don't have to think about
anything in order to get those points.

936
00:43:09,510 --> 00:43:11,093
You don't have to figure anything out.

937
00:43:11,093 --> 00:43:12,640
It's just making it look pretty.

938
00:43:12,640 --> 00:43:14,850
>> ALLISON: In fact, we
have style 50, which

939
00:43:14,850 --> 00:43:17,920
will tell you where you're messing
up if you're messing up on style

940
00:43:17,920 --> 00:43:21,180
and will tell you exactly what you
need to fix and how you need to fix it.

941
00:43:21,180 --> 00:43:23,900
It's also just good to mention
that it's course policy

942
00:43:23,900 --> 00:43:27,200
that if you're at office
hours and your code is a mess,

943
00:43:27,200 --> 00:43:30,200
we can decline to help
you until it looks nicer.

944
00:43:30,200 --> 00:43:34,310
So start out right,
keep consistent style,

945
00:43:34,310 --> 00:43:37,100
you're also just going to make
your lives a whole lot easier when

946
00:43:37,100 --> 00:43:38,730
you're trying to go through debug.

947
00:43:38,730 --> 00:43:41,510
If you're trying to figure out
where you're missing a curly brace

948
00:43:41,510 --> 00:43:44,890
and they are all over the place, you're
just making your own life harder.

949
00:43:44,890 --> 00:43:47,217
So be consistent with style.

950
00:43:47,217 --> 00:43:48,800
I promise it'll make your life easier.

951
00:43:48,800 --> 00:43:50,330
It'll make our lives easier.

952
00:43:50,330 --> 00:43:51,869
Everyone will be much happier.

953
00:43:51,869 --> 00:43:52,910
And that's what you want.

954
00:43:52,910 --> 00:43:54,192

955
00:43:54,192 --> 00:43:55,650
GABRIEL: Your grade will be higher.

956
00:43:55,650 --> 00:43:56,858
ALLISON: Yes, and your grade.

957
00:43:56,858 --> 00:43:58,410

958
00:43:58,410 --> 00:44:01,930
If your TF's like you,
tends to be favorable.

959
00:44:01,930 --> 00:44:02,940

960
00:44:02,940 --> 00:44:05,010
All right, and then just
the second point here.

961
00:44:05,010 --> 00:44:06,300
Consistent initializations.

962
00:44:06,300 --> 00:44:09,605
So as we saw, you can declare
and initialize things.

963
00:44:09,605 --> 00:44:10,750

964
00:44:10,750 --> 00:44:13,180
Multiple variables on the same line.

965
00:44:13,180 --> 00:44:17,930
One thing we would like you not
to do is to declare some variables

966
00:44:17,930 --> 00:44:21,360
and not initialize them on the same
line that you are initializing others.

967
00:44:21,360 --> 00:44:23,960
>> So in case that made
no sense whatsoever,

968
00:44:23,960 --> 00:44:29,050
we have the example here
where we're declaring ints

969
00:44:29,050 --> 00:44:31,180
in variables of quarters
dimes and pennies,

970
00:44:31,180 --> 00:44:34,214
but quarters and pennies
have no initial value.

971
00:44:34,214 --> 00:44:36,630
We haven't initialized them,
but right in the middle there

972
00:44:36,630 --> 00:44:38,600
we already initialized dimes to 0.

973
00:44:38,600 --> 00:44:41,650
So either do quarters, dimes, pennies.

974
00:44:41,650 --> 00:44:43,170
Or do quarters equal 0.

975
00:44:43,170 --> 00:44:43,930
Dimes equal 0.

976
00:44:43,930 --> 00:44:46,810
Pennies equal 0, or whatever
those initial values are.

977
00:44:46,810 --> 00:44:49,800
>> Big thing with style, be consistent.

978
00:44:49,800 --> 00:44:51,050
When in doubt, be consistent.

979
00:44:51,050 --> 00:44:52,129

980
00:44:52,129 --> 00:44:53,420
But follow our style guide too.

981
00:44:53,420 --> 00:44:54,710

982
00:44:54,710 --> 00:44:55,317
Cool.

983
00:44:55,317 --> 00:44:56,150
Everyone good there?

984
00:44:56,150 --> 00:44:57,566
>> AUDIENCE: Where's the style guide?

985
00:44:57,566 --> 00:45:00,800
ALLISON: The style guide
is on-- what's the website?

986
00:45:00,800 --> 00:45:03,950
>> GABRIEL: I think it's manual.cs50.net/--

987
00:45:03,950 --> 00:45:04,575
ALLISON: Style?

988
00:45:04,575 --> 00:45:05,610

989
00:45:05,610 --> 00:45:06,390
>> GABRIEL: Style.

990
00:45:06,390 --> 00:45:06,920
Yep.

991
00:45:06,920 --> 00:45:07,520
>> ALLISON: Yes.

992
00:45:07,520 --> 00:45:10,150
So question, where is style 50.

993
00:45:10,150 --> 00:45:12,250
manual.cs50.net/style.

994
00:45:12,250 --> 00:45:13,639
Yes?

995
00:45:13,639 --> 00:45:16,880
>> AUDIENCE: If we're defining
variables, is it OK

996
00:45:16,880 --> 00:45:28,145
if we put like [INAUDIBLE] like
int score and then int goal.

997
00:45:28,145 --> 00:45:29,873

998
00:45:29,873 --> 00:45:35,100
So would you say that now we've
got to define them together?

999
00:45:35,100 --> 00:45:37,640
>> ALLISON: So question, should
you have redundant code

1000
00:45:37,640 --> 00:45:40,940
when you are defining
variables such as int score and

1001
00:45:40,940 --> 00:45:43,239
on the next line int game?

1002
00:45:43,239 --> 00:45:46,030
ROB BOWDEN: There are definitely
cases where redundant code is bad.

1003
00:45:46,030 --> 00:45:47,738
I would not consider
that redundant code.

1004
00:45:47,738 --> 00:45:50,970
I almost never declare multiple
variables on the same line ever.

1005
00:45:50,970 --> 00:45:53,736
And if anything, it's because
usually I leave some sort of comment

1006
00:45:53,736 --> 00:45:55,235
explaining what the variable is for.

1007
00:45:55,235 --> 00:45:57,582
So I'll say int score slash slash.

1008
00:45:57,582 --> 00:45:59,350
Keeps track of whatever.

1009
00:45:59,350 --> 00:46:00,710
In total slash slash.

1010
00:46:00,710 --> 00:46:01,790

1011
00:46:01,790 --> 00:46:06,455
So it's much grosser in that way
to put them all on the same line.

1012
00:46:06,455 --> 00:46:08,080
I just never put them on the same line.

1013
00:46:08,080 --> 00:46:10,580
>> ALLISON: I feel like it's
personal preference at this point.

1014
00:46:10,580 --> 00:46:14,900
>> AUDIENCE: Does that go for
for loops and stuff too?

1015
00:46:14,900 --> 00:46:15,900
ROB BOWDEN: Like inside?

1016
00:46:15,900 --> 00:46:18,282
Like int i equals 0 comma
length equals something?

1017
00:46:18,282 --> 00:46:19,490
That you don't have a choice.

1018
00:46:19,490 --> 00:46:21,850

1019
00:46:21,850 --> 00:46:25,910
With for loops the initialization
part-- so you might have only seen

1020
00:46:25,910 --> 00:46:31,520
int i equals 0 semicolon i less
than whatever semicolon i plus plus.

1021
00:46:31,520 --> 00:46:33,820
That int i equals 0,
technically you can also

1022
00:46:33,820 --> 00:46:35,770
do what we saw before
with the comma syntax.

1023
00:46:35,770 --> 00:46:39,790
int i equals 0 comma j
equals 3 comma k equals 5.

1024
00:46:39,790 --> 00:46:41,610

1025
00:46:41,610 --> 00:46:44,320
You don't have a choice to split
that up into multiple lines,

1026
00:46:44,320 --> 00:46:46,530
and that's standard.

1027
00:46:46,530 --> 00:46:47,780
Seeing it there is fine.

1028
00:46:47,780 --> 00:46:49,182

1029
00:46:49,182 --> 00:46:49,890
ALLISON: Awesome.

1030
00:46:49,890 --> 00:46:52,120
Well, convenient segue into loops.

1031
00:46:52,120 --> 00:46:54,860

1032
00:46:54,860 --> 00:46:58,980
So yeah, here we have some examples
of loops that you guys saw in Scratch.

1033
00:46:58,980 --> 00:47:01,550
And of course all of these
can just be recreated in C.

1034
00:47:01,550 --> 00:47:04,610
And they basically allow you
to repeat some section of code

1035
00:47:04,610 --> 00:47:06,740
until a certain condition
is met, which we'll

1036
00:47:06,740 --> 00:47:09,198
get into right after talking
about loops with conditionals.

1037
00:47:09,198 --> 00:47:11,150

1038
00:47:11,150 --> 00:47:12,570
>> So we have three main types.

1039
00:47:12,570 --> 00:47:17,500
For, while, and do while, which
we will all go through right now.

1040
00:47:17,500 --> 00:47:18,860
So first one is for loops.

1041
00:47:18,860 --> 00:47:20,490

1042
00:47:20,490 --> 00:47:25,034
So for some condition,
execute this block of code.

1043
00:47:25,034 --> 00:47:27,200
We have this cool little
diagram here at the bottom.

1044
00:47:27,200 --> 00:47:28,230

1045
00:47:28,230 --> 00:47:32,310
But basically you have in
your for, that first line,

1046
00:47:32,310 --> 00:47:34,240
you're going to
initialize your variables.

1047
00:47:34,240 --> 00:47:38,260
>> So as we talked about, i is
equal to 0 or i is equal to 10.

1048
00:47:38,260 --> 00:47:40,010
Whatever you need that
variable to be it's

1049
00:47:40,010 --> 00:47:43,970
going to be initialized there,
declared and initialized to some value.

1050
00:47:43,970 --> 00:47:46,760
So then we have some
condition that's going

1051
00:47:46,760 --> 00:47:48,900
to be checking our
variable against something.

1052
00:47:48,900 --> 00:47:55,220
So in the case the typical case where
maybe you want this section of code

1053
00:47:55,220 --> 00:47:56,620
to execute five times.

1054
00:47:56,620 --> 00:48:02,380
So we'd have int i equals 0, and we
want it to be when i is less than 5.

1055
00:48:02,380 --> 00:48:04,940
So that condition is just
going to check that every time.

1056
00:48:04,940 --> 00:48:07,120
If that condition
evaluates to true, it's

1057
00:48:07,120 --> 00:48:11,162
going to run the code, which is exactly
what this little diagram is showing.

1058
00:48:11,162 --> 00:48:12,370

1059
00:48:12,370 --> 00:48:13,639
>> And so it executes it.

1060
00:48:13,639 --> 00:48:15,430
It updates a variable,
which is what we see

1061
00:48:15,430 --> 00:48:21,020
in the last part of our for
loop initialization there.

1062
00:48:21,020 --> 00:48:22,370

1063
00:48:22,370 --> 00:48:26,030
So it'll just keep doing this
until that condition is not met,

1064
00:48:26,030 --> 00:48:28,010
and then it will exit
the loop and continue

1065
00:48:28,010 --> 00:48:29,960
moving on with the rest of your program.

1066
00:48:29,960 --> 00:48:31,320

1067
00:48:31,320 --> 00:48:33,620
Everyone good there?

1068
00:48:33,620 --> 00:48:34,440
Cool.

1069
00:48:34,440 --> 00:48:37,780
>> So here's an example, very similar
to something I just talked about.

1070
00:48:37,780 --> 00:48:42,030
So we just want to print
this is CS50 10 times.

1071
00:48:42,030 --> 00:48:44,540
So you see here we have
our for, and then we

1072
00:48:44,540 --> 00:48:47,450
initialize the variable
i to be equal to 0.

1073
00:48:47,450 --> 00:48:50,610
Our condition is checking
that it's less than 10.

1074
00:48:50,610 --> 00:48:55,210
So evaluate to true when we first
start, and then updates our variable

1075
00:48:55,210 --> 00:48:58,985
each time that it actually executes
and prints out this is CS50.

1076
00:48:58,985 --> 00:49:00,510

1077
00:49:00,510 --> 00:49:02,180
And will terminate after 10 times.

1078
00:49:02,180 --> 00:49:03,190

1079
00:49:03,190 --> 00:49:04,070
Cool.

1080
00:49:04,070 --> 00:49:07,130
>> So while loops are up next.

1081
00:49:07,130 --> 00:49:12,400
And as you see here, we just have
some while this condition-- question?

1082
00:49:12,400 --> 00:49:15,238
>> AUDIENCE: How can I jump
actually just not one number,

1083
00:49:15,238 --> 00:49:19,030
but two numbers [INAUDIBLE]
i plus plus plus?

1084
00:49:19,030 --> 00:49:23,390
>> ALLISON: So the question was how can you
update your variable by more than one

1085
00:49:23,390 --> 00:49:24,070
at a time.

1086
00:49:24,070 --> 00:49:26,860
So i plus plus will
update by one each time.

1087
00:49:26,860 --> 00:49:32,310
If you wanted to update it by
two, you could do i plus equals 2.

1088
00:49:32,310 --> 00:49:34,526
>> ROB BOWDEN: Have you seen
plus equals in lecture yet?

1089
00:49:34,526 --> 00:49:35,442
>> AUDIENCE: [INAUDIBLE].

1090
00:49:35,442 --> 00:49:37,440

1091
00:49:37,440 --> 00:49:42,110
>> ALLISON: It's effectively the
same thing as i equals i plus 2.

1092
00:49:42,110 --> 00:49:46,130
So it's going to take it and
update it by two each time.

1093
00:49:46,130 --> 00:49:49,432
Plus equals is just something
we call syntactic sugar.

1094
00:49:49,432 --> 00:49:52,390
ROB BOWDEN: Yeah, those exist for
pretty much all arithmetic operators.

1095
00:49:52,390 --> 00:49:55,830
So i times equal to
would double the number.

1096
00:49:55,830 --> 00:50:02,590
j divide equals 3 is the same
as j equals j divided by 3.

1097
00:50:02,590 --> 00:50:07,399
>> ALLISON: Or minus equals 2 would
decrement i by two each time.

1098
00:50:07,399 --> 00:50:08,565
ROB BOWDEN: Even mod equals.

1099
00:50:08,565 --> 00:50:09,690

1100
00:50:09,690 --> 00:50:13,270
You haven't seen bitwise operators,
but caret equals and ampersand equals,

1101
00:50:13,270 --> 00:50:14,560
all of those exist.

1102
00:50:14,560 --> 00:50:19,480
>> ALLISON: So a lot of times, especially
with your first couple of P sets,

1103
00:50:19,480 --> 00:50:22,527
you'll be probably incrementing by
one, so i plus plus, j plus plus

1104
00:50:22,527 --> 00:50:24,610
are all things you're going
to typically be using.

1105
00:50:24,610 --> 00:50:28,240
But that update condition is
fully within your control.

1106
00:50:28,240 --> 00:50:32,310
You can update it by whatever increments
or in whatever way you decide to.

1107
00:50:32,310 --> 00:50:33,389

1108
00:50:33,389 --> 00:50:35,680
Maybe you even want it to be
a random number sometimes.

1109
00:50:35,680 --> 00:50:37,180

1110
00:50:37,180 --> 00:50:39,580
But yes, there are lots of
things you can do with that.

1111
00:50:39,580 --> 00:50:41,280
You're not restricted to i plus plus.

1112
00:50:41,280 --> 00:50:44,400
>> ROB BOWDEN: Just so you
know it exists, it also

1113
00:50:44,400 --> 00:50:46,960
exists in another form, plus plus i.

1114
00:50:46,960 --> 00:50:51,410
So if you're ever searching online
and happen to see plus plus i,

1115
00:50:51,410 --> 00:50:52,870
pretty much means the same thing.

1116
00:50:52,870 --> 00:50:54,377

1117
00:50:54,377 --> 00:50:54,960
ALLISON: Cool.

1118
00:50:54,960 --> 00:50:56,070

1119
00:50:56,070 --> 00:50:56,740
Good?

1120
00:50:56,740 --> 00:50:57,240
Awesome.

1121
00:50:57,240 --> 00:50:59,190

1122
00:50:59,190 --> 00:50:59,990
So while loops.

1123
00:50:59,990 --> 00:51:01,160

1124
00:51:01,160 --> 00:51:02,570
Very similar.

1125
00:51:02,570 --> 00:51:03,737
You have some condition.

1126
00:51:03,737 --> 00:51:05,820
The main thing to notice
here is instead of having

1127
00:51:05,820 --> 00:51:08,540
three different parts
to set up, we have one.

1128
00:51:08,540 --> 00:51:11,090
We just have some condition
that's being checked.

1129
00:51:11,090 --> 00:51:14,920
And in the same way, as long as
that condition evaluates to true,

1130
00:51:14,920 --> 00:51:16,840
your code is going to run.

1131
00:51:16,840 --> 00:51:18,870
And if it's false, it
will terminate, move

1132
00:51:18,870 --> 00:51:21,930
onto the next part of your program.

1133
00:51:21,930 --> 00:51:25,780
So this is kind of like-- what's
a good example of checking

1134
00:51:25,780 --> 00:51:27,215
for some normal condition?

1135
00:51:27,215 --> 00:51:29,402

1136
00:51:29,402 --> 00:51:30,235
GABRIEL: While true.

1137
00:51:30,235 --> 00:51:32,110
ALLISON: You could do while true.

1138
00:51:32,110 --> 00:51:33,510
Well, 1 is equal to 1.

1139
00:51:33,510 --> 00:51:34,970

1140
00:51:34,970 --> 00:51:37,642
>> ROB BOWDEN: You can do while--
just instead of using a for loop,

1141
00:51:37,642 --> 00:51:39,600
you can always code a
for loop in a while loop,

1142
00:51:39,600 --> 00:51:42,600
so i greater than 0 or
while i less than 10.

1143
00:51:42,600 --> 00:51:45,200

1144
00:51:45,200 --> 00:51:46,010
>> ALLISON: Awesome.

1145
00:51:46,010 --> 00:51:50,640
And then we have do while loops, which
is great for user validation, where

1146
00:51:50,640 --> 00:51:55,370
you want to get something from
your user, see if it's valid,

1147
00:51:55,370 --> 00:51:57,060
and then continue from there.

1148
00:51:57,060 --> 00:52:04,000
So one of the things to know is with a
do while is that it's going to execute,

1149
00:52:04,000 --> 00:52:08,000
and then it will re-execute
if this condition is met.

1150
00:52:08,000 --> 00:52:11,240
>> So probably the best way to do this
is just to see an example here.

1151
00:52:11,240 --> 00:52:14,620
So as I just mentioned, user
validation is really useful--

1152
00:52:14,620 --> 00:52:17,520
or do whiles are really
useful with user validation.

1153
00:52:17,520 --> 00:52:19,730
So this is just going
to re-prompt some user

1154
00:52:19,730 --> 00:52:23,640
until they enter a positive number,
which might be useful for your P set

1155
00:52:23,640 --> 00:52:24,190
this week.

1156
00:52:24,190 --> 00:52:25,850

1157
00:52:25,850 --> 00:52:29,480
And so in this case, when we
initially run this program,

1158
00:52:29,480 --> 00:52:32,260
it's going to print
enter a positive number.

1159
00:52:32,260 --> 00:52:34,810
It's going to get some
input from the user,

1160
00:52:34,810 --> 00:52:38,320
and then it's going to check
that input against the condition

1161
00:52:38,320 --> 00:52:39,500
that you've set for it.

1162
00:52:39,500 --> 00:52:41,030
>> So in this case it's going to check.

1163
00:52:41,030 --> 00:52:44,190
It's going to say, OK,
is our input negative,

1164
00:52:44,190 --> 00:52:47,175
or is it 0 or negative,
which would be invalid.

1165
00:52:47,175 --> 00:52:48,300
So then it would re-prompt.

1166
00:52:48,300 --> 00:52:50,280

1167
00:52:50,280 --> 00:52:50,780
Question?

1168
00:52:50,780 --> 00:52:54,720
>> AUDIENCE: Is this the same then as a
while loop if you just copied that code

1169
00:52:54,720 --> 00:52:56,680
and put it [INAUDIBLE] while loop?

1170
00:52:56,680 --> 00:52:59,620

1171
00:52:59,620 --> 00:53:05,160
>> ALLISON: So question was would
this be the same as just a while

1172
00:53:05,160 --> 00:53:08,570
loop if we were to just
copy the while loop above.

1173
00:53:08,570 --> 00:53:12,440
So in this case, your while loop is
going to check the condition first.

1174
00:53:12,440 --> 00:53:15,300
So in this case, if we tried
to write as just a while loop,

1175
00:53:15,300 --> 00:53:18,010
it would say while
input is less than one.

1176
00:53:18,010 --> 00:53:20,801
But we don't have an input for it.

1177
00:53:20,801 --> 00:53:24,238
>> AUDIENCE: If you [INAUDIBLE]
while loop including this code,

1178
00:53:24,238 --> 00:53:28,166
but then you coped the code
above the while loop also.

1179
00:53:28,166 --> 00:53:31,052
You just had this code
[INAUDIBLE] while loop.

1180
00:53:31,052 --> 00:53:32,760
ALLISON: It would be
the same thing, yes.

1181
00:53:32,760 --> 00:53:37,110
So you could just write--
instead of having a do-- yes.

1182
00:53:37,110 --> 00:53:37,976

1183
00:53:37,976 --> 00:53:39,350
GABRIEL: But that's more elegant.

1184
00:53:39,350 --> 00:53:41,020
ALLISON: Yeah, that's more elegant.

1185
00:53:41,020 --> 00:53:44,560
You can get into design and whatnot,
but yes, you can totally do that.

1186
00:53:44,560 --> 00:53:45,850

1187
00:53:45,850 --> 00:53:47,072
Any other questions?

1188
00:53:47,072 --> 00:53:49,240

1189
00:53:49,240 --> 00:53:50,250
OK, cool.

1190
00:53:50,250 --> 00:53:55,540
>> So we've talked a lot about conditions
with all these loops that we have,

1191
00:53:55,540 --> 00:53:58,615
so we're actually getting into
conditions in Boolean expressions.

1192
00:53:58,615 --> 00:53:59,990

1193
00:53:59,990 --> 00:54:03,440
Again, you use these in C,
so just kind of transitioning

1194
00:54:03,440 --> 00:54:06,050
from more graphic interface
to actually coding.

1195
00:54:06,050 --> 00:54:07,480

1196
00:54:07,480 --> 00:54:09,100
>> Cool, so big one, if.

1197
00:54:09,100 --> 00:54:11,130

1198
00:54:11,130 --> 00:54:17,070
Basically just allows us to introduce
some logic into our program and check

1199
00:54:17,070 --> 00:54:17,790
sys conditions.

1200
00:54:17,790 --> 00:54:22,150
So in this case, OK,
is n greater than 0?

1201
00:54:22,150 --> 00:54:24,070
Yes it is, so you can execute this.

1202
00:54:24,070 --> 00:54:28,060
It's just checking some
condition that you've

1203
00:54:28,060 --> 00:54:33,565
set, which I think we're all
comfortable with checking conditions.

1204
00:54:33,565 --> 00:54:35,975

1205
00:54:35,975 --> 00:54:36,475
Cool.

1206
00:54:36,475 --> 00:54:38,760

1207
00:54:38,760 --> 00:54:44,530
So if else is your other one,
you can say OK, if this is true,

1208
00:54:44,530 --> 00:54:46,150
do this first thing.

1209
00:54:46,150 --> 00:54:48,720
Otherwise I want you to
default and do something else.

1210
00:54:48,720 --> 00:54:51,977

1211
00:54:51,977 --> 00:54:55,060
Like in this case, you either pick a
positive number or a negative number.

1212
00:54:55,060 --> 00:54:56,500
You only have two options.

1213
00:54:56,500 --> 00:54:59,550
You need it to execute regardless
of what your user inputs.

1214
00:54:59,550 --> 00:55:02,920
So you can say well,
is it greater than 0?

1215
00:55:02,920 --> 00:55:03,480
Cool.

1216
00:55:03,480 --> 00:55:04,480
Print a positive number.

1217
00:55:04,480 --> 00:55:06,153
If it's not, print a negative.

1218
00:55:06,153 --> 00:55:06,960
Everyone good?

1219
00:55:06,960 --> 00:55:14,920
>> And then one thing to recognize is
that if the if condition is met,

1220
00:55:14,920 --> 00:55:16,650
the else will never also execute.

1221
00:55:16,650 --> 00:55:19,210
Only one of these will
execute at a time.

1222
00:55:19,210 --> 00:55:20,410
So it's a trade off.

1223
00:55:20,410 --> 00:55:21,720
You don't get to have both.

1224
00:55:21,720 --> 00:55:23,566
You either have the first condition.

1225
00:55:23,566 --> 00:55:25,440
You either have the if
or the else, not both.

1226
00:55:25,440 --> 00:55:26,849

1227
00:55:26,849 --> 00:55:28,890
Which then can make things
even more complicated,

1228
00:55:28,890 --> 00:55:31,060
because you can do if,
else it, and then else.

1229
00:55:31,060 --> 00:55:32,810
So in this case, we
have three conditions.

1230
00:55:32,810 --> 00:55:34,830

1231
00:55:34,830 --> 00:55:38,370
And again, only one of these is
going to end up being executed.

1232
00:55:38,370 --> 00:55:41,030
So you might be wondering
well, what if you

1233
00:55:41,030 --> 00:55:45,510
have something that
can meet two of these.

1234
00:55:45,510 --> 00:55:49,520
Maybe whatever you're inputting
meets both the condition

1235
00:55:49,520 --> 00:55:51,811
for if and the else if.

1236
00:55:51,811 --> 00:55:53,060
Only thing that's going to run

1237
00:55:53,060 --> 00:55:56,240
>> ALLISON: As soon as it finds something
that it meets the condition for that

1238
00:55:56,240 --> 00:55:59,790
evaluates to true, that's what
it's going to run and nothing else.

1239
00:55:59,790 --> 00:56:04,440
So if you had is this number
between 0 and 5 for your first one,

1240
00:56:04,440 --> 00:56:10,530
or is this number between 3
and 5 for the else if part,

1241
00:56:10,530 --> 00:56:15,550
and you input the number--
I said 0 and 5 and-- 4.

1242
00:56:15,550 --> 00:56:18,110
It's going to hit the first one.

1243
00:56:18,110 --> 00:56:20,960
It's going to say OK, this
number is between 0 and 5.

1244
00:56:20,960 --> 00:56:22,480
Execute and leave.

1245
00:56:22,480 --> 00:56:25,340
It will never hit that second option.

1246
00:56:25,340 --> 00:56:26,394
Cool?

1247
00:56:26,394 --> 00:56:27,250
Awesome.

1248
00:56:27,250 --> 00:56:31,300
>> OK we also have switch statements if
you want to get even more-- or sorry,

1249
00:56:31,300 --> 00:56:31,965
switch is next.

1250
00:56:31,965 --> 00:56:33,540

1251
00:56:33,540 --> 00:56:34,990
I'm getting ahead of myself here.

1252
00:56:34,990 --> 00:56:36,370

1253
00:56:36,370 --> 00:56:39,210
Again, multiple if blocks
where as I just said

1254
00:56:39,210 --> 00:56:45,600
is as soon as you find a condition
that's met and an if else if else,

1255
00:56:45,600 --> 00:56:46,630
it leaves.

1256
00:56:46,630 --> 00:56:49,560
If you need to check
multiple things, you're

1257
00:56:49,560 --> 00:56:53,000
going to want to use this because
it will check every time here.

1258
00:56:53,000 --> 00:56:58,060
So this will run through and if
it's greater than or equal to 90,

1259
00:56:58,060 --> 00:56:59,160
it's going to print that.

1260
00:56:59,160 --> 00:57:00,530

1261
00:57:00,530 --> 00:57:03,600
And it will run through and
check every single one of these.

1262
00:57:03,600 --> 00:57:06,444
>> AUDIENCE: So this would be
more buggy than [INAUDIBLE].

1263
00:57:06,444 --> 00:57:07,735
Would this be like [INAUDIBLE]?

1264
00:57:07,735 --> 00:57:10,990

1265
00:57:10,990 --> 00:57:15,740
>> ALLISON: The question is would this be
buggy or does this do what you want.

1266
00:57:15,740 --> 00:57:19,830
It really depends on what
you want from your program.

1267
00:57:19,830 --> 00:57:22,291
>> AUDIENCE: I mean like if you put 90 in.

1268
00:57:22,291 --> 00:57:23,290
ALLISON: If you put 90--

1269
00:57:23,290 --> 00:57:24,206
AUDIENCE: [INAUDIBLE].

1270
00:57:24,206 --> 00:57:25,584

1271
00:57:25,584 --> 00:57:27,250
GABRIEL: You're going to get two things.

1272
00:57:27,250 --> 00:57:28,916
ALLISON: You're going to get two things.

1273
00:57:28,916 --> 00:57:29,420
Yes, two.

1274
00:57:29,420 --> 00:57:32,420

1275
00:57:32,420 --> 00:57:33,920
>> ROB BOWDEN: Two?

1276
00:57:33,920 --> 00:57:34,580
>> ALLISON: No.

1277
00:57:34,580 --> 00:57:35,288
>> ROB BOWDEN: Four.

1278
00:57:35,288 --> 00:57:37,070

1279
00:57:37,070 --> 00:57:40,070
If you put 90, it's going to say you
got an A, you got a B, you got a C,

1280
00:57:40,070 --> 00:57:40,545
you got a D.

1281
00:57:40,545 --> 00:57:41,461
>> AUDIENCE: [INAUDIBLE].

1282
00:57:41,461 --> 00:57:42,196

1283
00:57:42,196 --> 00:57:42,820
ALLISON: Right.

1284
00:57:42,820 --> 00:57:44,778
So I depends on what you
want from you program.

1285
00:57:44,778 --> 00:57:47,050
Sometimes you need to
check multiple things.

1286
00:57:47,050 --> 00:57:49,970

1287
00:57:49,970 --> 00:57:55,270
You'll get much deeper into what
good design is as you go forward.

1288
00:57:55,270 --> 00:57:57,090
The important thing to
realize is that this

1289
00:57:57,090 --> 00:58:01,090
will check all four conditions here.

1290
00:58:01,090 --> 00:58:05,860
Whereas if this were an if else if else
if else, it would hit that first case,

1291
00:58:05,860 --> 00:58:07,950
it would print you got an A and be done.

1292
00:58:07,950 --> 00:58:10,250
>> ROB BOWDEN: Even if we
decided to change this to if

1293
00:58:10,250 --> 00:58:13,880
and greater than or equal to 90,
if and greater than or equal to 80,

1294
00:58:13,880 --> 00:58:19,710
and less than or equal to 89, if
n greater than or equal to 70,

1295
00:58:19,710 --> 00:58:23,830
and n less than or equal to
79, so that will be correct.

1296
00:58:23,830 --> 00:58:27,190
That will do what we want, but
it still checks every single it.

1297
00:58:27,190 --> 00:58:34,050
>> So whereas in the first scenario, if we
enter 90 with just if else if else if,

1298
00:58:34,050 --> 00:58:37,300
and we enter 90, then
it's going to correct.

1299
00:58:37,300 --> 00:58:39,615
It will check the first
one, print you got an A,

1300
00:58:39,615 --> 00:58:42,590
skip everything, because it
already found one that works.

1301
00:58:42,590 --> 00:58:46,360
All cases are mutually exclusive
based on if else if else if.

1302
00:58:46,360 --> 00:58:48,630
So it'll execute the
first if, then it's done.

1303
00:58:48,630 --> 00:58:49,790
It'll go to the end.

1304
00:58:49,790 --> 00:58:52,400
>> Whereas if we change
this to be what I was

1305
00:58:52,400 --> 00:58:54,204
saying with less than or equal to 89.

1306
00:58:54,204 --> 00:58:55,620
It's going to check the first one.

1307
00:58:55,620 --> 00:58:56,560
It'll print.

1308
00:58:56,560 --> 00:58:58,010
It'll check the second one.

1309
00:58:58,010 --> 00:58:59,010
It's not going to print.

1310
00:58:59,010 --> 00:58:59,910
Check the third one.

1311
00:58:59,910 --> 00:59:00,620
Not going to print.

1312
00:59:00,620 --> 00:59:01,495
Check the fourth one.

1313
00:59:01,495 --> 00:59:02,420
Now going to print.

1314
00:59:02,420 --> 00:59:05,380
So in that case, the else if
version, since these cases

1315
00:59:05,380 --> 00:59:09,120
are mutually exclusive, it's
better use if else if else if,

1316
00:59:09,120 --> 00:59:12,970
because that is going to have
fewer checks of the conditions

1317
00:59:12,970 --> 00:59:14,750
than this version.

1318
00:59:14,750 --> 00:59:17,692

1319
00:59:17,692 --> 00:59:18,400
ALLISON: Awesome.

1320
00:59:18,400 --> 00:59:20,580
So another thing we can
do is switch statements.

1321
00:59:20,580 --> 00:59:23,104

1322
00:59:23,104 --> 00:59:25,270
Basically a switch statement
takes in some variable,

1323
00:59:25,270 --> 00:59:28,780
in this case it's n, and
determines which case to execute.

1324
00:59:28,780 --> 00:59:33,106
So this is also one where your cases
should be kind of mutually exclusive.

1325
00:59:33,106 --> 00:59:35,210

1326
00:59:35,210 --> 00:59:37,940
So in this case, if
we we get a one, it's

1327
00:59:37,940 --> 00:59:42,270
going to match whatever that
variable-- whatever the value of n

1328
00:59:42,270 --> 00:59:48,700
is to one of these cases, so 1, 2, or
3, and print out the corresponding line.

1329
00:59:48,700 --> 00:59:51,870
>> And then if you notice here,
we also have a default,

1330
00:59:51,870 --> 00:59:54,670
which you can of think of as your else.

1331
00:59:54,670 --> 00:59:58,510
So if you pick any other number
besides 1, 2, and 3 in this case

1332
00:59:58,510 --> 00:59:59,885
it's just going to print invalid.

1333
00:59:59,885 --> 01:00:03,690

1334
01:00:03,690 --> 01:00:08,390
Deciding when to use ifs versus
if elses versus switches is going

1335
01:00:08,390 --> 01:00:12,590
to be something that you guys will
see design wise as you start writing

1336
01:00:12,590 --> 01:00:15,270
more complicated programs, and
there's no hard and fast rules

1337
01:00:15,270 --> 01:00:16,330
of when to use them.

1338
01:00:16,330 --> 01:00:17,890
It really depends on your context.

1339
01:00:17,890 --> 01:00:18,590
>> ROB BOWDEN: And just
to throw it out there

1340
01:00:18,590 --> 01:00:20,131
since it is more comfortable section.

1341
01:00:20,131 --> 01:00:20,920

1342
01:00:20,920 --> 01:00:25,053
Switches, they tend to
be-- so you're limited

1343
01:00:25,053 --> 01:00:27,430
in the number of ways you
can use them, because ifs,

1344
01:00:27,430 --> 01:00:30,100
the condition can be pretty
much anything you want.

1345
01:00:30,100 --> 01:00:33,410
With switches the cases
have to be numbers,

1346
01:00:33,410 --> 01:00:37,770
or technically they can be chars, but
chars, as we'll see, are just numbers.

1347
01:00:37,770 --> 01:00:44,250
So they have to be numbers, but switches
are really more efficient than if

1348
01:00:44,250 --> 01:00:50,060
else if else if, because even
taking the example before-- well,

1349
01:00:50,060 --> 01:00:51,486
the grade example seems good.

1350
01:00:51,486 --> 01:00:52,550

1351
01:00:52,550 --> 01:00:57,080
>> Well let's say here, we instead do
this as an if else if else if scenario.

1352
01:00:57,080 --> 01:01:00,930
So if n equals equals 1,
print you picked a low number.

1353
01:01:00,930 --> 01:01:04,490
If else if n equals equals 2,
you picked a medium number.

1354
01:01:04,490 --> 01:01:06,550
Else if equals equals 3, high.

1355
01:01:06,550 --> 01:01:08,060
Else invalid.

1356
01:01:08,060 --> 01:01:09,820
>> So let's say that was our scenario.

1357
01:01:09,820 --> 01:01:14,060
So let's say we enter
4, so we expect invalid.

1358
01:01:14,060 --> 01:01:17,410
The way that if else if else
if approach is going to work is

1359
01:01:17,410 --> 01:01:18,740
checks the first condition.

1360
01:01:18,740 --> 01:01:19,776
It's not satisfied.

1361
01:01:19,776 --> 01:01:21,150
So we check the second condition.

1362
01:01:21,150 --> 01:01:21,940
It's not satisfied.

1363
01:01:21,940 --> 01:01:23,023
Check the third condition.

1364
01:01:23,023 --> 01:01:23,640
Not satisfied.

1365
01:01:23,640 --> 01:01:26,650
So we go to the else and print invalid.

1366
01:01:26,650 --> 01:01:30,169
>> The way the switch works
is it compiles down

1367
01:01:30,169 --> 01:01:31,960
into what we're going
to call a jump table.

1368
01:01:31,960 --> 01:01:33,180

1369
01:01:33,180 --> 01:01:37,120
The main idea being
that when you enter 4,

1370
01:01:37,120 --> 01:01:39,090
it can immediately go to the default.

1371
01:01:39,090 --> 01:01:41,460
It doesn't need to check am I case 1?

1372
01:01:41,460 --> 01:01:42,350
Nope that's not it.

1373
01:01:42,350 --> 01:01:42,850
Case 2?

1374
01:01:42,850 --> 01:01:43,240
Nope.

1375
01:01:43,240 --> 01:01:43,770
Case 3?

1376
01:01:43,770 --> 01:01:44,270
Nope.

1377
01:01:44,270 --> 01:01:45,090
Default.

1378
01:01:45,090 --> 01:01:47,610
OK, this must be where I
want, and then execute that.

1379
01:01:47,610 --> 01:01:49,590
No, it immediately jumps to the default.

1380
01:01:49,590 --> 01:01:51,900
Or it I enter 2, it's
immediately going to go to the 2

1381
01:01:51,900 --> 01:01:54,060
without needing to go through case 1.

1382
01:01:54,060 --> 01:01:57,820
>> So in that way,
realistically nowadays that's

1383
01:01:57,820 --> 01:02:00,250
not that much of an efficiency gain.

1384
01:02:00,250 --> 01:02:02,880
Usually computers are pretty
fast, and that's not that great.

1385
01:02:02,880 --> 01:02:07,270
But it is the case that
switches are faster.

1386
01:02:07,270 --> 01:02:10,380
If you're really trying
to optimize, use a switch.

1387
01:02:10,380 --> 01:02:11,980

1388
01:02:11,980 --> 01:02:12,710
>> ALLISON: Cool.

1389
01:02:12,710 --> 01:02:15,270
And then we have ternary operator.

1390
01:02:15,270 --> 01:02:19,470
So I know I mentioned earlier
the word syntactic sugar.

1391
01:02:19,470 --> 01:02:24,160
So it's just things that make
your code much more concise.

1392
01:02:24,160 --> 01:02:25,590
So this is one of those cases.

1393
01:02:25,590 --> 01:02:31,430
>> So ternary operator is question mark
colon as we see in the line string

1394
01:02:31,430 --> 01:02:35,810
s equals n greater than 100
question mark high colon low.

1395
01:02:35,810 --> 01:02:41,800
So basically how this works is it's
the n greater than 100 is a condition.

1396
01:02:41,800 --> 01:02:43,674
So I think it can make sense.

1397
01:02:43,674 --> 01:02:44,840
It's like asking a question.

1398
01:02:44,840 --> 01:02:47,320
It's saying oh, is n greater than 100.

1399
01:02:47,320 --> 01:02:48,340
Who knows?

1400
01:02:48,340 --> 01:02:50,750
And if it evaluates to
true, it's going to give you

1401
01:02:50,750 --> 01:02:54,270
the first thing that's
listed there, which is high.

1402
01:02:54,270 --> 01:02:55,840
Otherwise it's going to give you low.

1403
01:02:55,840 --> 01:03:01,210
So this is just a really simple and
efficient way to do like an if else.

1404
01:03:01,210 --> 01:03:02,780
That's all this is.

1405
01:03:02,780 --> 01:03:07,450
>> And if we were to write this
as an if else conditional,

1406
01:03:07,450 --> 01:03:12,480
it would be if n is greater
than 100, return high.

1407
01:03:12,480 --> 01:03:14,220
Else, return low.

1408
01:03:14,220 --> 01:03:17,570
This is just a much more
concise way of writing it.

1409
01:03:17,570 --> 01:03:27,090
>> ROB BOWDEN: So this particular example
is whenever you're doing something

1410
01:03:27,090 --> 01:03:30,190
like this, this is the pattern
where I use ternary very frequently.

1411
01:03:30,190 --> 01:03:31,540

1412
01:03:31,540 --> 01:03:35,460
So we haven't talked about scope yet,
but I hate seeing string s semicolon.

1413
01:03:35,460 --> 01:03:39,150
If n greater than 100, s equals high.

1414
01:03:39,150 --> 01:03:40,660
Else, s equals low.

1415
01:03:40,660 --> 01:03:45,070
So that pattern, those five lines
of code literally 100% of the time

1416
01:03:45,070 --> 01:03:49,800
can be transferred into what
was up there with a ternary.

1417
01:03:49,800 --> 01:03:52,340
So the ternary, one line of code.

1418
01:03:52,340 --> 01:03:54,640
The if else, five.

1419
01:03:54,640 --> 01:03:56,910
That's an example I point
out every single time.

1420
01:03:56,910 --> 01:03:59,250
This would great place
for a ternary operator.

1421
01:03:59,250 --> 01:04:00,647
It's so clean.

1422
01:04:00,647 --> 01:04:01,980
But people tend to never use it.

1423
01:04:01,980 --> 01:04:06,140

1424
01:04:06,140 --> 01:04:08,030
>> ALLISON: Take it away Gabe.

1425
01:04:08,030 --> 01:04:11,110
>> GABRIEL: So now you guys all
learned in lecture this week

1426
01:04:11,110 --> 01:04:13,420
that everything in a
computer is binary, right?

1427
01:04:13,420 --> 01:04:14,570
Just like the lamps here.

1428
01:04:14,570 --> 01:04:16,492
You can be either turned on and off.

1429
01:04:16,492 --> 01:04:18,450
And by everything, I mean
literally everything.

1430
01:04:18,450 --> 01:04:24,272
Some numbers, and chars, and strings,
and even the code that you write when

1431
01:04:24,272 --> 01:04:26,480
it gets compiled to machine
code and stuff like that,

1432
01:04:26,480 --> 01:04:29,230
so it all boils down to 0's and 1'.

1433
01:04:29,230 --> 01:04:34,540
>> And so when we're dealing
with integers, which

1434
01:04:34,540 --> 01:04:38,000
is something that's technically very
simple, we should be able to do stuff

1435
01:04:38,000 --> 01:04:40,630
like adding them, which is
probably one of the simplest things

1436
01:04:40,630 --> 01:04:42,300
you can do to two integers, right?

1437
01:04:42,300 --> 01:04:47,410
So addition and subtraction works just
like it works in decimal notation,

1438
01:04:47,410 --> 01:04:50,780
except here it's binary, right?

1439
01:04:50,780 --> 01:04:52,090
So it's in base two.

1440
01:04:52,090 --> 01:04:54,070
So add 1 plus 1.

1441
01:04:54,070 --> 01:04:57,020
That gives 0, and 1 carries over.

1442
01:04:57,020 --> 01:05:01,335
And just keep doing that, So now
comes the more interesting question.

1443
01:05:01,335 --> 01:05:03,730

1444
01:05:03,730 --> 01:05:07,710
>> We know how to represent all
positive integers in the computer,

1445
01:05:07,710 --> 01:05:09,870
but let's make this an exercise.

1446
01:05:09,870 --> 01:05:15,240
Pretend you guys are all in 1960 or
something trying to create a computer,

1447
01:05:15,240 --> 01:05:19,950
and you have to come up of
a way of storing minus 1,

1448
01:05:19,950 --> 01:05:22,554
for example, or minus any
integer for that matter.

1449
01:05:22,554 --> 01:05:23,470
How would you do that?

1450
01:05:23,470 --> 01:05:27,820

1451
01:05:27,820 --> 01:05:29,220
Any ideas?

1452
01:05:29,220 --> 01:05:31,302
Just throw anything at me.

1453
01:05:31,302 --> 01:05:32,264
Yes?

1454
01:05:32,264 --> 01:05:39,480
>> AUDIENCE: [INAUDIBLE] designate
a special if your [INAUDIBLE].

1455
01:05:39,480 --> 01:05:42,590
>> GABRIEL: You can designate a
special bit, which will be 0 or 1.

1456
01:05:42,590 --> 01:05:45,590
Let's say one if it's positive
and 0 if it's negative.

1457
01:05:45,590 --> 01:05:48,171
And then the rest of the bit
is just to store the number.

1458
01:05:48,171 --> 01:05:48,670
Cool.

1459
01:05:48,670 --> 01:05:49,990
So that's a very good idea.

1460
01:05:49,990 --> 01:05:51,550
We have, I don't know, 200.

1461
01:05:51,550 --> 01:05:54,720
And if the first bit is
turned on, then it's plus 200.

1462
01:05:54,720 --> 01:05:57,270
If it's turned off, it is minus 200.

1463
01:05:57,270 --> 01:05:58,380
Cool.

1464
01:05:58,380 --> 01:06:01,350
>> There is only one small
problem with this,

1465
01:06:01,350 --> 01:06:05,370
which is if we try to sum things up.

1466
01:06:05,370 --> 01:06:18,910
So imagine we have 11111 here, and
we're summing this with 00100 whatever.

1467
01:06:18,910 --> 01:06:21,630
If those two are positive, that's fine.

1468
01:06:21,630 --> 01:06:24,470
But then if one of
them is negative, like

1469
01:06:24,470 --> 01:06:27,410
let's say that this bit here
is the one that's responsible

1470
01:06:27,410 --> 01:06:31,390
for-- I'm going to make a separate--
so this one means that this number here

1471
01:06:31,390 --> 01:06:31,970
is positive.

1472
01:06:31,970 --> 01:06:34,450
This one means that this
number here is negative, right?

1473
01:06:34,450 --> 01:06:37,010
>> But then when you're
going to sum them, you

1474
01:06:37,010 --> 01:06:40,180
need an if statement
saying oh if this is 0,

1475
01:06:40,180 --> 01:06:43,479
then my sum will be
something different, right?

1476
01:06:43,479 --> 01:06:45,270
So there's a slightly
more clever way to do

1477
01:06:45,270 --> 01:06:48,520
that, which is called two's complement.

1478
01:06:48,520 --> 01:06:52,350
So basically what we
do is we define minus 1

1479
01:06:52,350 --> 01:06:57,250
to be the thing that if
we add up to 1 gives us 0.

1480
01:06:57,250 --> 01:06:59,470

1481
01:06:59,470 --> 01:07:00,860
Let me repeat that.

1482
01:07:00,860 --> 01:07:03,280
So let's say that this here is 1.

1483
01:07:03,280 --> 01:07:08,110

1484
01:07:08,110 --> 01:07:13,570
What is the thing that
naturally in positive integers

1485
01:07:13,570 --> 01:07:15,570
added to that gives us 0?

1486
01:07:15,570 --> 01:07:19,150

1487
01:07:19,150 --> 01:07:21,030
What if we try to add it to this number?

1488
01:07:21,030 --> 01:07:22,830

1489
01:07:22,830 --> 01:07:28,032
We're going to have-- OK, so let's add.

1490
01:07:28,032 --> 01:07:32,820

1491
01:07:32,820 --> 01:07:38,065
We're going to have 1 plus 1
is 0, and then it carries over.

1492
01:07:38,065 --> 01:07:40,160

1493
01:07:40,160 --> 01:07:45,490
And then we're going to get 0 again.

1494
01:07:45,490 --> 01:07:47,730

1495
01:07:47,730 --> 01:07:48,820
I'm getting confused.

1496
01:07:48,820 --> 01:07:51,670
And you're going to get 0 and
0 and 0 and 0 and 0 and 0.

1497
01:07:51,670 --> 01:07:52,450
Lots of 0's.

1498
01:07:52,450 --> 01:07:56,240
>> At the very last one, we're not
going to be able to carry it over,

1499
01:07:56,240 --> 01:07:59,614
because let's say we're only dealing
with one byte, so only 8 bits.

1500
01:07:59,614 --> 01:08:02,780
So what the computer does by default
is just forgets about that [INAUDIBLE],

1501
01:08:02,780 --> 01:08:03,279
OK?

1502
01:08:03,279 --> 01:08:04,530

1503
01:08:04,530 --> 01:08:06,880
So this is what is called
the two's complement.

1504
01:08:06,880 --> 01:08:15,180
We simply define minus 1 to be the
thing here that if you add that to 1

1505
01:08:15,180 --> 01:08:15,995
would give you 0.

1506
01:08:15,995 --> 01:08:17,609

1507
01:08:17,609 --> 01:08:20,180
And that's pretty cool
because we don't really

1508
01:08:20,180 --> 01:08:24,090
need late to implement
a different type of sum

1509
01:08:24,090 --> 01:08:26,590
depending on whether that's a
negative or a positive number.

1510
01:08:26,590 --> 01:08:27,465
Does that make sense?

1511
01:08:27,465 --> 01:08:28,740

1512
01:08:28,740 --> 01:08:32,370
>> So one thing that we do
here in order to convert

1513
01:08:32,370 --> 01:08:38,550
between a positive and a negative
integer is then we flip everything,

1514
01:08:38,550 --> 01:08:40,930
and then we add 1 to that number.

1515
01:08:40,930 --> 01:08:43,140
If you try to do it yourself
on a piece of paper,

1516
01:08:43,140 --> 01:08:44,681
you're going to see that makes sense.

1517
01:08:44,681 --> 01:08:51,000
But if I take this number
here, this is five.

1518
01:08:51,000 --> 01:08:54,859
So if I flip everything
here, so 1, 1, 1, 1, 1.

1519
01:08:54,859 --> 01:08:55,880

1520
01:08:55,880 --> 01:08:57,830
Flip, flip, flip.

1521
01:08:57,830 --> 01:09:00,130
And then I add 1 to it.

1522
01:09:00,130 --> 01:09:02,750
I'm going to have exactly minus 5.

1523
01:09:02,750 --> 01:09:03,250
OK?

1524
01:09:03,250 --> 01:09:06,220
>> This kind of makes sense because if
you try to sum this with the number

1525
01:09:06,220 --> 01:09:10,229
that we had before, which
was-- let's flip this again.

1526
01:09:10,229 --> 01:09:12,999
It was 101 and lots of 0's.

1527
01:09:12,999 --> 01:09:13,795

1528
01:09:13,795 --> 01:09:15,670
If you try to add these
two numbers together,

1529
01:09:15,670 --> 01:09:16,961
you're going to have exactly 0.

1530
01:09:16,961 --> 01:09:18,920

1531
01:09:18,920 --> 01:09:19,460
OK.

1532
01:09:19,460 --> 01:09:19,884
Any questions?

1533
01:09:19,884 --> 01:09:20,759
>> AUDIENCE: [INAUDIBLE]

1534
01:09:20,759 --> 01:09:25,790

1535
01:09:25,790 --> 01:09:27,280
>> GABRIEL: What do you mean?

1536
01:09:27,280 --> 01:09:29,240
>> AUDIENCE: Negative to
positive [INAUDIBLE].

1537
01:09:29,240 --> 01:09:33,215
>> GABRIEL: No, you flip
and you add 1 always.

1538
01:09:33,215 --> 01:09:34,081

1539
01:09:34,081 --> 01:09:34,580
Yeah.

1540
01:09:34,580 --> 01:09:36,910

1541
01:09:36,910 --> 01:09:39,680
OK, so characters also encoded binaries.

1542
01:09:39,680 --> 01:09:42,649
We have ASCII table, as you
also saw in lecture, right?

1543
01:09:42,649 --> 01:09:45,040
So it's basically a mapping of things.

1544
01:09:45,040 --> 01:09:50,960
And here I can't emphasize enough
that for a computer, a and 65

1545
01:09:50,960 --> 01:09:52,770
are literally the same thing.

1546
01:09:52,770 --> 01:10:03,430
So if I write something like char c
equals a, I could at the same time

1547
01:10:03,430 --> 01:10:06,890
just write 65 here, and it
would be exactly the same, OK?

1548
01:10:06,890 --> 01:10:08,470
There's no difference whatsoever.

1549
01:10:08,470 --> 01:10:12,420
>> We usually tend to put
characters in variables of type.

1550
01:10:12,420 --> 01:10:16,770
Char, not because they're essentially
made for that, but because

1551
01:10:16,770 --> 01:10:18,050
of human convention.

1552
01:10:18,050 --> 01:10:22,410
But you can just deal with integers
instead of variables of type char,

1553
01:10:22,410 --> 01:10:23,490
and you'll be fine.

1554
01:10:23,490 --> 01:10:28,410
The only actual difference
between a char c and an int i

1555
01:10:28,410 --> 01:10:31,960
is that an int has four bytes in most
systems, while a char has one byte.

1556
01:10:31,960 --> 01:10:33,070

1557
01:10:33,070 --> 01:10:35,460
They're essentially the
same thing in terms of data.

1558
01:10:35,460 --> 01:10:36,990

1559
01:10:36,990 --> 01:10:37,990
So what will print here?

1560
01:10:37,990 --> 01:10:43,780
Here we're printing a digit using printf
with a plus 1, and just like integers,

1561
01:10:43,780 --> 01:10:46,240
chars can be summed, so
characters can also be summed.

1562
01:10:46,240 --> 01:10:47,890
So this is exactly 65.

1563
01:10:47,890 --> 01:10:49,950
So there's going to be
66, and here we have

1564
01:10:49,950 --> 01:10:56,860
65 plus little a minus big A,
which will be, I don't really know.

1565
01:10:56,860 --> 01:11:00,900
But it will be exactly the gap
between the capital letters

1566
01:11:00,900 --> 01:11:07,800
and and the smaller letters, so
we're going to get small a, right?

1567
01:11:07,800 --> 01:11:08,300
Yeah.

1568
01:11:08,300 --> 01:11:11,740
So this is going to print a
character which is exactly this one.

1569
01:11:11,740 --> 01:11:12,260
Good?

1570
01:11:12,260 --> 01:11:12,860
Any questions?

1571
01:11:12,860 --> 01:11:16,320

1572
01:11:16,320 --> 01:11:19,430
>> Here we have a bunch of different
types for numerical variables.

1573
01:11:19,430 --> 01:11:20,620
We already talk about int.

1574
01:11:20,620 --> 01:11:21,740

1575
01:11:21,740 --> 01:11:27,760
Float is just a way to-- this is really
funny, because when I first learned

1576
01:11:27,760 --> 01:11:32,320
to program back in the day with
Python, the first program I ever

1577
01:11:32,320 --> 01:11:37,480
tried to write, I saw that there was a
type called in and a type called float.

1578
01:11:37,480 --> 01:11:39,800
And the float was for all real numbers.

1579
01:11:39,800 --> 01:11:43,290
So then I asked why should
I ever use an int then?

1580
01:11:43,290 --> 01:11:45,590
Because if I can use all
real numbers with a float,

1581
01:11:45,590 --> 01:11:47,120
I would just stop using ints, right?

1582
01:11:47,120 --> 01:11:49,550
Because real numbers are
much like more generic.

1583
01:11:49,550 --> 01:11:51,820

1584
01:11:51,820 --> 01:11:54,060
>> It turns out that this is
not the case in computers

1585
01:11:54,060 --> 01:11:58,480
because they're essentially
different things.

1586
01:11:58,480 --> 01:12:01,470
So integers and floats, the
operations that you do to them

1587
01:12:01,470 --> 01:12:04,739
are essentially different because
of the way that they are stored, OK?

1588
01:12:04,739 --> 01:12:07,280
We're going to talk a little
bit more about that in a second.

1589
01:12:07,280 --> 01:12:09,110
>> So double is just a bigger float.

1590
01:12:09,110 --> 01:12:12,830
Usually in most systems, a float
is four bytes, just like an int.

1591
01:12:12,830 --> 01:12:15,440
And a double is eight bytes.

1592
01:12:15,440 --> 01:12:21,450
A long long is actually just a symbol
that you append to a type like int.

1593
01:12:21,450 --> 01:12:24,040
You say long long int like this.

1594
01:12:24,040 --> 01:12:28,550
Long long int x to make it longer.

1595
01:12:28,550 --> 01:12:32,310
So in most systems, that will give
eight bytes instead of the usual four.

1596
01:12:32,310 --> 01:12:35,620
And you can actually drop the
in, so it can just say long long,

1597
01:12:35,620 --> 01:12:37,240
and that works too, OK?

1598
01:12:37,240 --> 01:12:42,850
You can also do other things like
unsigned int, or again just unsigned

1599
01:12:42,850 --> 01:12:43,680
would also work.

1600
01:12:43,680 --> 01:12:49,370
And that would make x be a variable
like everything is positive,

1601
01:12:49,370 --> 01:12:53,231
so you can't really have negative
numbers in the way that we saw up here.

1602
01:12:53,231 --> 01:12:56,484

1603
01:12:56,484 --> 01:12:58,650
So following wonderful
floating point and precision.

1604
01:12:58,650 --> 01:13:01,890
That's one of the reasons why you
want to use ints instead of floats,

1605
01:13:01,890 --> 01:13:04,370
because ints are 100% precise, right?

1606
01:13:04,370 --> 01:13:06,170
It's exactly that number.

1607
01:13:06,170 --> 01:13:11,910
For floating points, if you
say answer equals 1 over 10--

1608
01:13:11,910 --> 01:13:14,690
I happen to have this exact
program here, float.c.

1609
01:13:14,690 --> 01:13:16,390

1610
01:13:16,390 --> 01:13:19,420
That prints to 20 decimal places.

1611
01:13:19,420 --> 01:13:23,270
1 divided by 10, and that
usually is 0.1, right?

1612
01:13:23,270 --> 01:13:27,910
But here if we make
float and then we run it,

1613
01:13:27,910 --> 01:13:30,320
we see that it's not exactly 0.1.

1614
01:13:30,320 --> 01:13:33,570
It's 0.149 something.

1615
01:13:33,570 --> 01:13:35,570
>> And why is that?

1616
01:13:35,570 --> 01:13:40,390
Because you can't really represent every
single possible real number in memory

1617
01:13:40,390 --> 01:13:42,730
because there are
uncountably many of them.

1618
01:13:42,730 --> 01:13:48,360
So we're technically only able to
represent a finite amount of them

1619
01:13:48,360 --> 01:13:50,470
with a finite amount of data.

1620
01:13:50,470 --> 01:13:52,050
But it's really interesting.

1621
01:13:52,050 --> 01:13:54,920
Now this begs the
question of how you would

1622
01:13:54,920 --> 01:13:59,299
go about representing
this with bits, right?

1623
01:13:59,299 --> 01:14:00,340
So how are floats stored?

1624
01:14:00,340 --> 01:14:01,970

1625
01:14:01,970 --> 01:14:03,730
With integers it was easy.

1626
01:14:03,730 --> 01:14:06,690
But with floats you want
to maximize the range,

1627
01:14:06,690 --> 01:14:10,530
and you want to be able to represent
huge numbers and very tiny numbers like

1628
01:14:10,530 --> 01:14:14,210
0.000001 at the same time.

1629
01:14:14,210 --> 01:14:15,180
So again, same game.

1630
01:14:15,180 --> 01:14:20,470
Does anyone have any idea how we could
go about representing float in memory?

1631
01:14:20,470 --> 01:14:26,820

1632
01:14:26,820 --> 01:14:27,970
Just throw anything.

1633
01:14:27,970 --> 01:14:29,930

1634
01:14:29,930 --> 01:14:30,856
Yes, please.

1635
01:14:30,856 --> 01:14:33,552
>> AUDIENCE: [INAUDIBLE] as
if it was two ints and one

1636
01:14:33,552 --> 01:14:36,890
being the [INAUDIBLE] and one being
everything after the decimal point.

1637
01:14:36,890 --> 01:14:37,640
GABRIEL: OK, cool.

1638
01:14:37,640 --> 01:14:40,300
So two different integers.

1639
01:14:40,300 --> 01:14:45,260
You can have 12.45, so that's 12 and 45.

1640
01:14:45,260 --> 01:14:45,890
Nice.

1641
01:14:45,890 --> 01:14:46,973
What ere you going to say?

1642
01:14:46,973 --> 01:14:48,420

1643
01:14:48,420 --> 01:14:49,430
The same thing?

1644
01:14:49,430 --> 01:14:49,930
Yeah?

1645
01:14:49,930 --> 01:14:55,630
>> AUDIENCE: [INAUDIBLE] notation
where you separate the base.

1646
01:14:55,630 --> 01:14:58,910
>> GABRIEL: Scientific notation,
yeah that's usually what happens.

1647
01:14:58,910 --> 01:15:01,350
So this is what is called the mantissa.

1648
01:15:01,350 --> 01:15:06,490
That's what is actually the
number, and then the exponent

1649
01:15:06,490 --> 01:15:08,780
is just where the comma is, right?

1650
01:15:08,780 --> 01:15:13,720
So this is going to be something
of the form 1, 2, 3, 4, 5 times 10

1651
01:15:13,720 --> 01:15:15,000
to the minus 4.

1652
01:15:15,000 --> 01:15:17,800
I just realized that-- yeah, exactly.

1653
01:15:17,800 --> 01:15:23,372
And then this 10 to the minus 4 is
going to define where the comma is, OK?

1654
01:15:23,372 --> 01:15:24,330
In Brazil we use comma.

1655
01:15:24,330 --> 01:15:26,795
Here you guys use a dot.

1656
01:15:26,795 --> 01:15:27,640
So a dot.

1657
01:15:27,640 --> 01:15:28,860

1658
01:15:28,860 --> 01:15:34,840
>> And this is cool, because then you can
focus lots of your bits on this guy

1659
01:15:34,840 --> 01:15:40,863
here, on the mantissa, and then that's
going to be your actual precision.

1660
01:15:40,863 --> 01:15:41,920

1661
01:15:41,920 --> 01:15:47,175
And you can do this either in decimal
or in the binary based system.

1662
01:15:47,175 --> 01:15:49,781
There are different
ways to implement this.

1663
01:15:49,781 --> 01:15:50,280
Questions?

1664
01:15:50,280 --> 01:15:55,918

1665
01:15:55,918 --> 01:15:56,418
Yes?

1666
01:15:56,418 --> 01:15:57,508

1667
01:15:57,508 --> 01:15:59,841
AUDIENCE: How many places
after the decimal [INAUDIBLE]?

1668
01:15:59,841 --> 01:16:05,240

1669
01:16:05,240 --> 01:16:12,610
>> GABRIEL: That's a complicated question,
because it's never really 100% precise,

1670
01:16:12,610 --> 01:16:15,680
because as you see here, for
some numbers it is 100% precise.

1671
01:16:15,680 --> 01:16:20,350
I believe if we put 0.5 here,
it's going to be 100% precise.

1672
01:16:20,350 --> 01:16:22,220
It's going to be 0.500000.

1673
01:16:22,220 --> 01:16:24,170
So in that case, it's perfect.

1674
01:16:24,170 --> 01:16:27,330
But in other cases,
it's much less perfect.

1675
01:16:27,330 --> 01:16:35,010
In my experience, like up to four,
five decimal places is pretty precise.

1676
01:16:35,010 --> 01:16:38,300
If you use a double, it's going to
be way more precise than that, OK?

1677
01:16:38,300 --> 01:16:42,750
>> ROB BOWDEN: So just to throw
some more context at floats,

1678
01:16:42,750 --> 01:16:46,320
I never remember 100% how the
spec of floats actually works,

1679
01:16:46,320 --> 01:16:52,660
but I do you always remember
that floats start getting messy.

1680
01:16:52,660 --> 01:16:55,460

1681
01:16:55,460 --> 01:17:00,930
So the idea is that when you get really,
really big numbers or really, really

1682
01:17:00,930 --> 01:17:03,470
small numbers, we start
getting worse and worse

1683
01:17:03,470 --> 01:17:05,860
at differentiating
between two close floats.

1684
01:17:05,860 --> 01:17:09,180
>> So how I like to think about is
with floating point imprecision,

1685
01:17:09,180 --> 01:17:11,890
there are two floats that
if I try to specify them

1686
01:17:11,890 --> 01:17:15,150
in C, despite the fact that
they're different numbers,

1687
01:17:15,150 --> 01:17:17,340
they're going to be
interpreted as the same number,

1688
01:17:17,340 --> 01:17:19,006
because we can't store them differently.

1689
01:17:19,006 --> 01:17:20,540
We need to use the same bits.

1690
01:17:20,540 --> 01:17:23,220
And so when we get to
really, really large numbers,

1691
01:17:23,220 --> 01:17:28,460
talking like 10 to the 300 or
something, it's at that point

1692
01:17:28,460 --> 01:17:33,240
that 10 to the 300 or
5 times 10 to the 300

1693
01:17:33,240 --> 01:17:37,020
can't be differentiated
from 7 times 10 to the 300.

1694
01:17:37,020 --> 01:17:39,660
So that's a pretty big difference
between the two numbers.

1695
01:17:39,660 --> 01:17:43,830
>> But then when you get down
to the normal range things,

1696
01:17:43,830 --> 01:17:45,770
you tend to be pretty
good at differentiating.

1697
01:17:45,770 --> 01:17:49,020
And then when you get down really small,
you're also getting pretty bad again.

1698
01:17:49,020 --> 01:17:52,529
So like a whole bunch of
0.0000, it gets pretty bad.

1699
01:17:52,529 --> 01:17:53,820
GABRIEL: Yeah, so a quick note.

1700
01:17:53,820 --> 01:17:54,670
Never do this.

1701
01:17:54,670 --> 01:17:57,590
Never try to compare
floats using equals equals,

1702
01:17:57,590 --> 01:18:02,800
because even if they're almost the
same, almost the same is not the same.

1703
01:18:02,800 --> 01:18:06,360
So what you usually do is you subtract
them, take the absolute value of that,

1704
01:18:06,360 --> 01:18:12,380
and see if that's smaller than
0.0001 or something like that, OK?

1705
01:18:12,380 --> 01:18:12,880
And cool.

1706
01:18:12,880 --> 01:18:16,630
I know a lot of people have
some background in Java,

1707
01:18:16,630 --> 01:18:19,700
especially the ones who did
AP computer science, right?

1708
01:18:19,700 --> 01:18:23,630
And Java is a language
that mostly based on C,

1709
01:18:23,630 --> 01:18:26,570
it has a couple very big differences.

1710
01:18:26,570 --> 01:18:31,430
But for loops, and ifs, and stuff like
that, they're all the same syntax.

1711
01:18:31,430 --> 01:18:35,240
I have a few programs here to show this.

1712
01:18:35,240 --> 01:18:37,050
>> So for example, a simple hello world.

1713
01:18:37,050 --> 01:18:43,140

1714
01:18:43,140 --> 01:18:46,600
This is hello world in C, which you
guys are definitely familiar with,

1715
01:18:46,600 --> 01:18:49,100
and this and this one is in Java.

1716
01:18:49,100 --> 01:18:53,100
So in Java we have this
public class, hello world,

1717
01:18:53,100 --> 01:18:57,050
and public static void
main, and string args.

1718
01:18:57,050 --> 01:18:59,665
The string args are going
to appear in C very shortly.

1719
01:18:59,665 --> 01:19:00,740

1720
01:19:00,740 --> 01:19:01,990
But let's not go there yet.

1721
01:19:01,990 --> 01:19:06,060
Right now we have void here, which means
that main is not take any arguments.

1722
01:19:06,060 --> 01:19:09,220
And then we have
system.out.println, the and that's

1723
01:19:09,220 --> 01:19:11,140
kind of the equivalent for printf.

1724
01:19:11,140 --> 01:19:17,150
Here we don't really need the backslash
n because print ln does that for you.

1725
01:19:17,150 --> 01:19:19,680
It appends the backslash
n at the end of the line.

1726
01:19:19,680 --> 01:19:22,540

1727
01:19:22,540 --> 01:19:30,415
>> But if you go into
something like a for, you

1728
01:19:30,415 --> 01:19:32,590
can see that they're
pretty much the same thing.

1729
01:19:32,590 --> 01:19:37,390
So initialization, and the
condition, and the update

1730
01:19:37,390 --> 01:19:42,050
is-- I missed a space here-- they're
pretty much the same thing, except Java

1731
01:19:42,050 --> 01:19:44,430
has as a few more high level stuff.

1732
01:19:44,430 --> 01:19:46,010

1733
01:19:46,010 --> 01:19:49,610
Here we can do plus I and
Java will automatically

1734
01:19:49,610 --> 01:19:52,730
make this i here, which is
an integer, into a string,

1735
01:19:52,730 --> 01:19:55,200
and then append the
two strings together.

1736
01:19:55,200 --> 01:19:57,570
Here in C we need to do the &%d.

1737
01:19:57,570 --> 01:20:15,310

1738
01:20:15,310 --> 01:20:18,170
The line here, the for
looks exactly the same.

1739
01:20:18,170 --> 01:20:37,760
>> And if we look at if, the ifs
also look exactly the same, right?

1740
01:20:37,760 --> 01:20:39,290

1741
01:20:39,290 --> 01:20:44,650
So the real big differences are
in those things that you see here.

1742
01:20:44,650 --> 01:20:47,530
Public static, void, and
then public class if.

1743
01:20:47,530 --> 01:20:48,990

1744
01:20:48,990 --> 01:20:52,360
So Java has what is
called a virtual machine.

1745
01:20:52,360 --> 01:20:53,560

1746
01:20:53,560 --> 01:21:00,150
And it is very heavily based on what
is called object oriented programming,

1747
01:21:00,150 --> 01:21:04,120
which is a very, very common
paradigm for programming nowadays.

1748
01:21:04,120 --> 01:21:10,870
And this class thing is what you see,
something from object orientation,

1749
01:21:10,870 --> 01:21:14,214
is you create a class and then you
can derive objects from that class.

1750
01:21:14,214 --> 01:21:16,380
We're not going to talk too
much about that in CS50,

1751
01:21:16,380 --> 01:21:18,213
but that's definitely
something really cool,

1752
01:21:18,213 --> 01:21:21,440
especially if you want to go into
more sophisticated web development

1753
01:21:21,440 --> 01:21:24,050
at the end of the course,
like submit your final project

1754
01:21:24,050 --> 01:21:26,430
and some nice frameworks and stuff.

1755
01:21:26,430 --> 01:21:31,250
>> So basically the idea is that you
don't want to re-implement something,

1756
01:21:31,250 --> 01:21:36,330
so you create something that's
very generic, like the shape,

1757
01:21:36,330 --> 01:21:38,310
and then you create
different shapes from it,

1758
01:21:38,310 --> 01:21:40,240
and then from each of
these shapes, you create

1759
01:21:40,240 --> 01:21:45,110
some more specific shapes in three
dimensions or something like that.

1760
01:21:45,110 --> 01:21:48,799
And they have this hierarchy they
inherit from the other ones, so

1761
01:21:48,799 --> 01:21:51,840
all functions and all variables that
the big shape here has, all of these

1762
01:21:51,840 --> 01:21:54,110
are going to have, and all of these are
going to have, and so on and so forth.

1763
01:21:54,110 --> 01:21:55,640
So that's the basic idea.

1764
01:21:55,640 --> 01:21:59,170
>> C doesn't have that, but C++
does have that kind of feature.

1765
01:21:59,170 --> 01:22:02,710
And Java is heavily influenced
by object orientation,

1766
01:22:02,710 --> 01:22:05,310
so that's why you see
class here all the time.

1767
01:22:05,310 --> 01:22:10,790
And the other thing is
this Java virtual machine.

1768
01:22:10,790 --> 01:22:13,790
So this, I think, is a very smart idea .

1769
01:22:13,790 --> 01:22:17,020
So what the folks who
invented java did is

1770
01:22:17,020 --> 01:22:19,630
they didn't want to
compile their code twice

1771
01:22:19,630 --> 01:22:23,990
if they had to run it in a Windows,
or a Mac, or Linux, so what they do

1772
01:22:23,990 --> 01:22:26,740
is they literally run
something like the appliance,

1773
01:22:26,740 --> 01:22:29,630
but you don't really see it happening.

1774
01:22:29,630 --> 01:22:32,430
So they run a virtual machine
inside of your computer, which

1775
01:22:32,430 --> 01:22:34,940
is basically like a
mini operating system.

1776
01:22:34,940 --> 01:22:37,920
And that operating
system's purpose in life

1777
01:22:37,920 --> 01:22:41,430
is just to run what is called byte code.

1778
01:22:41,430 --> 01:22:47,411
>> So instead of in C, the way we would
compile this is make if, and then run

1779
01:22:47,411 --> 01:22:47,910
./if.

1780
01:22:47,910 --> 01:22:53,510

1781
01:22:53,510 --> 01:22:55,290
I forgot the backslash in.

1782
01:22:55,290 --> 01:23:00,240
In Java, you would do first
Java C to compile it, if.c.

1783
01:23:00,240 --> 01:23:06,440

1784
01:23:06,440 --> 01:23:08,252
It's not C. It's dot java.

1785
01:23:08,252 --> 01:23:09,460

1786
01:23:09,460 --> 01:23:12,140
And then you have to run not ./.

1787
01:23:12,140 --> 01:23:15,440
You get this new file
if.class, but you can't really

1788
01:23:15,440 --> 01:23:17,980
run if.class now just
like we did before.

1789
01:23:17,980 --> 01:23:19,440
This is not an executable.

1790
01:23:19,440 --> 01:23:20,630
You have to run.

1791
01:23:20,630 --> 01:23:23,410
You have to feed it into
a program called Java,

1792
01:23:23,410 --> 01:23:28,260
and that program is the virtual machine,
and then you do if.class, or if.

1793
01:23:28,260 --> 01:23:28,760
Yes.

1794
01:23:28,760 --> 01:23:30,890
And then it works.

1795
01:23:30,890 --> 01:23:33,740
OK so this is kind of the
virtual machine happening.

1796
01:23:33,740 --> 01:23:37,700
C does not have that, so if I were to
put this program in a Windows machine,

1797
01:23:37,700 --> 01:23:40,516
it would not work in C. In Java it does.

1798
01:23:40,516 --> 01:23:41,015
Questions?

1799
01:23:41,015 --> 01:23:43,430

1800
01:23:43,430 --> 01:23:44,030
Cool.

1801
01:23:44,030 --> 01:23:47,160
That's if for super section for today.

1802
01:23:47,160 --> 01:23:49,462
